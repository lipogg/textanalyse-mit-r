[["regex.html", "6 Exkurs: Reguläre Ausdrücke 6.1 Was sind reguläre Ausdrücke? 6.2 Reguläre Ausdrücke in R 6.3 Regex Syntax 6.4 Regex für nicht-lateinische Schriften Weiterführende Links", " 6 Exkurs: Reguläre Ausdrücke 6.1 Was sind reguläre Ausdrücke? Reguläre Ausdrücke (oder engl. Regular Expression, kurz: RegEx, RegExp) sind verallgemeinerte Suchmuster (patterns) für Zeichenketten. Mithilfe von regulären Ausdrücken können syntaktische Konstrukte so beschrieben werden, dass sie ein Computer versteht. Ein syntaktisches Konstrukt ist zum Beispiel eine Zahl zwischen 1900 und 2000, eine Telefonnummer, eine Adresse, eine URL oder auch ein bestimmtes Wort in verschiedenen Flexionsformen. Mithilfe von regulären Ausdrücken können also Texte nach bestimmten Mustern durchsucht werden, und die gefundenen Konstrukte können anschließend z.B. entfernt oder bearbeitet werden. Die meisten Programmiersprachen, darunter auch R, stellen Funktionen bereit, welche die Verwendung von regulären Ausdrücken erlauben. 6.2 Reguläre Ausdrücke in R Als Beispieltexte nutzen wir die beiden Märchen Rapunzel und Aschenputtel. Zur Vorbereitung installieren wir die folgenden Pakete… install.packages(c(&quot;readtext&quot;, &quot;stringr&quot;, &quot;quanteda&quot;)) …und laden die installierten Pakete: library(readtext) library(stringr) library(quanteda) 6.2.1 R Base Funktionen In R können Texte nach regulären Ausdrücken entweder mithilfe von R-Basisfunktionen durchsucht werden, oder mithilfe von Funktionen aus spezialisierten Paketen. Zunächst betrachten wir die Basisfunktionen, und lernen später reguläre Ausdrücke selbst kennen: Funktion Bedeutung grep(), grepl() Search for matches of a regular expression/pattern in a character vector; either return the indices into the character vector that match, the strings that happen to match, or a TRUE/FALSE vector indicating which elements match. regexpr(), gregexpr() Search a character vector for regular expression matches and return the indices of the string where the match begins and the length of the match. sub(), gsub() Search a character vector for regular expression matches and replace that match with another string. Quelle: https://www.youtube.com/watch?v=q8SzNKib5-4 Offizielle Dokumentation: https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/grep Wir verwenden die readtext()-Funktion zum Einlesen unserer Märchen. maerchen_df &lt;- readtext(c(&quot;data/Rapunzel_(1850).txt&quot;, &quot;data/Aschenputtel_(1850).txt&quot;)) length(maerchen_df$text) ## [1] 2 maerchen_df ## readtext object consisting of 2 documents and 0 docvars. ## $text ## [1] &quot;# A data frame: 2 × 2&quot; ## [2] &quot; doc_id text &quot; ## [3] &quot; &lt;chr&gt; &lt;chr&gt; &quot; ## [4] &quot;1 Aschenputtel_(1850).txt \\&quot;\\\\\\&quot;\\\\nEinem rei\\\\\\&quot;...\\&quot;&quot; ## [5] &quot;2 Rapunzel_(1850).txt \\&quot;\\\\\\&quot;\\\\nEs war ei\\\\\\&quot;...\\&quot;&quot; ## ## $summary ## $summary[[1]] ## NULL ## ## ## attr(,&quot;class&quot;) ## [1] &quot;trunc_mat&quot; Durch Einlesen des Märchens mithilfe der readtext()-Funktion haben wir einen Dataframe mit zwei Spalten und zwei Zeilen erhalten. Wir wollen nicht den gesamten Datafrmae, sondern nur die Märchentexte nach Matches zu durchsuchen und wählen deswegen nur die Spalte text als Eingabe: grep(&quot;Rapunzel&quot;, maerchen_df$text, value=F) ## [1] 2 grepl(&quot;Rapunzel&quot;, maerchen_df$text) ## [1] FALSE TRUE regexpr(&quot;Rapunzel&quot;, maerchen_df$text) ## [1] -1 625 ## attr(,&quot;match.length&quot;) ## [1] -1 8 gregexpr(&quot;Rapunzel&quot;, maerchen_df$text) ## [[1]] ## [1] -1 ## attr(,&quot;match.length&quot;) ## [1] -1 ## ## [[2]] ## [1] 625 751 1005 1176 1334 1903 2077 2334 2672 2709 3006 3016 3056 3527 3972 ## [16] 3982 4026 4287 4297 4415 4729 5380 5782 6006 6117 6264 6274 6406 6697 7162 ## [31] 7376 ## attr(,&quot;match.length&quot;) ## [1] 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 Die Funktionen können aber auch auf jeden Text einzeln angewandt werden, indem separat auf beide Texte zugegriffen wird: grep(&quot;Rapunzel&quot;, maerchen_df$text[2], value=F) ## [1] 1 grepl(&quot;Rapunzel&quot;, maerchen_df$text[2]) ## [1] TRUE regexpr(&quot;Rapunzel&quot;, maerchen_df$text[2]) ## [1] 625 ## attr(,&quot;match.length&quot;) ## [1] 8 gregexpr(&quot;Rapunzel&quot;, maerchen_df$text[2]) ## [[1]] ## [1] 625 751 1005 1176 1334 1903 2077 2334 2672 2709 3006 3016 3056 3527 3972 ## [16] 3982 4026 4287 4297 4415 4729 5380 5782 6006 6117 6264 6274 6406 6697 7162 ## [31] 7376 ## attr(,&quot;match.length&quot;) ## [1] 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 grep(&quot;Rapunzel&quot;, maerchen_df$text[1], value=F) ## integer(0) grepl(&quot;Rapunzel&quot;, maerchen_df$text[1]) ## [1] FALSE regexpr(&quot;Rapunzel&quot;, maerchen_df$text[1]) ## [1] -1 ## attr(,&quot;match.length&quot;) ## [1] -1 gregexpr(&quot;Rapunzel&quot;, maerchen_df$text[1]) ## [[1]] ## [1] -1 ## attr(,&quot;match.length&quot;) ## [1] -1 Verständnisfragen: Interpretiert die Ausgabe der vier Funktionen. Welche Informationen liefern die verschiedenen Funktionen? Wonach wird gesucht? Was wird ausgegeben, wenn das Muster nicht gefunden wird? Die Funktionen regexpr() und gregexpr() können um die Funktion regmatches ergänzt werden, um statt Funstellen die tatsächlich gefundenen Zeichenketten anzuzeigen: regmatches(maerchen_df$text[2], regexpr(&quot;Rapunzel&quot;, maerchen_df$text[2])) ## [1] &quot;Rapunzel&quot; regmatches(maerchen_df$text[2], gregexpr(&quot;Rapunzel&quot;, maerchen_df$text[2])) ## [[1]] ## [1] &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; ## [7] &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; ## [13] &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; ## [19] &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; ## [25] &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; ## [31] &quot;Rapunzel&quot; Da wir nur nach genau der Zeichenkette “Rapunzel” gesucht haben, wird natürlich auch nur “Rapunzel” gefunden. Mithilfe der Funktionen sub() und gsub() können gefundene Zeichenketten gelöscht oder ersetzt werden. Mit der bereits bekannten Funktion grep() können wir daraufhin überprüfen, ob die Zeichenketten erfolgreich ersetzt wurden. # Zeichenkette ersetzen mit gsub() peterpan_1 &lt;- gsub(&quot;Rapunzel&quot;, &quot;Peter Pan&quot;, maerchen_df$text[2]) grepl(&quot;Rapunzel&quot;, peterpan_1) ## [1] FALSE grepl(&quot;Peter Pan&quot;, peterpan_1) ## [1] TRUE # Zeichenkette ersetzen mit sub() peterpan_2 &lt;- sub(&quot;Rapunzel&quot;, &quot;Peter Pan&quot;, maerchen_df$text[2]) grepl(&quot;Rapunzel&quot;, peterpan_2) ## [1] TRUE # Zeichenkette löschen mit gsub() - geht auch mit sub() rapunzel_cleaned &lt;- gsub(&quot;Rapunzel&quot;, &quot;&quot;, maerchen_df$text[2]) grepl(&quot;Rapunzel&quot;, rapunzel_cleaned) ## [1] FALSE Verständnisfragen: Überprüfen wir die Ergebnisse, so fällt auf, dass bei Anwendung der Funktion sub() nicht alle Instanzen der Zeichenkette “Rapunzel” ersetzt wurden. Woran liegt das? Wie unterscheidet sich folglich das Verhalten der Funktionen gsub() und sub()? Im Beispiel oben haben wir die Funktionen auf das readtext-Objekt angewandt. Es kann aber auch ein Quanteda corpus-Objekt mithilfe von regulären Ausdrücken durchsucht werden: maerchen_korpus &lt;- corpus(maerchen_df) grepl(&quot;Rapunzel&quot;, maerchen_korpus[1]) ## [1] FALSE grepl(&quot;Rapunzel&quot;, maerchen_korpus[2]) ## [1] TRUE grepl(&quot;Rapunzel&quot;, maerchen_korpus) ## [1] FALSE TRUE 6.2.2 Spezielle Pakete: stringr Die Suche mithilfe von R-base-Funktionen kann etwas kompliziert werden, insbesondere, wenn die gefundenen Zeichenketten mithilfe von regmatches() und gregexpr() ausgegeben werden sollen. Außerdem ist es nicht immer möglich, die R-base-Funktionen mithilfe des Pipe-Operators zu verketten. Deswegen gibt es stringr, ein Paket aus dem Tidyverse (s. Kapitel R Basics IV), welches spezialisierte Funktionen zur Arbeit mit regulären Ausdrücken bietet. Die unübersichtliche Kombination von regmatches() und gregexpr() kann beispielsweise durch die stringr-Funktion str_extract_all() ersetzt werden: str_extract_all(maerchen_df$text[2], &quot;Rapunzel&quot;) ## [[1]] ## [1] &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; ## [7] &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; ## [13] &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; ## [19] &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; ## [25] &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; ## [31] &quot;Rapunzel&quot; Für eine Übersicht über stringr-Funktionen und einen Vergleich mit den R-base-Funktionen siehe: https://stringr.tidyverse.org/articles/from-base.html Verständnisfragen: Welche stringr Funktionen können anstelle der bereits kennengelernten R base Funktionen verwendet werden? Googelt das Paket stringi. Was ist der Unterschied zu stringr? 6.3 Regex Syntax 6.3.1 Basics Syntax Bisher haben wir nur nach einzelnen Worten gesucht. Oft interessieren wir uns aber für komplexere Ausdrücke, Zeichen, oder verschiedene Varianten desselben Worts. Um solche syntaktischen Strukturen zu beschreiben, gibt es verschiedene Regex-Symbole, die im Folgenden vorgestellt werden. Zeichen Bedeutung Beispiel \\ Escaped character: s.o. ⎮ Veroderung (ohne Leerzeichen!) Achtung: Auf Eindeutigkeit achten! Klammern nutzen! () Gruppen: Einheiten können mit runden Baum(krone⎮stamm) Klammern begrenzt werden 199(4⎮5) [] Zeichenklasse [a-zA-ZäöüÄÖÜß] - Bindestrich für Zahlen- oder [0-9] Buchstabenreihen - Reihenfolge innerhalb von Klassen nicht festgelegt - Sucht nach allen Kombinationen der Zeichen, wenn kein “oder” spezifiz. [^] Verneinung [^aeo] {} Quantifizierer - zwischen 1 und 4 [a-z]{1,4} - mindestens 1 [a-z]{1,} - genau 4 [a-z]{4} + “mindestens einmal”, bis unendlich [1986]+ (Frage: Was ist der Unterschied?) (1986)+ * “beliebig oft”, 0 bis unendlich [1986]* (1986)* .* Wildcard: matcht Zeichen beliebig oft (Aber: außer new line characters) ? Mögliches, aber optionales Match ^ Positionsmarker: ^ außerhalb einer Zeichenklasse markiert Zeilenanfang $ Positionsmarker: Markiert Zeilenende Merkt euch: Reguläre Ausdrücke stehen immer in doppelten Anführungszeichen! Soll innerhalb des Ausdrucks nach Anführungszeichen gesucht werden, müssen diese “escaped” werden. Dazu nutzt man den Backslash \\. Das gilt auch für alle anderen Zeichen, die eine “Regex-interne” Bedeutung haben, wie Punkte, Bindestriche, Klammern, u.ä. Verständnisfragen: Wie hätte sich die Ausgabe der “Rapunzel”-Beispiele oben verändert, wenn wir statt nach “Rapunzel” nach “Rapunzeln?” gesucht hätten? Wie hätten wir nach allen Varianten des Namens “Rapunzel” suchen können? 6.3.2 Zeichenklassen Nach manchen Zeichen wird so oft gesucht, dass sich bereits nützliche Abkürzungen dafür entwickelt haben. Sowohl die R-base-Funktionen als auch die stringr-Funktionen unterstützen per Default die Suche nach den gängigsten Regex-Zeichenklassen. Klasse Bedeutung \\w Wortzeichen = [a-zA-Z] \\W kein Wortzeichen \\d Zahlzeichen = [0-9] \\D kein Zahlzeichen \\s Leerzeichen \\S kein Leerzeichen \\r carriage return (andere Art von Leerzeichen) \\n new line character (neue Zeile) \\t Tabulatorzeichen # Mit R-Basisfunktionen regmatches(maerchen_df$text[2], gregexpr(&quot;\\\\s\\\\w{8}\\\\s&quot;, maerchen_df$text[2])) ## [[1]] ## [1] &quot; Hoffnung &quot; &quot; Zauberin &quot; &quot; bekommen &quot; &quot; erschrak &quot; &quot; sogleich &quot; ## [6] &quot; Begierde &quot; &quot; erschrak &quot; &quot; Zauberin &quot; &quot; zornigem &quot; &quot; schlecht &quot; ## [11] &quot; Zauberin &quot; &quot; erschien &quot; &quot; Rapunzel &quot; &quot;\\nRapunzel &quot; &quot; schönste &quot; ## [16] &quot; Zauberin &quot; &quot; Zauberin &quot; &quot;\\nRapunzel &quot; &quot; Zauberin &quot; &quot; wickelte &quot; ## [21] &quot; Zauberin &quot; &quot; Zauberin &quot; &quot; Rapunzel &quot; &quot; Zauberin &quot; &quot; erschrak &quot; ## [26] &quot; gewaltig &quot; &quot; erblickt &quot; &quot; erzählte &quot; &quot; Rapunzel &quot; &quot; jedesmal &quot; ## [31] &quot; flechten &quot; &quot; herunter &quot; &quot; Zauberin &quot; &quot; Rapunzel &quot; &quot; schwerer &quot; ## [36] &quot; Flechten &quot; &quot; Rapunzel &quot; &quot; Wüstenei &quot; &quot; Rapunzel &quot; &quot; Zauberin &quot; ## [41] &quot; Flechten &quot; &quot; giftigen &quot; &quot; Rapunzel &quot; &quot; liebsten &quot; &quot; wanderte &quot; ## [46] &quot; Rapunzel &quot; &quot; erkannte &quot; &quot; Rapunzel &quot; # Mit stringr-Funktion str_extract_all(maerchen_df$text[2], &quot;\\\\s\\\\w{8}\\\\s&quot;) ## [[1]] ## [1] &quot; Hoffnung &quot; &quot; Zauberin &quot; &quot; bekommen &quot; &quot; erschrak &quot; &quot; sogleich &quot; ## [6] &quot; Begierde &quot; &quot; erschrak &quot; &quot; Zauberin &quot; &quot; zornigem &quot; &quot; schlecht &quot; ## [11] &quot; Zauberin &quot; &quot; erschien &quot; &quot; Rapunzel &quot; &quot;\\nRapunzel &quot; &quot; schönste &quot; ## [16] &quot; Zauberin &quot; &quot; Zauberin &quot; &quot;\\nRapunzel &quot; &quot; Zauberin &quot; &quot; wickelte &quot; ## [21] &quot; Zauberin &quot; &quot; Zauberin &quot; &quot; Rapunzel &quot; &quot; Zauberin &quot; &quot; erschrak &quot; ## [26] &quot; gewaltig &quot; &quot; erblickt &quot; &quot; erzählte &quot; &quot; Rapunzel &quot; &quot; jedesmal &quot; ## [31] &quot; flechten &quot; &quot; herunter &quot; &quot; Zauberin &quot; &quot; Rapunzel &quot; &quot; schwerer &quot; ## [36] &quot; Flechten &quot; &quot; Rapunzel &quot; &quot; Wüstenei &quot; &quot; Rapunzel &quot; &quot; Zauberin &quot; ## [41] &quot; Flechten &quot; &quot; giftigen &quot; &quot; Rapunzel &quot; &quot; liebsten &quot; &quot; wanderte &quot; ## [46] &quot; Rapunzel &quot; &quot; erkannte &quot; &quot; Rapunzel &quot; Verständnisfrage: Was bedeutet das Muster \\\\s\\\\w{8}\\\\s? Wonach wird gesucht? 6.3.3 Lookarounds Sogenannte Lookarounds kommen zur Anwendung, wenn nach einem Muster gesucht wird, das den Anfang oder das Ende von einem gesuchten String markiert, aber selbst nicht gematcht werden soll. Sequenz Bedeutung (?=foo) Lookahead Asserts that what immediately follows the current position in the string is foo (?&lt;=foo) Lookbehind Asserts that what immediately precedes the current position in the string is foo (?!foo) Negative Lookahead Asserts that what immediately follows the current position in the string is not foo (?&lt;!foo) Negative Lookbehind Asserts that what immediately precedes the current position in the string is not foo Quelle: https://www.rexegg.com/regex-lookarounds.html Die stringr-Funktionen unterstützen per Default die Suche mithilfe von Lookarounds. Um Lookarounds im Zusammenhang mit R-base-Funktionen zu verwenden, muss beim Funktionsaufruf das zusätzliche Argument perl = TRUE übergeben werden. # Mit R-Basisfunktionen regmatches(maerchen_df$text[2], gregexpr(&quot;(?&lt;=\\\\s)\\\\w{8}(?=\\\\s)&quot;, maerchen_df$text[2], perl = TRUE)) ## [[1]] ## [1] &quot;Hoffnung&quot; &quot;Zauberin&quot; &quot;bekommen&quot; &quot;erschrak&quot; &quot;sogleich&quot; &quot;Begierde&quot; ## [7] &quot;erschrak&quot; &quot;Zauberin&quot; &quot;zornigem&quot; &quot;schlecht&quot; &quot;Zauberin&quot; &quot;erschien&quot; ## [13] &quot;sogleich&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Zauberin&quot; &quot;Zauberin&quot; &quot;Rapunzel&quot; ## [19] &quot;Zauberin&quot; &quot;wickelte&quot; &quot;Zauberin&quot; &quot;Zauberin&quot; &quot;Rapunzel&quot; &quot;Zauberin&quot; ## [25] &quot;erschrak&quot; &quot;Rapunzel&quot; &quot;gewaltig&quot; &quot;erblickt&quot; &quot;Rapunzel&quot; &quot;jedesmal&quot; ## [31] &quot;flechten&quot; &quot;herunter&quot; &quot;Zauberin&quot; &quot;Rapunzel&quot; &quot;schwerer&quot; &quot;Flechten&quot; ## [37] &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;Zauberin&quot; &quot;Flechten&quot; &quot;giftigen&quot; &quot;Rapunzel&quot; ## [43] &quot;liebsten&quot; &quot;wanderte&quot; &quot;Rapunzel&quot; &quot;erkannte&quot; &quot;Rapunzel&quot; # Mit stringr-Funktion str_extract_all(maerchen_df$text[2], &quot;(?&lt;=\\\\s)\\\\w{8}(?=\\\\s)&quot;) ## [[1]] ## [1] &quot;Hoffnung&quot; &quot;Zauberin&quot; &quot;bekommen&quot; &quot;erschrak&quot; &quot;sogleich&quot; &quot;Begierde&quot; ## [7] &quot;erschrak&quot; &quot;Zauberin&quot; &quot;zornigem&quot; &quot;schlecht&quot; &quot;Zauberin&quot; &quot;erschien&quot; ## [13] &quot;sogleich&quot; &quot;Rapunzel&quot; &quot;Rapunzel&quot; &quot;schönste&quot; &quot;Zauberin&quot; &quot;Zauberin&quot; ## [19] &quot;Rapunzel&quot; &quot;Zauberin&quot; &quot;wickelte&quot; &quot;Zauberin&quot; &quot;Zauberin&quot; &quot;Rapunzel&quot; ## [25] &quot;Zauberin&quot; &quot;erschrak&quot; &quot;Rapunzel&quot; &quot;gewaltig&quot; &quot;erblickt&quot; &quot;erzählte&quot; ## [31] &quot;Rapunzel&quot; &quot;jedesmal&quot; &quot;flechten&quot; &quot;herunter&quot; &quot;Zauberin&quot; &quot;Rapunzel&quot; ## [37] &quot;schwerer&quot; &quot;Flechten&quot; &quot;Rapunzel&quot; &quot;Wüstenei&quot; &quot;Rapunzel&quot; &quot;Zauberin&quot; ## [43] &quot;Flechten&quot; &quot;giftigen&quot; &quot;Rapunzel&quot; &quot;liebsten&quot; &quot;wanderte&quot; &quot;Rapunzel&quot; ## [49] &quot;erkannte&quot; &quot;Rapunzel&quot; Verständnisfrage: Wie unterscheiden sich die Ergebnisse der Suche mithilfe von Lookarounds von den Ergebnissen der Suche nach \\\\s\\\\w{8}\\\\s im vorigen Abschnitt? Warum ist das so? 6.4 Regex für nicht-lateinische Schriften Reguläre Ausdrücke können natürlich auch zur Suche in Texten mit nicht-lateinischen Schriften oder in multilingualen Texten verwendet werden: Entweder explizit, indem einfach das Muster in der entsprechenden Sprache formuliert wird, oder aber mithilfe der Unicode-Zeichenklasse \\p (s.u.). rapunzel_rus &lt;- readtext(&quot;data/Колокольчик_(Гримм;_Полевой).txt&quot;) regmatches(rapunzel_rus$text[1], gregexpr(&quot;Колокольчик&quot;, rapunzel_rus$text[1])) ## [[1]] ## [1] &quot;Колокольчик&quot; &quot;Колокольчик&quot; &quot;Колокольчик&quot; &quot;Колокольчик&quot; &quot;Колокольчик&quot; ## [6] &quot;Колокольчик&quot; &quot;Колокольчик&quot; Zur Suche nach Mustern in verschiedenen Schriften kann auch eine spezielle Zeichenklasse für Unicode-Zeichen verwendet werden, \\p. Diese Zeichenklasse erlaubt es, ein bestimmtes Alphabet zu spezifizieren, oder alphabetübergreifend nach einem Zeichen in allen in Unicode abgebildeten Schriften zu suchen. Die stringr-Funktionen unterstützen per Default die Suche mithilfe der Unicode-Zeichenklasse \\p. Um diese Zeichenklasse im Zusammenhang mit R-base-Funktionen zu verwenden, muss beim Funktionsaufruf das zusätzliche Argument perl = TRUE übergeben werden. # Suche nach drei beliebigen Buchstaben aus dem kyrillischen Alphabet, angeführt und gefolgt von einem Leerzeichen regmatches(rapunzel_rus$text[1], gregexpr(&quot;\\\\s\\\\p{Cyrillic}{3}\\\\s&quot;, rapunzel_rus$text[1], perl = TRUE)) ## [[1]] ## [1] &quot; муж &quot; &quot; уже &quot; &quot; лет &quot; &quot; что &quot; &quot; был &quot; &quot; был &quot; &quot; что &quot; &quot; все &quot; ## [9] &quot; что &quot; &quot; нее &quot; &quot; она &quot; &quot; так &quot; &quot; она &quot; &quot; что &quot; &quot; она &quot; &quot; муж &quot; ## [17] &quot; что &quot; &quot; мне &quot; &quot; что &quot; &quot; мне &quot; &quot; сад &quot; &quot; это &quot; &quot; так &quot; &quot; что &quot; ## [25] &quot; еще &quot; &quot; его &quot; &quot; как &quot; &quot; что &quot; &quot; мой &quot; &quot; Это &quot; &quot; это &quot; &quot; моя &quot; ## [33] &quot; тут &quot; &quot; это &quot; &quot; как &quot; &quot; мне &quot; &quot; нем &quot; &quot; как &quot; &quot; все &quot; &quot; его &quot; ## [41] &quot; Бог &quot; &quot; той &quot; &quot; ней &quot; &quot; как &quot; &quot; она &quot; &quot; ним &quot; &quot; два &quot; &quot; тем &quot; ## [49] &quot; ему &quot; &quot; той &quot; &quot; той &quot; &quot; так &quot; &quot; что &quot; &quot;\\nЭто &quot; &quot; она &quot; &quot; это &quot; ## [57] &quot; так &quot; &quot; его &quot; &quot; что &quot; &quot; лес &quot; &quot; все &quot; &quot; что &quot; &quot; ней &quot; &quot; как &quot; ## [65] &quot; ним &quot; &quot; так &quot; &quot; ним &quot; &quot; ней &quot; &quot; она &quot; &quot; нею &quot; &quot; как &quot; &quot; как &quot; ## [73] &quot; тех &quot; &quot; мог &quot; &quot; нее &quot; &quot; она &quot; &quot; его &quot; &quot; она &quot; &quot; что &quot; &quot; она &quot; ## [81] &quot; чем &quot; &quot; она &quot; &quot; ему &quot; &quot;\\nОна &quot; &quot; как &quot; &quot; мне &quot; &quot; мне &quot; &quot; раз &quot; ## [89] &quot; она &quot; &quot; ней &quot; &quot;\\nОни &quot; &quot; что &quot; &quot; нее &quot; &quot; что &quot; &quot; ней &quot; &quot; это &quot; ## [97] &quot; вас &quot; &quot; Тот &quot; &quot; миг &quot; &quot; Что &quot; &quot; что &quot; &quot; все &quot; &quot; она &quot; &quot; ими &quot; ## [105] &quot; два &quot; &quot; что &quot; &quot; где &quot; &quot; тот &quot; &quot; под &quot; &quot; она &quot; &quot; ним &quot; &quot; там &quot; ## [113] &quot; она &quot; &quot; эта &quot; &quot; уже &quot; &quot; еще &quot; &quot; что &quot; &quot; тот &quot; &quot; ему &quot; &quot; Так &quot; ## [121] &quot; лет &quot; &quot; где &quot; &quot; его &quot; &quot; нее &quot; &quot; ему &quot; &quot; его &quot; &quot; ему &quot; &quot; Две &quot; ## [129] &quot; ему &quot; &quot; мог &quot; &quot; все &quot; &quot; как &quot; &quot; где &quot; &quot; они &quot; # Suche nach drei beliebigen Buchstaben, egal aus welchem Alphabet, angeführt und gefolgt von einem Leerzeichen regmatches(rapunzel_rus$text[1], gregexpr(&quot;\\\\s\\\\p{L}{3}\\\\s&quot;, rapunzel_rus$text[1], perl = TRUE)) ## [[1]] ## [1] &quot; муж &quot; &quot; уже &quot; &quot; лет &quot; &quot; что &quot; &quot; был &quot; &quot; был &quot; &quot; что &quot; &quot; все &quot; ## [9] &quot; что &quot; &quot; нее &quot; &quot; она &quot; &quot; так &quot; &quot; она &quot; &quot; что &quot; &quot; она &quot; &quot; муж &quot; ## [17] &quot; что &quot; &quot; мне &quot; &quot; что &quot; &quot; мне &quot; &quot; сад &quot; &quot; это &quot; &quot; так &quot; &quot; что &quot; ## [25] &quot; еще &quot; &quot; его &quot; &quot; как &quot; &quot; что &quot; &quot; мой &quot; &quot; Это &quot; &quot; это &quot; &quot; моя &quot; ## [33] &quot; тут &quot; &quot; это &quot; &quot; как &quot; &quot; мне &quot; &quot; нем &quot; &quot; как &quot; &quot; все &quot; &quot; его &quot; ## [41] &quot; Бог &quot; &quot; той &quot; &quot; ней &quot; &quot; как &quot; &quot; она &quot; &quot; ним &quot; &quot; два &quot; &quot; тем &quot; ## [49] &quot; ему &quot; &quot; той &quot; &quot; той &quot; &quot; так &quot; &quot; что &quot; &quot;\\nЭто &quot; &quot; она &quot; &quot; это &quot; ## [57] &quot; так &quot; &quot; его &quot; &quot; что &quot; &quot; лес &quot; &quot; все &quot; &quot; что &quot; &quot; ней &quot; &quot; как &quot; ## [65] &quot; ним &quot; &quot; так &quot; &quot; ним &quot; &quot; ней &quot; &quot; она &quot; &quot; нею &quot; &quot; как &quot; &quot; как &quot; ## [73] &quot; тех &quot; &quot; мог &quot; &quot; нее &quot; &quot; она &quot; &quot; его &quot; &quot; она &quot; &quot; что &quot; &quot; она &quot; ## [81] &quot; чем &quot; &quot; она &quot; &quot; ему &quot; &quot;\\nОна &quot; &quot; как &quot; &quot; мне &quot; &quot; мне &quot; &quot; раз &quot; ## [89] &quot; она &quot; &quot; ней &quot; &quot;\\nОни &quot; &quot; что &quot; &quot; нее &quot; &quot; что &quot; &quot; ней &quot; &quot; это &quot; ## [97] &quot; вас &quot; &quot; Тот &quot; &quot; миг &quot; &quot; Что &quot; &quot; что &quot; &quot; все &quot; &quot; она &quot; &quot; ими &quot; ## [105] &quot; два &quot; &quot; что &quot; &quot; где &quot; &quot; тот &quot; &quot; под &quot; &quot; она &quot; &quot; ним &quot; &quot; там &quot; ## [113] &quot; она &quot; &quot; эта &quot; &quot; уже &quot; &quot; еще &quot; &quot; что &quot; &quot; тот &quot; &quot; ему &quot; &quot; Так &quot; ## [121] &quot; лет &quot; &quot; где &quot; &quot; его &quot; &quot; нее &quot; &quot; ему &quot; &quot; его &quot; &quot; ему &quot; &quot; Две &quot; ## [129] &quot; ему &quot; &quot; мог &quot; &quot; все &quot; &quot; как &quot; &quot; где &quot; &quot; они &quot; # Suche mit stringr-Funktion str_extract_all() str_extract_all(rapunzel_rus$text[1], &quot;\\\\s\\\\p{L}{3}\\\\s&quot;) ## [[1]] ## [1] &quot; муж &quot; &quot; уже &quot; &quot; лет &quot; &quot; что &quot; &quot; был &quot; &quot; был &quot; &quot; что &quot; &quot; все &quot; ## [9] &quot; что &quot; &quot; нее &quot; &quot; она &quot; &quot; так &quot; &quot; она &quot; &quot; что &quot; &quot; она &quot; &quot; муж &quot; ## [17] &quot; что &quot; &quot; мне &quot; &quot; что &quot; &quot; мне &quot; &quot; сад &quot; &quot; это &quot; &quot; так &quot; &quot; что &quot; ## [25] &quot; еще &quot; &quot; его &quot; &quot; как &quot; &quot; что &quot; &quot; мой &quot; &quot; Это &quot; &quot; это &quot; &quot; моя &quot; ## [33] &quot; тут &quot; &quot; это &quot; &quot; как &quot; &quot; мне &quot; &quot; нем &quot; &quot; как &quot; &quot; все &quot; &quot; его &quot; ## [41] &quot; Бог &quot; &quot; той &quot; &quot; ней &quot; &quot; как &quot; &quot; она &quot; &quot; ним &quot; &quot; два &quot; &quot; тем &quot; ## [49] &quot; ему &quot; &quot; той &quot; &quot; той &quot; &quot; так &quot; &quot; что &quot; &quot;\\nЭто &quot; &quot; она &quot; &quot; это &quot; ## [57] &quot; так &quot; &quot; его &quot; &quot; что &quot; &quot; лес &quot; &quot; все &quot; &quot; что &quot; &quot; ней &quot; &quot; как &quot; ## [65] &quot; ним &quot; &quot; так &quot; &quot; ним &quot; &quot; ней &quot; &quot; она &quot; &quot; нею &quot; &quot; как &quot; &quot; как &quot; ## [73] &quot; тех &quot; &quot; мог &quot; &quot; нее &quot; &quot; она &quot; &quot; его &quot; &quot; она &quot; &quot; что &quot; &quot; она &quot; ## [81] &quot; чем &quot; &quot; она &quot; &quot; ему &quot; &quot;\\nОна &quot; &quot; как &quot; &quot; мне &quot; &quot; мне &quot; &quot; раз &quot; ## [89] &quot; она &quot; &quot; ней &quot; &quot;\\nОни &quot; &quot; что &quot; &quot; нее &quot; &quot; что &quot; &quot; ней &quot; &quot; это &quot; ## [97] &quot; вас &quot; &quot; Тот &quot; &quot; миг &quot; &quot; Что &quot; &quot; что &quot; &quot; все &quot; &quot; она &quot; &quot; ими &quot; ## [105] &quot; два &quot; &quot; что &quot; &quot; где &quot; &quot; тот &quot; &quot; под &quot; &quot; она &quot; &quot; ним &quot; &quot; там &quot; ## [113] &quot; она &quot; &quot; эта &quot; &quot; уже &quot; &quot; еще &quot; &quot; что &quot; &quot; тот &quot; &quot; ему &quot; &quot; Так &quot; ## [121] &quot; лет &quot; &quot; где &quot; &quot; его &quot; &quot; нее &quot; &quot; ему &quot; &quot; его &quot; &quot; ему &quot; &quot; Две &quot; ## [129] &quot; ему &quot; &quot; мог &quot; &quot; все &quot; &quot; как &quot; &quot; где &quot; &quot; они &quot; Weiterführende Links Wickham, Hadley, Çetinkaya-Rundel, Mine und Grolemund, Garrett (2023), R for Data Science. Chapter 15: Regular Expressions, https://r4ds.hadley.nz/regexps. Hase, Valerie (2021), Text as Data Methods in R - Applications for Automated Analyses of News Content. Tutorial 9: Searching &amp; Manipulating String Patterns, https://bookdown.org/valerie_hase/TextasData_HS2021/tutorial-9-searching-manipulating-string-patterns.html. Regex Debugging: https://regex101.com/ Erläuterungen zum Regex-Syntax: https://danielfett.de/2006/03/20/regulaere-ausdruecke-tutorial/ Interaktives Tutorial zum Regex-Syntax: https://regexone.com/ Video zu den R Base-Funktionen: https://www.youtube.com/watch?v=q8SzNKib5-4 Lookarounds erläutert: https://www.regular-expressions.info/lookaround.html PCRE Cheatsheet: https://www.debuggex.com/cheatsheet/regex/pcre "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
