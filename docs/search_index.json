[["index.html", "Textanalyse mit R für die Geisteswissenschaften Über diesen Kurs", " Textanalyse mit R für die Geisteswissenschaften Lisa Poggel SoSe 2025 Freie Universität Berlin Über diesen Kurs Willkommen in meinem Seminar “Textanalyse mit R für die Geisteswissenschaften”! Hier findet ihr die Inhalte zu allen Sitzungen. Dieses Seminar vermittelt grundlegende praktische Kenntnisse der Textanalyse mit der Programmiersprache R. Der Fokus liegt auf der Verarbeitung und Analyse geisteswissenschaftlicher Daten. Das Seminar richtet sich insbesondere an Studierende ohne Programmiererfahrung und vermittelt neben Verfahren der Textanalyse und des Text Mining auch Grundlagen der Programmierung mit R. R kommt als besonders einstiegsfreundliche Programmiersprache vermehrt auch in geisteswissenschaftlichen Forschungsprojekten zur Anwendung, beispielsweise bei der quantitativen Textanalyse, in der digitalen Stilometrie, bei der Autorschaftserkennung oder zur Analyse und Visualisierung historischer Korrespondenznetzwerke. Das Seminar setzt keine Programmiererfahrung voraus. "],["warum-r.html", "Warum R? Was ist R überhaupt? R Thirst Traps", " Warum R? Was ist R überhaupt? R is a language and environment for statistical computing and graphics. Quelle: https://www.r-project.org/about.html Warum sollten Geisteswissenschaftler:innen eine Programmiersprache für “statistical computing” lernen? Kann man damit nicht nur Worthäufigkeiten zählen und Wortwolken erstellen? Und sind Wortwolken nicht irgendwie etwas “underwhelming”? In den letzten Jahren ist R neben Python zur meistgenutzten Programmiersprache im Bereich Data Science geworden. Data Scientists beschäftigen sich natürlich tatsächlich viel mit Statistik. Aber R ist viel mehr als “nur” Statistik. Die Anwendungsmöglichkeiten von R sind genauso vielfältig wie die Digital Humanities selbst. Und das nicht nur, weil die Digital Humanities selbst ein sehr vielseitiges Fach sind, über deren Definition immer noch kontrovers diskutiert wird (siehe zum Beispiel whatisdigitalhumanities.com). R hat eine aktive und riesige Community von Nutzer:innen, die immer neue sogenannte “Pakete” erstellen, die für bestimmte Anwendungen gemacht sind, wie zum Beispiel für die Analyse dramatischer Texte, die Stilometrie oder auch die Textanalyse ganz allgemein. Was man alles so mit R in den Digital Humanities anstellen kann, illustrieren die Beispiele im nächsten Abschnitt. R Thirst Traps Das klingt alles bisher noch sehr abstrakt. Deswegen hier ein paar ganz konkrete Anwendungsbeispiele von R im Bereich der Digital Humanities, die hoffentlich etwas Lust auf R machen: Web App, Geocoding, GIS, Queere Geschichte: https://www.mappingthegayguides.org/map/ Code zum Projekt: https://github.com/MappingtheGayGuides/MGG-App Rezeptionsforschung zu James Baldwin, Literaturgeschichte, Datenvisualisierung: https://tweetsofanativeson.com/Seattle-Public-Library-2023/ Code: https://github.com/JoeLollo21/Viral-Lit-Project Text Reuse und Intertextualität: https://americaspublicbible.org/ , https://americaspublicbible.supdigital.org/verse-viewer/?ref=Proverbs%2022%3A6 Code: https://github.com/lmullen/americas-public-bible Text Reuse in historischen Zeitschriften, Topic Modeling, Text Feature Extraction: https://viraltexts.org/ Code: https://github.com/rccordell/us-newspapers-1689-2009 ; https://github.com/ViralTexts/viral-texts-networks ; https://github.com/jonathandfitzgerald/Viral-Texts-R Topic Modeling: https://layeredlives.org/ Publikation zum Projekt: https://statsmaths.github.io/pdf/2022-layered-lives.pdf Named Entity Recognition und Textannotation: https://photogrammar.org Code: https://github.com/americanpanorama/photogrammar Korrespondenznetzwerk analysieren und visualisieren: https://www.jessesadler.com/project/dvdm-correspondence Code: https://github.com/jessesadler/dvdm-correspondence Quantitative Textanalyse von Shakespeare-Dramen, Datenbeschaffung: https://m-clark.github.io/text-analysis-with-R/shakespeare.html Dramenanalyse, Arbeit mit XML-TEI Dateien: https://quadrama.github.io/DramaAnalysis/tutorial/3/introduction.html Code: https://github.com/quadrama/DramaAnalysis Datenbeschaffung mithilfe von APIs (Codebeispiel): https://github.com/ThomasK81/ExploringDigitalHumanities/blob/master/RScripts/shortstories.R Textklassifikation (Codesammlung): https://github.com/kbenoit/newsmap Quantitative Inhaltsanalyse mit R, Kookkurrenzen von Charakteren in “Sherlock Holmes”: http://inhaltsanalyse-mit-r.de/netzwerke.html Lexikalische Vielfalt und Sentimentanalyse (Codesammlung): https://github.com/louismagowan/lyrics_analysis Lexikalische Ähnlichkeit von Romanen, Computational Linguistics, Stemming Publikation zum Projekt: https://piperlab.mcgill.ca/pdfs/Piper_NovelConversions.pdf Code: https://github.com/nan-da/Novel-Devotions Genreklassifikation, Topic Modeling, soziale Netzwerkanalyse, Part of Speech Tagging, uvm. Publikation: https://press.uchicago.edu/ucp/books/book/chicago/E/bo28465405.html Code: https://github.com/piperandrew/enumerations Computational Linguistics, Named Entity Recognition, Part of Speech Tagging: Publikation: https://amst.winter-verlag.de/article/AMST/2018/2/8 Code: https://github.com/nilsreiter/rereading-the-american-short-story Quantitative Linguistik, Korpuslinguistik: https://jupyter.korpus.cz/shiny/lukes/mda/ Code: https://github.com/dlukes/shiny-mda Digital Humanities Masterarbeit, in der R verwendet wird (Codesammlung): https://github.com/mikkosk/spectator_masters_thesis Noch eine Digital Humanities Masterarbeit (von mir): https://lipogg.shinyapps.io/soviet-ethnography/ Code: https://github.com/lipogg/soviet-ethnography Im Laufe des Semesters werden wir also nicht (nur) Wordclouds erstellen, sondern genuin geistes- bzw. literaturwissenschaftlichen Fragestellungen und Technologien behandeln, die für die geisteswissenschaftliche Arbeit relevant sind. Dabei sollen programmatische Zugriffe auf diese Fragestellungen natürlich traditionelle Analysemethoden nicht ersetzen, sondern diese produktiv ergänzen. "],["seminarplan.html", "Seminarplan", " Seminarplan Sitzung Nr. Datum Thema 1 15.04. Einstieg 2 22.04. R Basics I: Datentypen, Variablen und Operatoren 3 29.04. R Basics II: Datenstrukturen 4 06.05. R Basics III: Kontrollstrukturen 5 13.05. R Basics IV: Funktionen und Pakete 6 20.05. R Basics Wiederholung 7 27.05. Textanalyse mit Quanteda I: Korpus, Tokens, Daten und Dateien 8 03.06. Textanalyse mit Quanteda II: Preprocessing und Reguläre Ausdrücke 9, 10 10. und 17.06. Textanalyse mit Quanteda III: Wortfrequenzanalysen 11 24.06. Part of Speech Tagging und Dependency Parsing mit UDPipe 12 01.07. Textanalyse Wiederholung 13 08.07. Named Entity Recognition 14 15.07. Arbeit mit XML-TEI Dateien: XML, TEI und XPath Die Sitzung am 1.7. wird voraussichtlich REMOTE via Webex stattfinden. Der Seminarplan ist erst einmal vorläufig. Je nach Lerntempo und Interessen werden wir das ein oder andere Thema mehr oder weniger vertiefen. Die Inhalte bauen grundsätzlich aufeinander auf: Zunächst beschäftigen wir uns mit sogenannten “unstrukturierten” Daten und später mit “(semi-)strukturierten” Daten. Nach einem Einstieg in R steigen wir in die Arbeit mit “rohem Text”, also Plaintext-Dateien, als Beispiel für unstrukturierte Daten ein und erarbeiten Grundkonzepte der quantitativen Textanalyse. Dabei werden wir auch diskutieren, was “geisteswissenschaftliche Daten” eigentlich sind. Danach behandeln wir zwei verschiedene Verfahren, wie Texte in R im Hinblick auf bestimmte Textinformationen strukturiert (man sagt auch “annotiert”) werden können: das automatisierte Erkennen von Wortarten (Part of Speech Tagging) und von “Entitäten” wie Personennamen und Ortsnamen (Named Entity Recognition). Zuletzt widmen wir uns XML-TEI-Dateien als Beispiel für die Analyse (semi-)strukturierter Textdaten. XML-TEI ist ein in den Digital Humanities weit verbreiteter Standard zur digitalen Darstellung von Texten, beispielsweise literarsichen Werken, archivalischen Quellen oder wissenschaftlichen Arbeiten. Mithilfe von XML-TEI können Textinformationen, zum Beispiel Metadaten und bestimmte Bestandteile des Textes, strukturiert dargestellt werden. Die vorgestellten Verfahren können wir natürlich in der kurzen Zeit nur sehr, sehr oberflächlich behandeln. Das Ziel ist es, dass ihr am Ende des Semesters Grundkonzepte des Programmierens in R und grundlegende Anwendungen der Programmiersprache im Bereich der Textanalyse kennt und euch die Fertigkeiten erarbeitet habt, fortgeschrittenere Themen eigenständig weiter zu vertiefen. Da wir viele Themen besprechen werden, erfordert dieses Seminar ein hohes Maß an Motivation und Durchhaltevermögen. Jede Woche wird es Übungsaufgaben geben. Die Bearbeitung der Übungsaufgaben ist verpflichtend und insbesondere zur Vor- und Nachbereitung der Einstiegssitzungen essentiell, denn sonst wird es sehr schwierig sein, später mitzukommen. Die Lernkurve ist demenstprechend steil: "],["lernziele.html", "Lernziele", " Lernziele Das Seminar ist als Praxisseminar konzipiert. Das heißt, dass der Fokus darauf liegt, anhand praktischer Übungsaufgaben und Fragestellungen das Coden in R zu erlernen. Das heißt aber nicht, dass wir nur Sachen auswendig lernen und Inhalte von einem Zusammenhang auf den anderen übertragen. Die kritische Analyse und Evaluation nicht nur von Code sondern auch von konkreten Verfahren ist essentiell für die Arbeit mit geisteswissenschaftlichen Daten. Nach diesem Seminar kennt ihr… Grundbegriffe und Konzepte der Programmierung mit R: Die Studierenden kennen den Unterschied zwischen verschiedenen Datentypen und Datenstrukturen und kennen die wichtigsten Operationen darauf. Sie haben ein Grundverständnis von der sinnvollen Strukturierung von R-Code und kennen wichtige Konventionen. Grundbegriffe und Verfahren der Textanalyse und -aufbereitung mit R: Die Studierenden kennen geeignete Verfahren zur Aufbereitung und Analyse von Plaintext-Dateien und XML-TEI-Dateien. Sie können mögliche Probleme, Vor- und Nachteile der verschiedenen Verfahren sowie ausgewählte Anwendungsgebiete der Verfahren benennen. Sie kennen relevante Richtwerte und Metriken zur Bewertung der Analyseergebnisse und haben ein elementares Verständnis der statistischen Grundlagen der angewandten Verfahren. Datenformate: Die Studierenden sind mit dem Aufbau von XML-TEI Dokumenten vertraut. Sie können zwischen verschiedenen Datenformaten unterscheiden. Suchtechniken für verschiedene Datenformate: Die Studierenden kennen die grundlegende Syntax von Regulären Ausdrücken und XPath. Nach diesem Seminar könnt ihr … Verfahren des Preprocessing und der Textanalyse in R anwenden: Die Studierenden können R-Code lesen und (je nach Vorkenntnissen) einfache bis fortgeschrittene Skripte zum Preprocessing und Analyse von Textdaten in R selbst schreiben. Sie können Fehler mithilfe von Debugging-Strategien selbst identifizieren und können Online-Ressourcen nutzen, um sich selbst Hilfe zu beschaffen. Sie können komplexen Code auf dem eigenen Computer reproduzieren. Sie sind routiniert im Umgang mit RStudio. Sie können einfache Ausdrücke zur Suche in Plaintext- und XML-TEI-Dateien mithilfe von Regulären Ausdrücken und XPath schreiben und einsetzen. Auswirkungen der angewandten Verfahren evaluieren: Die Studierenden können evaluieren, wie sich verschiedene Entscheidungen und Verfahren des Preprocessing auf die Analyse eines Textkorpus’ auswirken. Sie können identifizieren, welche Preprocessing-Schritte die Analyseergebnisse verbessern können. Aussagekraft der Ergebnisse kritisch bewerten: Die Studierenden können die Ergebnisse der verschiedenen Analyse-, Such und Extraktionsverfahren im Hinblick auf die Preprocessingentscheidungen, die Qualität und Zusammensetzung des Korpus kritisch bewerten. "],["organisatorisches.html", "Organisatorisches", " Organisatorisches Hier findet ihr Informationen zu Teilnahmemodalitäten, Prüfungsleistungen und Kommunikation. Teilnahmeschein: Aktive Teilnahme: n-2 Sitzungen Wöchentliche Übungsaufgaben: Lösungen Montagabend vor jeder Stunde an mich schicken (l.poggel@fu-berlin.de). Übungen schicke ich euch per Mail jede Woche Mittwoch. Ein Kahoot-Quiz erstellen und moderieren. Login über https://kahoot.com/ Leistungsschein: Wie Teilnahmeschein Zusätzlich ein eigenständiges Projekt (ersetzt die Hausarbeit): Ihr plant und implementiert auf der Grundlage der Inhalte aus diesem Seminar ein kleines Digital Humanities Projekt. Im Laufe der Bearbeitung eurer Fragestellung erstellt ihr ein kleines Programmierportfolio mit allen Skripten, die ihr im Rahmen des Projekts erstellt habt. Das Portfolio sendet ihr als Zip-Ordner bis zum 30.09.2025 an l.poggel@fu-berlin.de. Die Anforderungen, Projektbeispiele und die Bewertungsgrundlage für das Portfolio besprechen wir rechtzeitig im Laufe des Semesters. Kommunikation: Bei Fragen, Kritik oder falls ihr mal eine Sitzung nicht kommen könnt, schreibt mir eine E-Mail an l.poggel@fu-berlin.de. Um eine Sprechstunde zu vereinbaren, könnt ihr mich gern vor oder nach den Sitzungen ansprechen oder mir eine E-Mail schreiben. Bewertungskriterien für das Abschlussprojekt: Umfang: Programmierportfolio, bestehend aus mindestens zwei verschiedenen R Skripten und einem Dokumentationstext, der die Fragestellung, das Korpus, den Forschungsstand und die gewählten Verfahren vorstellt und begründet, sowie die Ergebnisse in Bezug auf die Fragestellung auswertet und kritisch diskutiert. Der Umfang der Dokumentationstextes (exklusive Code) sollte 4-8 Seiten (ca. 1200-3000 Wörter) entsprechen. Abgabefrist: 30.09.2025 Abgabeformat: Programmierportfolio als Zip-Ordner Beispielportfolio: Skript 1: Preprocessing. Vorbereitetes Korpus wird in RDS-Datei gespeichert. Skript 2: Analyse mit quanteda, UDPipe (oder Named Entity Recognition). Das Korpus wird aus der RDS-Datei eingelesen. Dokumentation als RMarkdown-Dokument oder PDF Bewertungsskala: Note Erläuterung 1.0-1.3 Alle formalen Kriterien werden eingehalten. Die Forschungsfrage ist sinnvoll und mithilfe der gewählten Preprocessing- und Analyseverfahren sehr gut beantwortbar. Es gibt dabei unter den im Kurs kennengelernten Verfahren keine besser geeigneten Verfahren zur Beantwortung der Fragestellung. Die Wahl der verwendeten Verfahren, Vor- und Nachteile, die Aussagekraft sowie mögliche Auswirkungen auf die Beantwortung der Fragestellung werden kritisch diskutiert. Die Aussagekraft des Analyseverfahrens wird kritisch diskutiert. Die Ergebnisse werden in Bezug zum aktuellen Forschungsstand gesetzt. Der Code ist ausführlich kommentiert. Fremder Code wird nur dann verwendet, wenn der Code für die Umsetzung von Aufgaben, die über die Inhalte im Seminar hinausgehen, gebraucht wird, oder, wenn der Code eine Verbesserung zu den im Seminar vorgestellten Vorgehen darstellt. Fremder Code wird immer zitiert. Der Code produziert keine Fehlermeldungen und folgt immer gängigen stilistischen Konventionen und Regeln. 1.3-2.3 Alle formalen Kriterien werden eingehalten. Die Fragestellung ist sinnvoll und mithilfe der gewählten Preprocessing- und Analyseverfahren beantwortbar, aber es gibt ein besser geeignetes Verfahren. Die Wahl des Verfahrens wird begründet, aber die Begründung ist nicht gänzlich überzeugend oder weniger wichtige Konsequenzen der Entscheidung werden nicht diskutiert. Die Aussagekraft des Analyseverfahrens wird kritisch diskutiert. Die Ergebnisse werden in Bezug zum aktuellen Forschungsstand gesetzt. Der Code ist ausführlich kommentiert. Fremder Code wird nur dann verwendet, wenn der Code für die Umsetzung von Aufgaben, die über die Inhalte im Seminar hinausgehen, gebraucht wird, oder, wenn der Code eine Verbesserung zu den im Seminar vorgestellten Vorgehen darstellt. Fremder Code wird immer zitiert. Der Code produziert keine Fehlermeldungen und folgt zumeist gängigen stilistischen Konventionen und Regeln. 2.3-3.3 Alle formalen Kriterien werden eingehalten. Die Fragestellung ist sinnvoll und mithilfe der gewählten Preprocessing- und Analyseverfahren beantwortbar, aber es gibt ein besser geeignetes Verfahren. Die Wahl des Verfahrens wird begründet, aber die Begründung ist nicht überzeugend. Der Code ist an den wichtigsten Stellen kommentiert. Fremder Code wird nur dann verwendet, wenn der Code für die Umsetzung von Aufgaben, die über die Inhalte im Seminar hinausgehen, gebraucht wird, oder, wenn der Code eine Verbesserung zu den im Seminar vorgestellten Vorgehen darstellt. Fremder Code wird immer zitiert. Der Code produziert keine Fehlermeldungen. 3.3-4.0 Formale Kriterien werden zumeist eingehalten. Die Fragestellung ist teilweise mithilfe der gewählten Preprocessing- und Analyseverfahren beantwortbar. Die Wahl des Verfahrens wird begründet, aber die Begründung ist nicht überzeugend. Fremder Code wird immer zitiert. Der Code produziert keine Fehlermeldungen. ab 4.0 Formale Kriterien werden zumeist eingehalten. Die Fragestellung ist teilweise mithilfe der gewählten Preprocessing- und Analyseverfahren beantwortbar. Die Wahl des Verfahrens wird nicht begründet. Fremder Code wird immer zitiert. Der Code produziert keine Fehlermeldungen. 5.0 Formale Kriterien werden nicht eingehalten. Der Code ist nicht ausführbar und enthält schwerwiegende Fehler. Die Fragestellung ist nicht sinnvoll gewählt und die gewählten Preprocessing- und Analyseverfahren sind nicht geeignet, um die Fragestellung zu bearbeiten. "],["hilfe.html", "Hilfe!!", " Hilfe!! Oft kommt es beim Coden zu komischen Fehlermeldungen, die mehr verwirren als helfen. Häufig steckt aber ein ganz simpler Flüchtigkeitsfehler dahinter. In diesem Fall gilt: 1. Syntax und Rechtschreibung überprüfen. Fehlt vielleicht nur eine Klammer? Ist die Variable wirklich richtig geschrieben? Sind wirklich alle notwendigen Pakete installiert und geladen? 2. Fehlermeldung kopieren und googeln. Bestimmt hatte schonmal jemand anderes dasselbe Problem und bestenfalls findet sich eine Lösung auf https://stackoverflow.com/ oder in einem anderen Forum. 3. ChatGPT fragen. Das Codesnippet an ChatGPT senden und nach möglichen Fehlern fragen. 4. R Hilfeseiten aufrufen. Mit dem ? und dem ?? Operator können über die Konsole die Dokumentation zu konkreten Funktionen aufgerufen werden. Das kann nützlich sein, um beispielsweise zu überprüfen, welchen Datentyp die Funktion als Input nimmt. Wenn mit ?funktionsname keine oder nicht die richtige Dokumentationsseite gefunden wird, kann alternativ mit ?paketname::funktionsname nach einer Funktion aus einem konkreten Paket gesucht werden. Weitere Informationen zu den R Hilfeseiten: https://www.r-project.org/help.html Manchmal macht das Skript aber auch einfach nicht das, was es soll, ohne, dass eine Fehlermeldung entsteht. In diesem Fall liegt wahrscheinlich ein logischer Fehler im Programmablauf vor. Für diesen Fall gibt es eine Strategie, die Rubber Ducking oder Quietscheentchen-Debugging genannt wird. 5. Rubber Ducking oder Quietscheentschen-Debugging. Wenn nichts mehr hilft, hilft nur eins: Den Code einer Person, die nichts davon versteht - oder eben einem Quietscheentchen, Zeile für Zeile erklären. Dabei fallen oft logische Fehler auf, die das Problem verursachen. 6. Hilfe holen. Falls ihr im Laufe des Seminars ein Problem habt, das ihr selbst nicht lösen könnt, könnt ihr einen Screenshot für die nächste Sitzung mitbringen oder mir eine E-Mail an l.poggel@fu-berlin.de schreiben. Falls die Konsole (Fenster Console im RStudio) plötzlich + statt &gt; anzeigt oder sich ein Prozess durch Klick auf das rote “Stop”-Symbol nicht abbrechen lässt: Tastenkombination Ctrl (Control) + C (bzw. Strg + C). Zuletzt kann es natürlich auch vorkommen, dass euch ein Inhalt aus dem Seminar nicht ganz klar ist oder ihr ein weiterführendes Interesse an einem Thema habt. Zum Nachlesen empfehle ich die folgenden Lehrbücher und Ressourcen: Allgemein: Offizielle R Handbücher: https://cran.r-project.org/manuals.html Wickham, Hadley, Çetinkaya-Rundel, Mine und Grolemund, Garrett (2023). R for Data Science (=Official Tidyverse Book): https://r4ds.hadley.nz/ Schmidt, Ben (ongoing). Humanities Data Fundamentals: https://hdf.benschmidt.org/R/ Van Atteveldt, Wouter, Trilling, Damian und Arcila Calderón, Carlos (2022). Computational Analysis of Communication: https://cssbook.net/ Stoltz, Dustin S. und Taylor, Marshall A. (2024). Mapping Texts. Computational Text Analysis for the Social Sciences, https://global.oup.com/academic/product/mapping-texts-9780197756881 Sammlung von R “Cheatsheets”: https://github.com/rstudio/cheatsheets/tree/main Lehrbuch-Klassiker (für Grundlagen, bei speziellen Anwendungen zum Teil nicht mehr aktuell): Andresen, Melanie (2024). Computerlinguistische Methoden für die Digital Humanities, https://doi.org/10.24053/9783823395799 (hervorragendes Lehrbuch vor allem zum theoretischen und mathematischen Hintergrund der verschiedenen Methoden) Arnold, Taylor und Tilton, Lauren (2024). Humanities Data in R. Exploring Networks, Geospatial Data, Images, and Text: https://doi.org/10.1007/978-3-031-62566-4 Jockers, Matthew und Thalken, Rosamond (2020). Text Analysis with R for Students of Literature: https://doi.org/10.1007/978-3-030-39643-5 Desagulier, Guillaume (2017). Corpus Linguistics and Statistics with R: https://doi.org/10.1007/978-3-319-64572-8 Levshina, Natalia (2015). How to Do Linguistics with R: https://doi.org/10.1075/z.195 Textanalyse mit Quanteda: Offizielle Quanteda-Dokumentationsseiten: https://quanteda.io/ Offizielles Quanteda-Tutorial: https://tutorials.quanteda.io/ Replikation des Codes aus Levshinas “Text Analysis with R for Students of Literature” mithilfe von Quanteda: https://quanteda.io/articles/pkgdown/replication/digital-humanities.html Video-Tutorial zu Preprocessing und Textanalyse mit R von Kasper Welbers: https://www.youtube.com/playlist?list=PL-i7GM-A1wBZYRYTpem7hNVHK3hSV_1It Kapitel 10: “Text as Data” aus “Computational Analysis of Communication”: https://cssbook.net/content/chapter10.html Kapitel 6: “From Text to Numbers” aus “Mapping Texts”: https://global.oup.com/academic/product/mapping-texts-9780197756881 Datenvisualisierung mit ggplot2: Healy, Kieran (2019). Data Visualization. A Practical Introduction, https://socviz.co/ Wickham, Hadley (2016). ggplot2. Elegant Graphics for Data Analysis, https://ggplot2-book.org/ ggplot2-Dokumentationsseiten: https://ggplot2.tidyverse.org/; https://ggplot2.tidyverse.org/articles/ggplot2.html Online-Tool das dabei hilft, eine passende Visualisierung zu finden, mit Links zu den Dokumentationsseiten geeigneter R Funktionen: https://www.data-to-viz.com/ Statistik: (grundlegend) Handl, Andreas und Kuhlenkasper, Torben (2018). Einführung in die Statistik. Theorie und Praxis mit R: https://doi.org/10.1007/978-3-662-56440-0 (grundlegend) Gries, Stefan (2021). Statistics for Linguistics with R: https://doi.org/10.1515/9783110718256 (grundlegend) Blitzstein, Joe. Vorlesungsvideos, interaktiver Kurs und Buch Statistics 110: Probability, https://projects.iq.harvard.edu/stat110/home (fortgeschritten) Kroonenberg, Pieter (2021). Multivariate Humanities: https://doi.org/10.1007/978-3-030-69150-9 (fortgeschritten) Handl, Andreas und Kuhlenkasper, Torben (2017). Multivariate Analysemethoden. Theorie und Praxis mit R: https://doi.org/10.1007/978-3-662-54754-0 Hintergrund Preprocessing und Natural Language Processing (POS Tagging, Dependency Parsing, NER,…): Jurafsky, Daniel und Martin, James H. (2025). Speech and Language Processing, https://web.stanford.edu/~jurafsky/slp3/ (insbesondere Kapitel 2, 8, 17, 18). Andresen, Melanie (2024). Computerlinguistische Methoden für die Digital Humanities, https://doi.org/10.24053/9783823395799 Grimmer, Justin, Roberts, Margaret E. und Stewart, Brandon M. (2022), Text as Data. A New Framework for Machine Learning and the Social Sciences, https://fu-berlin.primo.exlibrisgroup.com/permalink/49KOBV_FUB/1v1tp5h/alma9960725495502883 Biemann, Chris, Heyer, Gerhard und Quasthoff, Uwe (2013). Wissensrohstoff Text. Eine Einführung in das Text Mining, https://doi.org/10.1007/978-3-658-35969-0 (insbesondere Kapitel 1, 2). Theorie (wird fortlaufend ergänzt): Gius, Evelyn und Jacke, Janina (2022). Are Computational Literary Studies Structuralist?, in: Journal of Cultural Analytics 7, no. 4, https://doi.org/10.22148/001c.46662. (Woche 1) Pichler, Axel und Reiter, Nils (2021), Zur Operationalisierung literaturwissenschaftlicher Begriffe in der algorithmischen Textanalyse, in: Journal of Literary Theory 15, no. 1-2, https://doi.org/10.1515/jlt-2021-2008. (W1) Bhattacharyya, Sayan (2021). Text Analysis for Thought in the Black Atlantic, in: Kelly Baker Josephs und Roopika Risam, The Digital Black Atlantic, pp. 77-83, https://muse.jhu.edu/book/84470. (W1) Stoltz, Dustin und Taylor, Marshall (2024). Mapping Texts. S. XIII und Ch. 1: Text in Context, https://doi.org/10.1093/oso/9780197756874.001.0001. (W1) Pichler, Axel und Reiter, Nils (2022). From Concepts to Texts and Back: Operationalization as a Core Activity of Digital Humanities, https://culturalanalytics.org/article/57195 Risam, Roopika (2019). New Digital Worlds. Postcolonial Digital Humanities in Theory, Praxis, and Pedagogy. Ch. 1: The Stakes of Postcolonial Digital Humanities (insb. Abschnitt World Making in Digital Humanities), https://fu-berlin.primo.exlibrisgroup.com/permalink/49KOBV_FUB/1v1tp5h/alma9961448530002883. Bubenhofer, Noah und Scharloth, Joachim (2013). Korpuslinguistische Diskursanalyse, in: Ulrike Hanna Meinhof, Martin Reisigl und Ingo Warnke (Hrsg.), Diskurslinguistik im Spannungsfeld von Deskription und Kritik, S. 147-167. https://doi.org/10.1524/9783050061047.147 Bode, Katherine (2017), The Equivalence of “Close” and “Distant” Reading; or, Toward a New Object for Data-Rich Literary History, https://doi.org/10.1215/00267929-3699787. Kleymann, Rabea (2022). Datendiffraktion: Von Mixed zu Entangled Methods in den Digital Humanities, https://doi.org/10.17175/sb005_008. Alessandro Lenci und Magnus Sahlgren (2023). Distributional Semantics, Ch. 1: From Usage to Meaning. The Foundations of Distributional Semantics, pp. 3-25, https://doi.org/10.1017/9780511783692.002 (Woche 9) Eve, Martin Paul (2022). The Digital Humanities and Literary Studies. Introduction, https://doi.org/10.1093/oso/9780198850489.003.0001 (für Skeptiker:innen) Bond, Sarah, Long, Hoyt und Underwood, Ted (2017). ‘Digital’ Is Not the Opposite of ‘Humanities’, https://www.chronicle.com/article/digital-is-not-the-opposite-of-humanities/. (für Skeptiker:innen) Glossar der Zeitschrift für digitale Geisteswissenschaften (mit Beiträgen zu Theorie, Operationalisierung, Daten, …): https://zfdg.de/wp_2023_001. Literaturhinweise zu den verschiedenen Analysemethoden findet ihr in den optionalen ausklappbaren Abschnitten im jeweiligen Kapitel. Einige Digital Humanities Zeitschriften (für die eigene Recherche): Zeitschrift für digitale Geisteswissenschaften, https://zfdg.de/ Digital Scholarship in the Humanities, https://academic.oup.com/dsh Digital Humanities Quarterly, https://www.digitalhumanities.org/dhq/ Journal of Cultural Analytics, https://culturalanalytics.org/ Journal of Computational Literary Studies, https://jcls.io/ Journal of Digital History, https://journalofdigitalhistory.org/ Volltextrepositorien mit Texten im Plaintext- oder XML-TEI-Format: https://wikisource.org/ (Plaintext, PDF, eBook-Formate) https://www.projekt-gutenberg.org/ (Volltexte nur online, zum Download ist Webscraping erforderlich) https://gutenberg.org (Plaintext, HTML, eBook-Formate) https://textgridrep.org/ (XML-TEI, Bildformate) https://archive.org/ (Volltexte im Plaintextformat aber häufig mittels OCR erstellt und in fragwürdiger Qualität) Datensätze und Korpora für die Textanalyse (wird fortlaufend ergänzt): Korpora, Editionen und Repositorien im Text+ Registry: https://registry.text-plus.org/ Datensätze im Social Sciences and Humanities Open Marketplace: https://marketplace.sshopencloud.eu/search?categories=dataset Datensätze im Hamburger Zentrum für Sprachkorpora: https://www.fdr.uni-hamburg.de/communities/hzsk/ Links zu historischen Textkorpora in der Perseus Digital Library: https://www.perseus.tufts.edu/hopper/collections Links zu verschiedenen Listen von DH Korpora und Datensätzen (unter “Resources for finding humanities data”): https://cdh.princeton.edu/programs/humanities-data-new/; https://guides.lib.ua.edu/datasources/humanities Journal of Open Humanities Data, https://openhumanitiesdata.metajnl.com/articles Deutsches Textarchiv: https://www.deutschestextarchiv.de/download European Literary Text Collection (ELTeC): https://github.com/COST-ELTeC/ELTeC Download über Github, z.B. für die deutschen Texte: https://github.com/COST-ELTeC/ELTeC-deu Assoziiertes Projekt: https://www.distant-reading.net/ DraCor (europäische Dramen in vielen verschiedenen Sprachen): https://dracor.org/ SlaveVoyages Datenbank: https://www.slavevoyages.org/american/downloads#intra-american-database-downloads/0/en/ Digitale Sammlung Deutscher Kolonialismus: https://www.deutschestextarchiv.de/dsdk/ HathiTrust derived datasets: https://analytics.hathitrust.org/deriveddatasets; https://htrc.atlassian.net/wiki/spaces/COM/pages/43287791/HTRC+Derived+Datasets Somar Social Media Archive: https://socialmediaarchive.org/ Digitale Sammlungen der Österreichischen Nationalbibliothek: https://labs.onb.ac.at/de/datasets/ Verzeichnis linguistischer Korpora (Daten zu den Korpora sind aber z.T. nicht mehr aktuell): https://www.lancaster.ac.uk/fass/projects/corpus/cbls/corpora.asp Datendienst des Deutschen Literaturarchivs Marbach: https://www.dla-marbach.de/katalog/dla-dataplus/ Verschiedene Universitäten weltweit sammeln außerdem Datensätze und Forschungsdaten in eigenen Forschungsdatenrepositorien, zum Beispiel: Harvard Dataverse (aktuell mit Stand Feb. 2025 37.000 Datensätze für das Thema “Arts and Humanities”), https://dataverse.harvard.edu/ Heidelberg Open Research Data (heiDATA; kleine Sammlung von Volltexten und XML-TEI-Editionen von Forschungsprojekten an der Uni Heidelberg, z.B. digitale Editionen der Kaiserchronik, des Maltechnik-Notizbuchs von Hans Emmenegger, der Korrespondenz von Nicodemus Frischlin, Index zu Artikeln der chinesischen Zeitschrift Shenbao, Metadaten zu allen Werken von Abou Naddara, uvm.), https://heidata.uni-heidelberg.de/dataverse/root Einen Überblick über weitere solche “Dataverses” findet ihr unter https://dataverse.org/ Zuletzt arbeiten auch außeruniversitäre Forschungsinstitute und die Akademien der Wissenschaften in den verschiedenen Bundesländern an digitalen Editionen und anderen Forschungsprojekten: Edition Humboldt Digital an der Berlin-Brandenburgischen Akademie der Wissenschaften: https://edition-humboldt.de/ Digitale Reiseberichte der Frühen Neuzeit in Sachsen an der Sächsischen Akademie der Wissenschaften : https://reise.isgv.de/ Forschungsprojekte an der Akademie der Wissenschaften und der Literatur Mainz: https://lod.academy/site/projects Digitale Ressourcen des Max Planck Instituts für Wissenschaftsgeschichte (darunter z.B. auch eine Sammlung frühneuzeitlicher Rezepte und eine Datenbank mit Metadaten zu Büchern in chinesischen öffentlichen Einrichtungen des 14. bis 21. Jahrhunderts): https://www.mpiwg-berlin.mpg.de/de/publikationen-ressourcen/digitale-ressourcen "],["installation-und-setup.html", "Installation und Setup", " Installation und Setup Egal, welches Betriebssystem: Erst R installieren, dann RStudio! R installieren (Mac: Intel oder Silicon!) https://cran.r-project.org/ Mac: Zusätzlich XQuartz installieren: https://www.xquartz.org/ RStudio installieren (RStudio ist jetzt Posit): https://posit.co/download/rstudio-desktop/ Wenn alles installiert ist, öffnet RStudio. "],["orientierung-im-rstudio.html", "Orientierung im RStudio", " Orientierung im RStudio "],["r-basics-i-datentypen-variablen-und-operatoren.html", "1 R Basics I: Datentypen, Variablen und Operatoren 1.1 Grundlegende Begriffe 1.2 Style Guide 1.3 Kommentare 1.4 Datentypen 1.5 Operatoren 1.6 Variablen 1.7 Operatorpräzedenz Quellen", " 1 R Basics I: Datentypen, Variablen und Operatoren 1.1 Grundlegende Begriffe Begriff Englische Entsprechung Definition (im R-Kontext) Objekt Object Alles: Funktionen, Variablen, Datenstrukturen,.. Anweisung Statement Syntaktische Einheit, die Aktionen beschreibt, die von einem Computer ausgeführt werden können. Wenn die Anweisung ausgeführt wird, wird die Aktion veranlasst und der Zustand des Speichers wird geändert. Zuweisung Assignment Besondere Art von Anweisung, bei der einer Variable ein bestimmter Wert zugeordnet wird. Dabei wird ein Name festgelegt, der fortan für diesen Wert und für den Speicherplatz, in dem der Wert gespeichert wird, steht. Ausdruck Expression Syntaktische Einheit, die zu einem Wert evaluiert (ausgewertet) werden kann. Ein Ausdruck ist immer Teil einer Anweisung. Ausdrücke stehen auf der rechten Seite von Zuweisungen: x &lt;- Ausdruck. Ausdrücke haben immer einen Typ, der dem Datentyp des Werts entspricht, zu dem sie evaluiert werden, z.B. 3 == 4 ist ein Ausdruck vom Typ boolean. Aussage Proposition In der Aussagenlogik ein sprachliches Gebilde, von dem es sinnvoll ist zu sagen, dass es entweder wahr oder falsch ist (Aristoteles). Im R-Kontext ein Ausdruck, der entweder zu TRUE oder zu FALSE evaluiert werden kann. Auswerten Evaluate Der Computer liest einen Ausdruck und wertet diesen aus: Er berechnet etwas und liefert einen Wert. Ausführen Execute Der Computer liest eine Anweisung und führt diese aus: Er macht etwas und ändert den Zustand des Speichers. Ausgeben Output/Print Das Ergebnis einer Berechnung oder die Ausgabe einer Funktion wird auf der Konsole angezeigt. Die Definitionen sind angelehnt an Venables et al. (2023), Wickham (2019) und Reussner (2016). 1.2 Style Guide Anders als beispielsweise in Python gibt es in R keinen allgemein anerkannten “Coding Style”, also keine über die Syntaxregeln hinausgehenden Vorgaben, wie Code am besten geschrieben wird. Es gibt allerdings einige breit akzeptierte Empfehlungen. Wir richten uns in diesem Kurs nach dem “Tidyverse Style Guide” von Hadley Wickham: https://style.tidyverse.org/. 1.3 Kommentare Um den eigenen Code für andere verständlicher zu gestalten und sich selbst an seinen Code zu erinnern, sollte man diesen immer gut kommentieren. # Das ist ein Kommentar 1.4 Datentypen In R ist ganz grundsätzlich alles ein Objekt: ein Wort, eine Zahl, ein Vektor, eine Liste, eine Variable und sogar Funktionen (lernen wir alles später), all das wird in R als Objekt behandelt. Wie auch in der realen Welt haben verschiedene Objekte verschiedene Eigenschaften und sie können für verschiedene Zwecke und auf verschiedene Weise verwendet werden. Das hängt davon ab, um was für eine Art Objekt es sich handelt: ein Objekt vom Typ “Lampe” kann man anschalten und ausschalten, mathematische Objekte wie Zahlen kann man addieren und dividieren, ein Auto kann fahren, parken oder tanken. In R haben wir es natürlich nicht mit realen Objekten zu tun, sondern eigentlich mit “Datenobjekten”. In R gibt es vier grundlegende Datentypen (und zwei, die wir jetzt erstmal ignorieren): character (auch “character string”): Zeichenkette integer: Ganzzahl numeric (auch “double”): Gleitkommazahl logical (auch “boolean”): Boolescher Wahrheitswert Character ist kurz für “character string”; in anderen Programmiersprachen heißt dieser Datentyp daher oft “string”. In R wird jeder Ausdruck, der von Anführungszeichen umgeben ist, als Zeichenkette (character) interpretiert. Double ist, ähnlich wie bei character und string, der allgemeine Name für den Datentyp numeric. Der Default-Datentyp für Zahlen ist in R numeric. Um eine Zahl als Integer zu definieren, kann ein großes L an die Zahl angefügt werden. Logical steht für die beiden Werte TRUE und FALSE. Sie werden auch als Boolesche Wahrheitswerte bezeichnet (-&gt; kennt ihr ggf. aus der Aussagenlogik). Für “Datentyp” kann man auch kurz “Typ” sagen. Ein paar Beispiele: 2 2L 345682389 4.6 # Punkt statt Komma! &quot;4.6&quot; TRUE FALSE &quot;Hello World&quot; # Anführungszeichen! &quot;Ein ganz langer Satz! Mit mehreren Satzzeichen. Und einer Zahl: 34.&quot; &quot; &quot; Den Datentyp eines Objekts könnt ihr z.B. mit der Funktion typeof() abfragen. Wenn ihr jede Zeile nacheinander in ein R Skript kopiert und ausführt, wird auf der Konsole (Fenster Console im RStudio) der Wert ausgegeben, der hier von #&gt; angeführt wird. typeof(2) #&gt; [1] &quot;double&quot; typeof(2L) #&gt; [1] &quot;integer&quot; typeof(4.6) #&gt; [1] &quot;double&quot; typeof(&quot;Hello World&quot;) #&gt; [1] &quot;character&quot; typeof(TRUE) #&gt; [1] &quot;logical&quot; Verständnisfragen: Ist ” ” auch ein Zeichen? Haben 4.6 und “4.6” denselben Datentyp? Welchen Datentyp hat der Satz “Ein ganz langer Satz! …”? Style Tip: Für Zeichenketten können einfache oder doppelte Anführungszeichen verwendet werden. Wickham empfiehlt, für Zeichenketten doppelte Anführungszeichen zu verwenden, außer, wenn diese selbst Anführungszeichen beinhalten, hier werden beide Anführungszeichen wie folgt kombiniert: ‘Text mit “Anführungszeichen”’. 1.5 Operatoren Je nachdem, welchen Datentyp ein oder mehrere Objekte in R haben, können diese Objekte auf verschiedene Weise mithilfe von Operatoren manipuliert werden. Arithmetische Operatoren sind aus der Schulmathematik bekannt. Es handelt sich dabei um Operatoren wie -, +, *, / sowie %% und %/%. Beachtet, dass der Divisionsoperator / nur für numerics definiert ist. Für die Division zweier integers wird ein spezieller Divisionsoperator, %/%, verwendet. %% ist der modulo Operator, damit kann bei einer Division der Rest berechnet werden. ^ oder ** wird zum Exponieren verwendet. 5 + 4 #&gt; [1] 9 10 / 5 #&gt; [1] 2 3 * 6.3 #&gt; [1] 18.9 10 %% 5 #&gt; [1] 0 10^2 #&gt; [1] 100 10**2 #&gt; [1] 100 Verständnisfragen: Was passiert, wenn wir \"Hallo\" + \"Welt\" ausführen? Welche Datentypen in R erlauben arithmetische Operationen? Logische Operatoren ermöglichen es, Werte zu vergleichen und die Richtigkeit einer logischen Aussage zu überpüfen. Die Vergleichsoperatoren &lt;, &gt;, &lt;=, &gt;= sind allgemein bekannt. Außerdem sind folgende Operatoren wichtig: Operator Bedeutung == genau gleich != ungleich !x nicht x x ⎮ y x oder y x &amp; y x und y x ⎮⎮ y x oder y in Kontrollstrukturen x &amp;&amp; y x und y Kontrollstrukturen Beispiele: -5 &lt; -10 #&gt; [1] FALSE 5 &gt;= 5 #&gt; [1] TRUE 3 != 5 #&gt; [1] TRUE &quot;Hallo&quot; != &quot;Hello&quot; #&gt; [1] TRUE 3 == 3 &amp; &quot;c&quot; == &quot;c&quot; #&gt; [1] TRUE 3 == 3 | &quot;c&quot; == &quot;a&quot; #&gt; [1] TRUE &quot;Eine Rose ist eine Pflanze&quot; == &quot;Eine Rose ist keine Pflanze&quot; #&gt; [1] FALSE Verständnisfragen: Warum wird der Ausdruck 3 == 3 &amp; \"c\" == \"c\" zu TRUE evaluiert? Warum wird auch der Ausdruck 3 == 3 | \"c\" == \"a\" zu TRUE evaluiert? Was passiert im letzten Beispiel? Der Wahrheitswert, zu dem ein Ausdruck mit einem logischen Operator in R evaluiert wird, lässt sich aus einer sogenannten Wahrheitstabelle ablesen. Für zwei Ausdrücke A und B und die logischen Operatoren &amp; und | lassen sich die folgenden Kombinationen als Wahrheitstabelle darstellen: Verständnisfragen: A sei der Ausdruck 3 == 3 &amp; \"c\" == \"c\" und B sei der Ausdruck -5 &lt; -10. Ist A &amp; B wahr oder falsch? Ist A | B wahr oder falsch? In Kontrollstrukturen (lernen wir noch) werden anstelle von &amp; und | die beiden Operatoren &amp;&amp; und || verwendet. Das hat den Grund, dass die Objekte in einem Ausdruck mit &amp;und | bei “elementweise” ausgewertet werden. Bei der Auswertung von Ausdrücken mit &amp;&amp; und || wird dagegen nur das erste Element ausgewertet. Dieses Verhalten heißt deswegen auch “lazy evaluation”. Das Verhalten ist bei einfachen Ausdrücken nicht bemerkbar, aber es wird relevant, wenn die Operatoren auf Datenstrukturen anstelle von einzelnen Werten wie bisher angewendet werden. Für die beiden Operatoren &amp;&amp; und || sind die Wahrheitstabellen also nur dann zu den Wahrheitstabellen der Operatoren &amp; und | analog, wenn einzelne Werte verglichen werden. Darauf werden wir in der kommenden Stunde noch einmal zurückkommen, wenn wir Objekte kennengelernt haben, die aus mehreren Elementen bestehen. Im nächsten Abschnitt werden wir einen weiteren Operator kennenlernen, den sogenannten Zuweisungsoperator &lt;- bzw. =. Daneben gibt es die Zugriffsoperatoren [], [[]], [:] und $, mit denen Operationen auf Datenstrukturen ausgeführt werden können. Diese Operatoren lernen wir in der nächsten Stunde kennen, wenn wir uns mit Datenstrukturen beschäftigen. 1.6 Variablen Angenommen, wir wollen den Wert, der ausgegeben wird, wenn der Ausdruck 3 == 3 &amp; \"c\" == \"c\" evaluiert wird, im Programmverlauf noch einmal verwenden. Dann wäre es unpraktisch, wenn wir jedes Mal den gesamten Ausdruck kopieren müssten. Wenn wir später die 3 durch eine 4 ersetzen, müssten wir dann alle Stellen finden, wo derselbe Ausdruck vorkommt, und überall die Änderung vornehmen. So entstehen schnell Fehler. Aus diesem Grund gibt es Variablen. Variablen ermöglichen, einen bestimmten Wert im Verlauf des Programms mehrmals zu verwenden, ohne ihn jedes Mal neu berechnen oder eingeben zu müssen. Werte können mithilfe der Zuweisungsoperatoren &lt;- und = einer Variable “zugewiesen” werden. Das heißt, dass ein Name festgelegt wird, der fortan für diesen Wert und für den Speicherplatz, in dem der Wert gespeichert wird, steht. Man kann alternativ auch sagen, dass ein Wert “an einen Namen gebunden” wird, oder andersherum, dass der Name einen bestimmten Wert “referenziert”. Eine Zuweisung folgt in R dem Schema Name &lt;- Wert. So kann mithilfe des Variablennamens auf den damit verknüpften Wert zugegriffen werden, selbst dann, wenn sich der Wert im Programmverlauf verändert hat. Variablen sind also sowas wie Platzhalter für Werte eines Datentyps. Bei der Benennung von Variablen sollten bestimmte Regeln und die Konventionen aus unserem Style Guide eingehalten werden: Variablennamen dürfen kein Leerzeichen enthalten (Regel!). Variablennamen dürfen keine Sonderzeichen außer Punkte und Unterstriche enthalten (Regel!). Zwei Wörter oder ein Wort und eine Zahl können mit Unterstrich, Punkt, oder camelCase getrennt werden. Wickhams Empfehlung ist hier die Verwendung des Unterstrichs. Variablen dürfen nicht mit einer Zahl oder einem Unterstrich anfangen (Regel!). R ist “case sensitive”, das heißt: die Variable baum ist nicht dasselbe wie die Variable Baum! Wickham empfiehlt, alle Variablennamen klein zu schreiben. Mit dem Zuweisungsoperator &lt;- bzw. = kann ein Wert einem Namen zugewiesen werden. &lt;- und = sind gleichbedeutend; Wickham empfiehlt aber die Verwendung des Operators &lt;-. Beim Ausführen einer Zuweisung wird nichts auf dem Bildschirm (auf der Rstudio Konsole) ausgegeben. Nach der Zuweisung können Werte, die einer Variable zugeordnet sind, mithilfe der Funktion print() auf dem Bildschirm ausgegeben werden. Alternativ kann auch einfach der Variablennamen erneut eingegeben und ausgeführt werden. # Zuweisungen zahl &lt;- 454 satz &lt;- &quot;Eine Rose ist eine Pflanze&quot; satz_2 &lt;- &quot;Eine zweite Rose ist auch eine Pflanze&quot; noch_ein_satz &lt;- &quot;Noch eine Rose&quot; Satz &lt;- &quot;Eine Rose ist keine Pflanze&quot; # Variable Satz auf dem Bildschirm ausgeben print(Satz) #&gt; [1] &quot;Eine Rose ist keine Pflanze&quot; # Variable satz auf dem Bildschirm ausgeben print(satz) #&gt; [1] &quot;Eine Rose ist eine Pflanze&quot; # Variable satz ohne die print()-Funktion auf dem Bildschirm ausgeben satz #&gt; [1] &quot;Eine Rose ist eine Pflanze&quot; # Der Variable satz einen neuen Wert zuweisen satz &lt;- &quot;Ein Apfel ist keine Pflanze&quot; # Variable satz erneut ausgeben print(satz) #&gt; [1] &quot;Ein Apfel ist keine Pflanze&quot; # hier werden die Variablen satz und Satz aus dem Beispiel oben verglichen satz == Satz #&gt; [1] FALSE Verständnisfragen: Welchen Datentyp hat die Variable zahl? Warum wird das erste Mal, dass die Anweisung print(satz) ausgeführt wird, ein anderer Wert ausgegeben, als beim zweiten Mal? Warum wird der Ausdruck satz == Satz zu FALSE evaluiert? Warum ist es nicht korrekt zu sagen, dass bei der Zuweisung ein Wert in einer Variable gespeichert wird? Wie könn die Ausdrücke 1 &gt; 2 &amp; 1 &lt; 4, 1 &gt; 2 | 1 &lt; 4 und (1 &lt; 4) == \"Hund\" mithilfe von Variablen so umgeschrieben werden, dass sich die Zahl 1 nicht wiederholt? Was passiert, wenn der Code 23 -&gt; zahl ausgeführt wird? Nicht nur einzelne Werte können Variablen zugewiesen werden, sondern auch ganze Ausdrücke. In der nächsten Stunde werden wir außerdem sehen, dass auch Datenstrukturen Variablen zugewiesen werden können. # Ausdrücke als Variablen aussage_1 &lt;- &quot;c&quot; == &quot;c&quot; aussage_2 &lt;- 3 == 5 aussage_1 == !aussage_2 #&gt; [1] TRUE Verständnisfragen: Was passiert in diesem Beispiel? Welcher Wert wird den Variablen aussage_1 und aussage_2 zugewiesen? Gut zu wissen: Eine Zuweisung ist eine Art von Anweisung: Sie beschreibt eine bestimmte Aktion, die vom Computer ausgeführt wird und die den Zustand des Speichers ändert. Deswegen sagt man, dass Anweisungen ausgeführt werden, während Ausdrücke ausgewertet werden. 1.7 Operatorpräzedenz Wir haben bereits einige Beispiele für Ausdrücke kennengelernt, die mehrere Operatoren beinhalten. Wie auch bei arithmetischen Operatoren gibt es bei allen anderen Operatoren eine festgelegte Reihenfolge, in der diese Operatoren ausgewertet werden, wenn sie im selben Ausdruck vorkommen und sich einen Operanden teilen. Für die bisher bekannten Operatoren gilt die folgende Rangfolge: Rang Operator 1 () 2 $ 3 [], [[]] 4 ^ 5 [:] 6 *, / 7 +, - 8 &lt;, &gt;, &lt;=, &gt;=, ==, != 9 ! 10 &amp;, &amp;&amp; 11 ⎮, ⎮⎮ 12 &lt;-, = Wenn diese Auswertungsreihenfolge geändert werden soll, müssen runde Klammern verwendet werden. Beispiele: 4 + 10 &gt; 3 + 5 * 2 #&gt; [1] TRUE 4 + 10 &gt; (3 + 5) * 2 #&gt; [1] FALSE FALSE &amp; TRUE == FALSE #&gt; [1] FALSE (FALSE &amp; TRUE) == FALSE #&gt; [1] TRUE Wenn zwei Operatoren in einem Ausdruck denselben Rang haben und einen Operanden teilen, wird der Ausdruck nach der sogenannten Assoziativität der Operatoren ausgewertet: wenn ein Operator linksassoziativ ist, dann heißt dass, dass ein Ausdruck von links nach rechts ausgewertet wird. Wenn ein Operator rechtsassoziativ ist, wird ein Ausdruck von rechts nach links ausgewertet. In R sind fast alle Operatoren linksassoziativ; nur der Potenzierungsoperator und der Zuweisungsoperartor sind rechtsassoziativ. Linksassoziatitvität: ((4+5)+6)+1 = (9+6)+1 = 15+1 = 16 Rechtsassoziativität: 3**(4**5) = 3**1024 = eine sehr lange Zahl Quellen Venables, W.N. and Smith, D.M. and the R Core Team (2023). An Introduction to R, https://cran.r-project.org/doc/manuals/r-release/R-intro.pdf Wickham, Hadley. The Tidyverse Style Guide, https://style.tidyverse.org/ Wickham, Hadley (2019). Advanced R. Chapter 2: Names and Values, https://adv-r.hadley.nz/names-values.html Reussner, Ralf H. Mitschnitt zur Vorlesung “Programmieren” im WiSe 2015/2016. 02: Typen und Variablen, https://www.youtube.com/watch?v=POe41EL2EgU R 4.3.0 Documentation. Operator Syntax and Precedence, https://stat.ethz.ch/R-manual/R-devel/library/base/html/Syntax.html Wickham, Hadley (2019). Advanced R. Chapter 4: Subsetting, https://adv-r.hadley.nz/subsetting.html "],["r-basics-ii-datenstrukturen.html", "2 R Basics II: Datenstrukturen 2.1 Grundlegende Begriffe 2.2 Vektoren 2.3 Listen 2.4 Auf einen Blick: Vektoren vs benannte Vektoren vs Faktoren vs Listen 2.5 Matrizen 2.6 Arrays 2.7 Dataframes 2.8 Auf einen Blick: Matrizen vs Arrays vs Dataframes 2.9 Datenstrukturen untersuchen 2.10 Fehlende und ungültige Werte in Datenstrukturen 2.11 Der Mitgliedschaftsoperator %in% 2.12 Unveränderbarkeit von Objekten in R Quellen", " 2 R Basics II: Datenstrukturen Bisher haben wir Variablen als Platzhalter für Werte vom Typ character, integer, numeric oder logical genutzt. Variablen können aber auch Platzhalter für strukturierte Sammlungen von Werten sein. Datenstrukturen können anstelle von einfachen Werten auch selbst wieder Datenstrukturen enthalten. Die verschiedenen Weisen, wie Daten in R organisiert und im Speicher repräsentiert werden können, werden Datenstrukturen genannt. Solche Datenstrukturen können entweder nur Elemente vom selben Typ aufnehmen (wie z.B. Vektoren und Matrizen), oder Elemente unterschiedlichen Typs (wie z.B. Listen und Dataframes). Wir werden in diesem Kapitel alle wichtigsten Datenstrukturen besprechen. In der Praxis werden wir aber vor allem mit Vektoren und Dataframes arbeiten. 2.1 Grundlegende Begriffe Begriff Englische Entsprechung Definition (im R-Kontext) Element Element Wert oder anderes Objekt innnerhalb einer Datenstruktur. Datenstrukturen können selbst Elemente einer anderen Datenstruktur sein. Elemente haben einen Index und manchmal zusätzlich einen Namen (oder ‘Schlüssel’), über den auf das Element zugegriffen werden kann. Index Index Position eines Elements innerhalb einer Datenstruktur. Ein Index ist in R immer eine Zahl &gt;= 1. Indexierung Indexing Überbegriff für verschiedene Operationen, mit denen auf Elemente in einer Datenstruktur zugegriffen werden kann. Zugreifen Access Operation, bei der durch den Einsatz spezifischer Operatoren Elemente einer Datenstruktur ausgewählt, diese extrahiert oder modifiziert werden können. Vektorisierung Vectorization Mechanismus, bei dem Funktionen oder Operationen automatisch auf alle Elemente eines Vektors angewandt werden, statt auf einzelne Elemente. Dimension Dimension In Bezug auf Matrizen die Anzahl von Zeilen und Spalten (angegeben als Zeilen x Spalten). In Bezug auf Arrays allgemein die Anzahl der verschiedenen ‘Richtungen’, in denen Daten organisiert sind. Bei einem Array können das nicht nur Zeilen und Spalten sein, sondern auch ‘Schichten’ von Matrizen und andere Organisationsweisen. 2.2 Vektoren Eigentlich haben wir in der letzten Stunde schon Vektoren kennengelernt. Denn in R ist jeder einzelne Wert zugleich ein Vektor der Länge 1. Vektoren sind nämlich im Grunde Sequenzen verschiedener Werte desselben Datentyps. Die Werte innerhalb eines Vektors werden Elemente genannt. Die Elemente in einem Vektor haben eine festgelegte Reihenfolge. Jedes Element in einem Vektor hat deswegen eine Position (auch “Index” genannt) zwischen 1 und n, wobei n eine beliebige ganze Zahl &gt; 1 ist. Über den Index kann auf jedes Element einzeln zugegriffen werden oder es können mehrere Elemente gleichzeitig ausgewählt werden. Der Zugriff auf Elemente des Vektors erfolgt mithilfe von eckigen Klammern und wird im Abschnitt 2.2.4 erläutert. 2.2.1 Vektoren erstellen Vektoren können mithilfe von bestimmten Funktionen (lernen wir noch) erstellt werden. Wenn bei der Erstellung bekannt ist, welchen Datentyp die Elemente haben sollen, können die Funktionen character() oder numeric() zur Erstellung verwendet werden. Im Regelfall ist aber die Anzahl der Elemente und/oder deren Datentyp bei der Erstellung noch nicht bekannt. In diesem Fall wird zur Erstellung eines leeren Vektors die Funktion c() verwendet: # leeren Vektor erstellen, ohne einen bestimmten Datentyp festzulegen c() #&gt; NULL Wenn ein leerer Vektor erstellt wird, wird dieser mithilfe des Werts NULL repräsentiert. Darauf kommen wir am Ende der Sitzung noch einmal zurück. Mithilfe der Funktion c() können auch Vektoren aus bereits bekannten Elementen erstellt werden: # Vektor aus einer Zahlsequenz erstellen zahlen &lt;- 1:3 print(zahlen) #&gt; [1] 1 2 3 # Vektoren mit selbst gewählten Elementen erstellen leckere_fruechte &lt;- c(&quot;Apfel&quot;, &quot;Banane&quot;, &quot;Erdbeere&quot;) coole_zahlen &lt;- c(45, 7, 420) Vektoren können auch durch Zusammenfügen zweier bestehender Vektoren erstellt werden. Wenn die Funktion c() auf zwei Vektoren oder einen Vektor und ein Element angewandt wird, dann werden die beiden Vektoren in der angegebenen Reihenfolge in einen neuen Vektor kombiniert: # Vektoren kombinieren mithilfe der Funktion c() fruechte_und_zahlen &lt;- c(leckere_fruechte, coole_zahlen) # Vektor auf dem Bildschirm ausgeben print(fruechte_und_zahlen) #&gt; [1] &quot;Apfel&quot; &quot;Banane&quot; &quot;Erdbeere&quot; &quot;45&quot; &quot;7&quot; &quot;420&quot; Achtung: Bei der Erstellung von Vektoren muss beachtet werden, dass der Typ der Elemente automatisch vereinhetilicht wird, wenn Elemente mit unterschiedlichen Datentypen in einen Vektor kombiniert werden: vec &lt;- c(&quot;hallo&quot;, &quot;1&quot;) vec &lt;- c(vec, 3) # double wird zu character typeof(vec) #&gt; [1] &quot;character&quot; # bool wird zu double vec &lt;- c(3, TRUE) typeof(vec) #&gt; [1] &quot;double&quot; Nur, wenn ein Element des Vektors eine Liste ist, gilt dieses Prinzip nicht. Darauf kommen wir im Abschnitt “Listen” noch einmal zurück. Während es jeden Index nur einmal gibt, können sich die Werte in einem Vektor wiederholen: fruechte &lt;- c(&quot;Apfel&quot;, &quot;Apfel&quot;, &quot;Orange&quot;) In diesem Vektor gibt es den Wert “Apfel” zwar zweimal, aber die Werte haben verschiedene Indexpositionen (1 bzw. 2). 2.2.2 Sets (Mengen) In anderen Programmiersprachen (bspw. Python) gibt es eine Datenstruktur, die oft Set (Menge) genannt wird. Sets (Mengen) sind dadurch ausgezeichnet, dass alle Werte einzigartig sind. In R gibt es keine eigenständige Datenstruktur für Mengen. Dennoch ist es möglich und oft nützlich, in R mit Sammlungen von einzigartigen Werten zu arbeiten und Mengenoperationen durchzuführen. In R können Mengen aus Vektoren erstellt werden, indem die einzigartigen Werte eines Vektors oder mehrerer Vektoren extrahiert werden: # Einzigartige Werte eines Vektors ausgeben lassen unique(c(&quot;Apfel&quot;, &quot;Banane&quot;, &quot;Erdbeere&quot;, &quot;Apfel&quot;)) #&gt; [1] &quot;Apfel&quot; &quot;Banane&quot; &quot;Erdbeere&quot; # Vereinigung von zwei Vektoren: union(c(&quot;Apfel&quot;, &quot;Banane&quot;, &quot;Erdbeere&quot;, &quot;Apfel&quot;), c(&quot;Kiwi&quot;, &quot;Grapefruit&quot;)) #&gt; [1] &quot;Apfel&quot; &quot;Banane&quot; &quot;Erdbeere&quot; &quot;Kiwi&quot; &quot;Grapefruit&quot; # Schnittmenge von zwei Vektoren: intersect(c(&quot;Apfel&quot;, &quot;Banane&quot;), c(&quot;Erdbeere&quot;, &quot;Apfel&quot;)) #&gt; [1] &quot;Apfel&quot; # Differenz zwischen zwei Vektoren: Elemente erhalten, die im ersten Vektor, aber nicht im zweiten Vektor vorkommen. setdiff(c(&quot;Apfel&quot;, &quot;Banane&quot;), c(&quot;Erdbeere&quot;, &quot;Apfel&quot;)) #&gt; [1] &quot;Banane&quot; 2.2.3 Named Vectors Neben den “einfachen” Vektoren gibt es noch sogenannte benannte Vektoren oder named vectors. Das sind Vektoren, bei dem jedem Element nicht nur eine Indexposition, sondern auch ein Name zugeordnet ist. Um einen named vector zu erstellen, wird ebenfalls die Funktion c() verwendet. Den Elementen wird bei der Erstellung des Vektors aber ein Name (oder “Schlüssel”) zugeordnet. Dieser muss ein character sein. Beachtet, dass bei der Zuweisung von Namen innerhalb von Funktionen anstelle des Zuweisungsoperators &lt;- der Operator = verwendet wird: # Erstellung eines named vectors: Schlüssel sind immer Zeichenketten einkauf &lt;- c(&quot;Apfel&quot;=4, &quot;Banane&quot;=3, &quot;Erdbeere&quot;=20) # ...selbst dann, wenn ihr Wörter ohne Anführungszeichen eingebt, weiß R, dass eine Zeichenkette gemeint ist: einkauf &lt;- c(Apfel=4, Banane=3, Erdbeere=20) # Das geht allerdings nicht, wenn ihr Zahlen als Schlüssel eingebt! # einkauf &lt;- c(1=4, 2=3, 3=20) 2.2.4 Faktoren Da R ursprünglich für die Statistik entwickelt wurde, haben sich die Entwickler:innen der Programmiersprache überlegt, dass es praktisch wäre, wenn es eine Datenstruktur speziell für kategorische (auch “kategoriale”) Daten gäbe. Kategorische Daten sind Daten, die in bestimmte Kategorien oder Gruppen fallen, also beispielsweise Farben, Regionen, Beschäftigungsstatus. Speziell zur Organisation solcher Daten gibt es in R Faktoren. Ein Faktor ist eine spezielle Art von Vektor, der kategorische Daten repräsentiert. Es handelt sich dabei eigentlich um einen “einfachen” Vektor, dem eine zusätzliche Metainformation hinzugefügt wurde: die Information, welche verschiedenen Arten oder Kategorien von Werten der Vektor enthält (=“Levels”). Im Beispiel oben hat der Vektor vier Elemente, aber nur drei verschiedene Elemente, nämlich “Apfel”, “Banane” und “Erdbeere”. Die Levels entsprechen also im Grunde genau den einzigartigen Werten eines Vektors, die wir im Abschnitt zu Sets (Mengen) mithilfe der Funktion unique(c(\"Apfel\", \"Banane\", \"Erdbeere\", \"Apfel\")) erhalten haben. Faktoren erlauben also, sowohl die ursprünglichen, möglicherweise wiederholt vorkommenden Werte als auch die einzigartigen Werte in einem Vektor zu repräsentieren. Faktoren werden mithilfe der Funktion factor() erstellt. Faktoren werden stets aus bereits existierenden Vektoren erstellt, beispielsweise aus dem Vektor fruechte, den wir hier noch einmal neu erstellen: fruechte &lt;- c(&quot;Apfel&quot;, &quot;Banane&quot;, &quot;Erdbeere&quot;, &quot;Apfel&quot;) factor(fruechte) #&gt; [1] Apfel Banane Erdbeere Apfel #&gt; Levels: Apfel Banane Erdbeere In der Praxis werden wir nicht häufig Faktoren selbst erstellen. Trotzdem solltet ihr zumindest von Faktoren gehört haben. Denn Faktoren werden in R häufig automatisch “unter der Motorhaube” beim Anwenden vieler Funktionen erstellt. Ein Beispiel dafür besprechen wir im nächsten Abschnitt. Faktoren vereinfachen viele Operationen und Berechnungen und sind einer der Gründe dafür, warum sich R von anderen Programmiersprachen unterscheidet. Deswegen sind Faktoren zum Verständnis von R und von manchen Funktionen wichtig, auch, wenn wir selbst damit nicht häufig arbeiten. 2.2.5 Operationen auf Vektoren Wir haben gesehen, dass alle Vektoren, egal ob einfache Vektoren, benannte Vektoren oder Faktoren, Elemente in einer festgelegten Reihenfolge enthalten, Wir haben auch gesehen, dass jedes Element einen Index hat, also eine Zahl, welche die Position des Elements in dem Vektor beschreibt. Um auf ein oder mehrere Elemente in einem Vektor zuzugreifen, wird der Zugriffsoperator [] verwendet. Diesen Operator tauchte in der letzten Woche bereits in der Tabelle im Abschnitt “Operatorpräzedenz” auf. In die eckigen Klammern wird der Index oder, bei benannten Vektoren, der Name des ausgewählten Elements geschrieben. Als Beispiel für den Zugriff über den Index sehen wir uns einige Zugriffsoperationen auf den Vektor fruechte an, den wir hier erneut erstellen: fruechte &lt;- c(&quot;Apfel&quot;, &quot;Banane&quot;, &quot;Erdbeere&quot;, &quot;Apfel&quot;) # Zugriff auf das erste Element des Vektors leckere_fruechte über den Index fruechte[1] #&gt; [1] &quot;Apfel&quot; # Zugriff auf Elemente 1-3 fruechte[1:3] #&gt; [1] &quot;Apfel&quot; &quot;Banane&quot; &quot;Erdbeere&quot; # Zugriff auf Elemente 1 und 3 fruechte[c(1,3)] #&gt; [1] &quot;Apfel&quot; &quot;Erdbeere&quot; # Zugriff auf alle Elemente mit dem Wert &quot;Banane&quot; fruechte[fruechte == &quot;Banane&quot;] #&gt; [1] &quot;Banane&quot; Die Zugriffsoperation fruechte[fruechte == \"Banane\"] bedarf vielleicht einer kurzen Erläuterung. Wie funktioniert diese Operation? Warum werden nur die Elemente ausgegeben, deren Wert “Banane” ist? Zunächst wird der Ausdruck in den eckigen Klammern evaluiert, fruechte == \"Banane\". Dabei wird ein Mechanismus aktiviert, der sich Vektorisierung nennt (s. nächster Abschnitt): Beim Auswerten des Ausdrucks fruechte == \"Banane\" wird einzeln für jedes Element überprüft, ob dieses Element dem Wert “Banane” entspricht. Der Ausdruck wird also zu einem Vektor aus Wahrheitswerten ausgewertet wird und nicht zu einem einzelnen Wahrheitswert wie in den Beispielen aus der letzten Woche. Wenn im Vektor fruechte der Wert “Banane” steht, steht in diesem Vektor TRUE und sonst FALSE. Danach wird die eigentliche Zugriffsoperation ausgeführt, allerdings mit dem logischen Vektor anstelle der Indizes: fruechte[c(FALSE, TRUE, FALSE, FALSE)]. Bei einer solchen Zugriffsoperation werden alle Elemente ausgegeben, für die in dem logischen Vektor TRUE steht. Eine Zugriffsoperation der Art fruechte == \"Banane\", wird deswegen auch bedingter Zugriff genannt. Anstelle des logischen Operators == kann hier auch ein anderer logischer Operator oder ein Vergleichsoperator stehen. Elemente in einem Vektor können auch ausgetauscht, hinzugefügt oder entfernt werden: # Element an Indexposition 1 austauschen fruechte[1] &lt;- &quot;Orange&quot; # Neues Element an Indexposition 5 hinzufügen fruechte[5] &lt;- &quot;Birne&quot; # Neues Element am Ende des Vektors hinzufügen fruechte &lt;- c(fruechte, &quot;Melone&quot;) # Neues Element am Anfang des Vektors hinzufügen fruechte &lt;- c(&quot;Traube&quot;, fruechte) # Element an Indexposition 1 entfernen fruechte[-1] #&gt; [1] &quot;Orange&quot; &quot;Banane&quot; &quot;Erdbeere&quot; &quot;Apfel&quot; &quot;Birne&quot; &quot;Melone&quot; Elemente können auch direkt einer neuen Variable zugewiesen werden: erste_frucht &lt;- fruechte[1] print(erste_frucht) #&gt; [1] &quot;Traube&quot; Um sich die Anzahl der Werte in einem Vektor (also dessen “Länge”) ausgeben zu lassen, kann die Funktion length() verwendet werden: length(c(&quot;Apfel&quot;, &quot;Banane&quot;, &quot;Erdbeere&quot;, &quot;Apfel&quot;)) #&gt; [1] 4 Die Funktion length() kann mit der Funktion unique() kombiniert werden, um die Anzahl der einzigartigen Werte in einem Vektor auszugeben: length(unique(c(&quot;Apfel&quot;, &quot;Banane&quot;, &quot;Erdbeere&quot;, &quot;Apfel&quot;))) #&gt; [1] 3 Um auf die Elemente eines benannten Vektors zuzugreifen, kann entweder der Index oder der Name des Elements verwendet werden: einkauf &lt;- c(&quot;Apfel&quot;=4, &quot;Banane&quot;=3, &quot;Erdbeere&quot;=20, &quot;Apfel&quot;=5) # Zugriff auf das Element mit dem Namen &quot;Erdbeere&quot;: Hier müssen die Anführungszeichen wieder explizit angegeben werden (zur Erinnerung: Schlüssel sind immer character!) einkauf[&quot;Erdbeere&quot;] #&gt; Erdbeere #&gt; 20 # Zugriff auf den Wert ohne den Namen einkauf[[&quot;Erdbeere&quot;]] #&gt; [1] 20 # Zugriff auf alle Elemente mit dem Namen &quot;Apfel&quot;: einkauf[&quot;Apfel&quot;] #&gt; Apfel #&gt; 4 # Zugriff auf mehrere Elemente einkauf[c(&quot;Apfel&quot;, &quot;Erdbeere&quot;)] #&gt; Apfel Erdbeere #&gt; 4 20 # Wert (!) des Elements mit dem Namen &quot;Banane&quot; austauschen einkauf[&quot;Banane&quot;] &lt;- 5 # Neues Element mit dem Namen &quot;Birne&quot; hinzufügen einkauf[&quot;Birne&quot;] &lt;- 3 # Neues Element am Ende des Vektors hinzufügen einkauf &lt;- c(einkauf, Melone=1) # Neues Element am Anfang des Vektors hinzufügen einkauf &lt;- c(Traube=12, einkauf) # Element mit dem Namen &quot;Birne&quot; entfernen: einkauf &lt;- einkauf[!(names(einkauf) == &quot;Birne&quot;)] einkauf #&gt; Traube Apfel Banane Erdbeere Apfel Melone #&gt; 12 4 5 20 5 1 Um nur auf die Level, also die verschiedenen Arten von Werten in einem Faktor zuzugreifen, wird die Funktion levels() verwendet: fruechte &lt;- c(&quot;Apfel&quot;, &quot;Banane&quot;, &quot;Erdbeere&quot;, &quot;Apfel&quot;) fruechte_fct &lt;- factor(fruechte) levels(fruechte_fct) #&gt; [1] &quot;Apfel&quot; &quot;Banane&quot; &quot;Erdbeere&quot; Wir haben bereits gesehen, dass die Funktion length() mit der Funktion unique() kombiniert werden kann, um sich die Anzahl der einzigartigen Werte in einem Vektor ausgeben zu lassen. Aber wenn man herausfinden möchte, wie oft jeder Wert jeweils vorkommt, dann ist das mithilfe der unique() Funktion kompliziert: # Diesen Code müsst ihr nicht verstehen, er dient nur, um die Komplexität zu illustrieren haeufigkeiten &lt;- sapply(unique(fruechte), function(x) sum(fruechte == x)) haeufigkeiten #&gt; Apfel Banane Erdbeere #&gt; 2 1 1 Mithilfe von Faktoren können wir viel einfacher herausfinden, wie oft jeder Wert vorkommt, und zwar mithilfe der Funktion table(): table(factor(fruechte)) #&gt; #&gt; Apfel Banane Erdbeere #&gt; 2 1 1 Tatsächlich wandelt die Funktion table() automatisch den Vektor in einen Faktor um. Wenn wir herausfinden wollen, wie oft jeder Wert in einem Vektor vorkommt, dann brauchen wir also nicht unbedingt erst den Vektor in einen Faktor umwandeln. Wir können die table()-Funktion direkt auf den Vektor anwenden: table(fruechte) #&gt; fruechte #&gt; Apfel Banane Erdbeere #&gt; 2 1 1 Wie wir gesehen haben, greift die Funktion table() unter der Motorhaube auf Faktoren zurück und wandeln einen Vektor automatisch in einen Faktor um. Verständnisfragen: Wie viele Elemente hat der Vektor fruechte? Wie kann das Element \"Orange\" aus dem Vektor fruechte entfernt werden? An welcher Indexposition steht es jetzt? Sind einzelne Zahlen oder Zeichenketten in R auch Datenstrukturen? Wenn ja, welche? Zu welchem Wahrheitswert wird der Ausdruck c(2) == 2 evaluiert? Warum? Wie kann auf alle Elemente mit dem Wert 3 im Vektor einkauf zugegriffen werden? 2.2.6 Vektorisierung Im Abschnitt “Operationen auf Vektoren” habt ihr bereits gesehen, dass die bereits bekannten Operatoren wie ==, &gt; oder + auch auf Vektoren angewendet werden können. Wenn Operatoren auf Vektoren angewandt werden, wird die Operation automatisch elementweise auf jedes Element des Vektors angewandt. Dieser Mechanismus nennt sich Vektorisierung. Wir werden in der Sitzung zu Funktionen noch einmal darauf zurückkommen. Wichtig ist dabei zu beachten, dass beide Vektoren die gleiche Länge haben müssen. Auf Vektoren vom Typ numeric oder integer (also Vektoren, deren Elemente alle numerics oder integers sind) können die arithmetischen Operatoren angewandt werden, zum Beispiel: vec_1 &lt;- c(1, 2, 3) vec_2 &lt;- c(3, 5, 6) vec_1 + vec_2 #&gt; [1] 4 7 9 Wird ein Vektor nicht mit einem anderen Vektor, sondern mit einem einzelnen Wert addiert (oder subtrahiert, dividiert, … ), dann wird jedes Element des Vektors mit diesem Wert verrechnet: vec_1 + 5 #&gt; [1] 6 7 8 Daneben können auch Vergleichsoperatoren und logische Operatoren auf Vektoren angewandt werden, und es können sogar zwei Vektoren elementweise verglichen werden: vec_1 == vec_2 #&gt; [1] FALSE FALSE FALSE vec_1 &lt; vec_2 #&gt; [1] TRUE TRUE TRUE vec_1 &lt; 3 #&gt; [1] TRUE TRUE FALSE In der letzten Sitzung haben wir bereits den Unterschied zwischen dem “elementweisen” Operatoren &amp; und | und den Operatoren &amp;&amp; und || angeschnitten. Das Verhalten war bei der Auswertung einfacher Ausdrücke mit einzelnen Werten nicht bemerkbar, aber es wird relevant, wenn die Operatoren auf Vektoren anstelle von einzelnen Werten angewandt werden: zahlen &lt;- 1:5 zahlen &gt; 2 &amp; zahlen &lt; 4 #&gt; [1] FALSE FALSE TRUE FALSE FALSE zahlen &gt; 2 &amp;&amp; zahlen &lt; 4 #&gt; Error in zahlen &gt; 2 &amp;&amp; zahlen &lt; 4: &#39;length = 5&#39; in coercion to &#39;logical(1)&#39; Verständnisfragen: Warum wird der Ausdruck zahlen &gt; 2 &amp; zahlen &lt; 4 zu FALSE FALSE TRUE FALSE FALSE evaluiert? Welche Datenstruktur wird ausgegeben, wenn der Ausdruck evaluiert wird? Was bedeutet die Fehlermeldung bei der Auswertung des Ausdrucks zahlen &gt; 2 &amp;&amp; zahlen &lt; 4? 2.3 Listen Listen enthalten wie Vektoren eine Sequenz von Werten. Im Abschnitt zu Vektoren haben wir bereits gelernt, dass diese Werte auch Elemente genannt werden. Genau wie bei Vektoren können sich Werte in einer Liste wiederholen. Die Elemente einer Liste sind ebenfalls geordnet, das heißt jedes Element hat einen Index, genau wie bei Vektoren. Ähnlich wie bei benannten Vektoren kann man den Elementen einer Liste außerdem einen Namen (wird manchmal auch Schlüssel genannt) zuordnen, über den auf den Wert zugegriffen werden kann. Anders als bei Vektoren können die Elemente einer Liste aber verschiedene Datentypen haben. 2.3.1 Listen erstellen Listen werden mithilfe der Funktion list() erstellt. Genau wie bei benannten Vektoren müssen die Namen oder Schlüssel der Werte Zeichenketten sein. Wenn keine Anführungszeichen angegeben werden, erkennt R auch hier automatisch, dass eine Zeichenkette gemeint ist. # Liste erstellen einkauf_liste &lt;- list(frucht=&quot;Apfel&quot;, anzahl=20, vorraetig=TRUE) # Liste ausgeben print(einkauf_liste) #&gt; $frucht #&gt; [1] &quot;Apfel&quot; #&gt; #&gt; $anzahl #&gt; [1] 20 #&gt; #&gt; $vorraetig #&gt; [1] TRUE Die einzelnen Elemente müssen dabei nicht unbedingt benannt werden, das heißt, der Code oben könnte genausogut so aussehen: list(&quot;Apfel&quot;, 20, TRUE) #&gt; [[1]] #&gt; [1] &quot;Apfel&quot; #&gt; #&gt; [[2]] #&gt; [1] 20 #&gt; #&gt; [[3]] #&gt; [1] TRUE Die Elemente einer Liste können auch Vektoren oder selbst Listen sein. Im ersten Fall wird die Liste dann “Liste von Vektoren” und im letzteren Fall “Liste von Listen” genannt. Ein allgemeiner Begriff für solche Listen ist “verschachtelte Liste”. # Liste von Vektoren erstellen: liste_von_vektoren &lt;- list(frucht = c(&quot;Apfel&quot;, &quot;Erdbeere&quot;, &quot;Banane&quot;), anzahl = c(20, 32, 0), vorraetig = c(TRUE, TRUE, FALSE) ) print(liste_von_vektoren) #&gt; $frucht #&gt; [1] &quot;Apfel&quot; &quot;Erdbeere&quot; &quot;Banane&quot; #&gt; #&gt; $anzahl #&gt; [1] 20 32 0 #&gt; #&gt; $vorraetig #&gt; [1] TRUE TRUE FALSE # Liste von Listen erstellen: liste_von_listen &lt;- list(Apfel = list(20, FALSE), Erdbeere = list(32, FALSE), Banane = list(0, TRUE) ) print(liste_von_listen) #&gt; $Apfel #&gt; $Apfel[[1]] #&gt; [1] 20 #&gt; #&gt; $Apfel[[2]] #&gt; [1] FALSE #&gt; #&gt; #&gt; $Erdbeere #&gt; $Erdbeere[[1]] #&gt; [1] 32 #&gt; #&gt; $Erdbeere[[2]] #&gt; [1] FALSE #&gt; #&gt; #&gt; $Banane #&gt; $Banane[[1]] #&gt; [1] 0 #&gt; #&gt; $Banane[[2]] #&gt; [1] TRUE Achtung: In der Liste liste_von_vektoren sind alle Vektoren gleich lang und beziehen sich aufeinander: Von der Frucht Apfel sind noch 20 Stück da, sodass Äpfel vorrätig sind. Dies muss aber nicht unbedingt der Fall sein! Die Elemente einer verschachtelten Liste können unterschiedlich lang sein und müssen sich nicht unbedingt aufeinander beziehen. Schematisch sieht eine Liste von Vektoren (hier mit Vektoren derselben Länge) in etwa so aus: Das Bild illustriert auch, wie auf die Elemente in einer Liste von Vektoren zugegriffen werden kann. Der Zugriff auf Elemente in einer Liste ist nämlich etwas komplizierter als bei einem Vektor. Darum geht es im folgenden Abschnitt. 2.3.2 Operationen auf Listen Auf Elemente und ihre Namen über den Index zugreifen: einkauf_liste[1] #&gt; $frucht #&gt; [1] &quot;Apfel&quot; Auf Elemente ohne Namen über den Index zugreifen: einkauf_liste[[1]] #&gt; [1] &quot;Apfel&quot; Auf Elemente über den Namen (Schlüssel) zugreifen: # Option 1 einkauf_liste$frucht #&gt; [1] &quot;Apfel&quot; # Option 2 einkauf_liste[[&quot;frucht&quot;]] #&gt; [1] &quot;Apfel&quot; Auf das erste Element des ersten Vektors in einer Liste von Vektoren über den Index zugreifen: liste_von_vektoren[[1]][1] #&gt; [1] &quot;Apfel&quot; Auf das erste Element des ersten Vektors in einer Liste von Vektoren über den Schlüssel zugreifen # Option 1 liste_von_vektoren[[&quot;frucht&quot;]][1] #&gt; [1] &quot;Apfel&quot; # Option 2 liste_von_vektoren$frucht[1] #&gt; [1] &quot;Apfel&quot; Listen kombinieren mit der Funktion c(): einkauf_bananen &lt;- list(frucht=&quot;Banane&quot;, anzahl=0, vorraetig=FALSE) einkauf_gesamt &lt;- c(einkauf_liste, einkauf_bananen) Verständnisfragen: Um welche Datenstruktur handelt es sich bei dem Objekt einkauf_gesamt? Was ist der Datentyp der Elemente des Objekts einkauf_gesamt? Was ist der Unterschied zwischen Listen und Named Vectors? Sehr anschaulich illustriert dieser Abschnitt in Hadley Wickham’s Lehrbuch “Advanced R” den Unterschied zwischen dem Zugriff mit einfachen und mit doppelten eckigen Klammern: Figure 2.1: Quelle: Hadley Wickham (2019), https://adv-r.hadley.nz/subsetting.html#subset-single Im letzten Beispiel haben wir die bereits bekannte Funktion c() verwendet, um zwei Listen in eine neue Liste einkauf_gesamt zu kombinieren. Das heißt: Wenn wir die Funktion c() verwenden, um zwei Listen zu kombinieren, dann kommt auch eine Liste dabei raus. Man kann mit der Funktion c() aber keine Listen aus einzelnen Werten erstellen: # Mit der Funktion c() kann man KEINE Liste erstellen einkauf_bananen &lt;- c(frucht=&quot;Banane&quot;, anzahl=0, vorraetig=FALSE) typeof(einkauf_bananen) #&gt; [1] &quot;character&quot; 2.4 Auf einen Blick: Vektoren vs benannte Vektoren vs Faktoren vs Listen In diesem Abschnitt werden die Unterschiede zwischen einfachen Vektoren, benannten Vektoren, Faktoren und Listen anhand eines Beispiels illustriert. Das Beispiel illustriert, wie Daten zu Wetterbedingungen für jeden Monat eines Jahres mithilfe der verschiedenen Datenstrukturen organisiert werden können. # Vektor: Ein einfacher Vektor, der die Wetterbedingungen für jeden Monat eines Jahres speichert. weather_conditions &lt;- c(&quot;sonnig&quot;, &quot;bewölkt&quot;, &quot;sonnig&quot;, &quot;regnerisch&quot;, &quot;bewölkt&quot;, &quot;sonnig&quot;, &quot;regnerisch&quot;, &quot;bewölkt&quot;, &quot;bewölkt&quot;, &quot;sonnig&quot;, &quot;bewölkt&quot;, &quot;regnerisch&quot;) avg_rainfall &lt;- c(50, 40, 45, 60, 55, 70, 80, 75, 70, 65, 55, 50) print(weather_conditions) #&gt; [1] &quot;sonnig&quot; &quot;bewölkt&quot; &quot;sonnig&quot; &quot;regnerisch&quot; &quot;bewölkt&quot; #&gt; [6] &quot;sonnig&quot; &quot;regnerisch&quot; &quot;bewölkt&quot; &quot;bewölkt&quot; &quot;sonnig&quot; #&gt; [11] &quot;bewölkt&quot; &quot;regnerisch&quot; print(avg_rainfall) #&gt; [1] 50 40 45 60 55 70 80 75 70 65 55 50 # Named Vector: Ein benannter Vektor, der die Wetterbedingungen für jeden Monat eines Jahres speichert und Monatsnamen als Namen für jedes Element verwendet. weather_conditions_named &lt;- c(Jan=&quot;sonnig&quot;, Feb=&quot;bewölkt&quot;, Mar=&quot;sonnig&quot;, Apr=&quot;regnerisch&quot;, Mai=&quot;bewölkt&quot;, Jun=&quot;sonnig&quot;, Jul=&quot;regnerisch&quot;, Aug=&quot;bewölkt&quot;, Sep=&quot;bewölkt&quot;, Okt=&quot;sonnig&quot;, Nov=&quot;bewölkt&quot;, Dez=&quot;regnerisch&quot;) print(weather_conditions_named) #&gt; Jan Feb Mar Apr Mai Jun #&gt; &quot;sonnig&quot; &quot;bewölkt&quot; &quot;sonnig&quot; &quot;regnerisch&quot; &quot;bewölkt&quot; &quot;sonnig&quot; #&gt; Jul Aug Sep Okt Nov Dez #&gt; &quot;regnerisch&quot; &quot;bewölkt&quot; &quot;bewölkt&quot; &quot;sonnig&quot; &quot;bewölkt&quot; &quot;regnerisch&quot; # Faktor: Häufigkeitsverteilung der Wetterbedingungen # Konvertieren des Vektors in einen Faktor mit benannten Ebenen weather_factor &lt;- factor(weather_conditions, levels=c(&quot;sonnig&quot;, &quot;bewölkt&quot;, &quot;regnerisch&quot;), ordered=TRUE) # Häufigkeitsverteilung der Wetterbedingungen weather_table &lt;- table(weather_factor) # Ergebnis anzeigen print(weather_table) #&gt; weather_factor #&gt; sonnig bewölkt regnerisch #&gt; 4 5 3 # Liste: Eine Liste, die Informationen über das Wetter für jeden Monat des Jahres enthält. # Jedes Element der Liste ist ein eigenes Objekt, in diesem Fall ein Vektor. weather_list &lt;- list(Condition=weather_conditions, Rainfall=avg_rainfall, Month=c(&quot;Januar&quot;, &quot;Februar&quot;, &quot;Maerz&quot;, &quot;April&quot;, &quot;Mai&quot;, &quot;Juni&quot;, &quot;Juli&quot;, &quot;August&quot;, &quot;September&quot;, &quot;Oktober&quot;, &quot;November&quot;, &quot;Dezember&quot;)) print(weather_list) #&gt; $Condition #&gt; [1] &quot;sonnig&quot; &quot;bewölkt&quot; &quot;sonnig&quot; &quot;regnerisch&quot; &quot;bewölkt&quot; #&gt; [6] &quot;sonnig&quot; &quot;regnerisch&quot; &quot;bewölkt&quot; &quot;bewölkt&quot; &quot;sonnig&quot; #&gt; [11] &quot;bewölkt&quot; &quot;regnerisch&quot; #&gt; #&gt; $Rainfall #&gt; [1] 50 40 45 60 55 70 80 75 70 65 55 50 #&gt; #&gt; $Month #&gt; [1] &quot;Januar&quot; &quot;Februar&quot; &quot;Maerz&quot; &quot;April&quot; &quot;Mai&quot; &quot;Juni&quot; #&gt; [7] &quot;Juli&quot; &quot;August&quot; &quot;September&quot; &quot;Oktober&quot; &quot;November&quot; &quot;Dezember&quot; # Andere Darstellungsform als Liste von Listen weather_list &lt;- list(Januar=list(50, &quot;sonnig&quot;), Februar=list(40, &quot;bewölkt&quot;), Maerz=list(45, &quot;sonnig&quot;), April=list(60, &quot;regnerisch&quot;), Mai=list(55, &quot;bewölkt&quot;), Juni=list(70, &quot;sonnig&quot;), Juli=list(80, &quot;regnerisch&quot;), August=list(75, &quot;bewölkt&quot;), September=list(70, &quot;bewölkt&quot;), Oktober=list(65, &quot;sonnig&quot;), November=list(55, &quot;bewölkt&quot;), Dezember=list(50, &quot;regnerisch&quot;) ) print(weather_list) #&gt; $Januar #&gt; $Januar[[1]] #&gt; [1] 50 #&gt; #&gt; $Januar[[2]] #&gt; [1] &quot;sonnig&quot; #&gt; #&gt; #&gt; $Februar #&gt; $Februar[[1]] #&gt; [1] 40 #&gt; #&gt; $Februar[[2]] #&gt; [1] &quot;bewölkt&quot; #&gt; #&gt; #&gt; $Maerz #&gt; $Maerz[[1]] #&gt; [1] 45 #&gt; #&gt; $Maerz[[2]] #&gt; [1] &quot;sonnig&quot; #&gt; #&gt; #&gt; $April #&gt; $April[[1]] #&gt; [1] 60 #&gt; #&gt; $April[[2]] #&gt; [1] &quot;regnerisch&quot; #&gt; #&gt; #&gt; $Mai #&gt; $Mai[[1]] #&gt; [1] 55 #&gt; #&gt; $Mai[[2]] #&gt; [1] &quot;bewölkt&quot; #&gt; #&gt; #&gt; $Juni #&gt; $Juni[[1]] #&gt; [1] 70 #&gt; #&gt; $Juni[[2]] #&gt; [1] &quot;sonnig&quot; #&gt; #&gt; #&gt; $Juli #&gt; $Juli[[1]] #&gt; [1] 80 #&gt; #&gt; $Juli[[2]] #&gt; [1] &quot;regnerisch&quot; #&gt; #&gt; #&gt; $August #&gt; $August[[1]] #&gt; [1] 75 #&gt; #&gt; $August[[2]] #&gt; [1] &quot;bewölkt&quot; #&gt; #&gt; #&gt; $September #&gt; $September[[1]] #&gt; [1] 70 #&gt; #&gt; $September[[2]] #&gt; [1] &quot;bewölkt&quot; #&gt; #&gt; #&gt; $Oktober #&gt; $Oktober[[1]] #&gt; [1] 65 #&gt; #&gt; $Oktober[[2]] #&gt; [1] &quot;sonnig&quot; #&gt; #&gt; #&gt; $November #&gt; $November[[1]] #&gt; [1] 55 #&gt; #&gt; $November[[2]] #&gt; [1] &quot;bewölkt&quot; #&gt; #&gt; #&gt; $Dezember #&gt; $Dezember[[1]] #&gt; [1] 50 #&gt; #&gt; $Dezember[[2]] #&gt; [1] &quot;regnerisch&quot; 2.5 Matrizen Eine Matrix ist in R im Grunde eine Kombination mehrerer Vektoren in Spalten und Zeilen. Formell ausgedrückt: In einer Matrix kann jede Spalte und jede Zeile als Vektor aufgefasst werden. Das heißt, dass jedes Element in einer Matrix denselben Datentyp hat, eben genau wie bei Vektoren. Wenn beispielsweise alle Elemente den Typ character haben, spricht man auch von einer character-Matrix. Zusätzlich haben Matrizen eine Dimension, die mithilfe der Funktion dim() abgefragt werden kann. Die Dimension einer Matrix ist die Anzahl ihrer Zeilen und Spalten. Die Matrix unten hat beispielsweise die Dimension 2x3: Sie hat zwei Zeilen und drei Spalten. 2.5.1 Matrizen erstellen Da Matrizen aus Vektoren bestehen, können Matrizen erstellt werden, indem mehrere Vektoren kombiniert werden, oder, indem ein einzelner Vektor in verschiedene Spalten aufgeteilt wird. Dabei wird bei der Erstellung der Matrix mithilfe dem Zusatz ncol festgelegt, in wie viele Spalten die Elemente des Vektors organisiert werden sollen. Wir betrachten zunächst ein ganz simples Beispiel: # Matrix aus einem einzigen Vektor erstellen mit der Funktion matrix() fruechte &lt;- matrix(c(&quot;Apfel&quot;, &quot;Orange&quot;, &quot;Banane&quot;, &quot;Kiwi&quot;, &quot;Birne&quot;, &quot;Erdbeere&quot;), ncol = 3) print(fruechte) #&gt; [,1] [,2] [,3] #&gt; [1,] &quot;Apfel&quot; &quot;Banane&quot; &quot;Birne&quot; #&gt; [2,] &quot;Orange&quot; &quot;Kiwi&quot; &quot;Erdbeere&quot; # Dimension einer Matrix ausgeben lassen dim(fruechte) # Dimension ist 2 x 3 #&gt; [1] 2 3 Die Matrix fruechte ist jedoch nicht sehr informativ. Häufig haben die Spalten und Zeilen einer Matrix eine Bedeutung, sodass es sinnvoll ist, die Zeilen und/oder Spalten zu benennen. Wenn die Matrix wie im Beispiel oben aus einem einzelnen Vektor erstellt wird, können direkt beim Erstellen der Matrix die Zeilen- und Spaltennamen angegeben werden. In unserem Beispiel macht es nicht so viel Sinn, auch den Zeilen eine Bedeutung zu geben. Deswegen verwenden wir in der Funktion list() innerhalb der Funktion matrix() hier den Wert NULL (siehe dazu den Abschnitt “Fehlende und ungültige Werte in Datenstrukturen”). Wenn Zeilennamen festgelegt werden sollen, kann NULL einfach durch einen Vektor mit den Zeilennamen ausgetauscht werden. Beachtet, dass es einen Unterschied macht, ob die Elemente der Liste einen Namen haben oder nicht: # Matrix erstellen und direkt Namen für die Spalten festlegen # Achtung: die Dimension ist jetzt 3 x 2 ! matrix(c(&quot;Apfel&quot;, &quot;Orange&quot;, &quot;Banane&quot;, &quot;Kiwi&quot;, &quot;Birne&quot;, &quot;Erdbeere&quot;), ncol = 2, dimnames = list(NULL, c(&quot;nicht_vorraetig&quot;, &quot;vorraetig&quot;))) #&gt; nicht_vorraetig vorraetig #&gt; [1,] &quot;Apfel&quot; &quot;Kiwi&quot; #&gt; [2,] &quot;Orange&quot; &quot;Birne&quot; #&gt; [3,] &quot;Banane&quot; &quot;Erdbeere&quot; # Matrix erstellen, Namen für einzelne Spalten festlegen, und Spalten insgesamt benennen matrix(c(&quot;Apfel&quot;, &quot;Orange&quot;, &quot;Banane&quot;, &quot;Kiwi&quot;, &quot;Birne&quot;, &quot;Erdbeere&quot;), ncol = 2, dimnames = list(NULL, &quot;Vorratsstatus&quot; = c(&quot;nicht_vorraetig&quot;, &quot;vorraetig&quot;))) #&gt; Vorratsstatus #&gt; nicht_vorraetig vorraetig #&gt; [1,] &quot;Apfel&quot; &quot;Kiwi&quot; #&gt; [2,] &quot;Orange&quot; &quot;Birne&quot; #&gt; [3,] &quot;Banane&quot; &quot;Erdbeere&quot; Wenn Matrizen aus mehreren Vektoren erstellt werden, sind die Spalten- bzw. Zeilennamen automatisch die Namen der Vektoren, aus denen die Matrix erstellt wurde. Um Matrizen aus bereits existierenden Vektoren zu erstellen, kann entweder die Funktion rbind() oder die Funktion cbind() verwendet werden. rbind() fügt die Vektoren als Zeilen, also übereinander, zusammen. cbind() fügt die Vektoren als Spalten, also nebeneinander, zusammen. # Matrix zeilenweise erstellen mit der Funktion rbind() nicht_vorraetig &lt;- c(&quot;Banane&quot;, &quot;Orange&quot;, &quot;Birne&quot;) vorraetig &lt;- c(&quot;Apfel&quot;, &quot;Erbeere&quot;, &quot;Kiwi&quot;) fruechte_einkauf &lt;- rbind(nicht_vorraetig, vorraetig) fruechte_einkauf #&gt; [,1] [,2] [,3] #&gt; nicht_vorraetig &quot;Banane&quot; &quot;Orange&quot; &quot;Birne&quot; #&gt; vorraetig &quot;Apfel&quot; &quot;Erbeere&quot; &quot;Kiwi&quot; # Matrix spaltenweise erstellen mit der Funktion cbind() nicht_vorraetig &lt;- c(&quot;Banane&quot;, &quot;Orange&quot;, &quot;Birne&quot;) vorraetig &lt;- c(&quot;Apfel&quot;, &quot;Erbeere&quot;, &quot;Kiwi&quot;) fruechte_einkauf &lt;- cbind(nicht_vorraetig, vorraetig) fruechte_einkauf #&gt; nicht_vorraetig vorraetig #&gt; [1,] &quot;Banane&quot; &quot;Apfel&quot; #&gt; [2,] &quot;Orange&quot; &quot;Erbeere&quot; #&gt; [3,] &quot;Birne&quot; &quot;Kiwi&quot; Matrizen können auch aus anderen bereits existierenden Matrizen erstellt werden. Hierzu könen ebenfalls die Funktionen rbind() und cbind() verwendet werden: # Matrizen zeilenweise kombinieren mat_3 &lt;- rbind(nicht_vorraetig, vorraetig) mat_3 #&gt; [,1] [,2] [,3] #&gt; nicht_vorraetig &quot;Banane&quot; &quot;Orange&quot; &quot;Birne&quot; #&gt; vorraetig &quot;Apfel&quot; &quot;Erbeere&quot; &quot;Kiwi&quot; # Matrizen spaltenweise kombinieren mat_4 &lt;- cbind(nicht_vorraetig, vorraetig) mat_4 #&gt; nicht_vorraetig vorraetig #&gt; [1,] &quot;Banane&quot; &quot;Apfel&quot; #&gt; [2,] &quot;Orange&quot; &quot;Erbeere&quot; #&gt; [3,] &quot;Birne&quot; &quot;Kiwi&quot; Matrizen können auch in Dataframes umgewandelt werden und umgekehrt. Das behandeln wir im Abschnitt “Dataframes”. 2.5.2 Operationen auf Matrizen Zugriff auf eine Zeile und Zeilen (um)benennen: # Zugriff auf Zeile 1 fruechte[1, ] #&gt; [1] &quot;Apfel&quot; &quot;Banane&quot; &quot;Birne&quot; # Zeilen nachträglich (um)benennen rownames(fruechte_einkauf) &lt;- c(&quot;kuehlschrank&quot;, &quot;vorratskammer&quot;, &quot;regal&quot;) fruechte_einkauf #&gt; nicht_vorraetig vorraetig #&gt; kuehlschrank &quot;Banane&quot; &quot;Apfel&quot; #&gt; vorratskammer &quot;Orange&quot; &quot;Erbeere&quot; #&gt; regal &quot;Birne&quot; &quot;Kiwi&quot; # Zugriff auf Zeile mit dem Namen &quot;kuehlschrank&quot; fruechte_einkauf[&quot;kuehlschrank&quot;, ] #&gt; nicht_vorraetig vorraetig #&gt; &quot;Banane&quot; &quot;Apfel&quot; Zugriff auf eine Spalte und Spalten (um)benennen: # Zugriff auf Spalte mit Index 1 fruechte[, 1] #&gt; [1] &quot;Apfel&quot; &quot;Orange&quot; # Zugriff auf Spalte mit dem Namen &quot;vorraetig&quot; fruechte_einkauf[, &quot;vorraetig&quot;] #&gt; kuehlschrank vorratskammer regal #&gt; &quot;Apfel&quot; &quot;Erbeere&quot; &quot;Kiwi&quot; # Spalten nachträglich (um)benennen colnames(fruechte_einkauf) &lt;- c(&quot;vorhanden&quot;, &quot;nicht_vorhanden&quot;) Zugriff auf ein Element: # Zugriff auf das Element in Zeile 1 und Spalte 2 fruechte[1, 2] #&gt; [1] &quot;Banane&quot; Bedingter Zugriff, hier Zugriff auf alle Elemente mit dem Wert “Banane”: # Zugriff auf alle Elemente mit dem Wert &quot;Banane&quot; fruechte[fruechte == &quot;Banane&quot;] #&gt; [1] &quot;Banane&quot; Da Matrizen aus Vektoren bestehen, können wie auf Vektoren auch auf Matrizen die bereits bekannten Operatoren angewendet werden. Dabei wird wieder der Mechanismus der Vektorisierung aktiviert: Wenn Operatoren auf Matrizen angewandt werden, wird die Operation automatisch elementweise auf jedes Element der Matrix angewandt: mat_1 &lt;- matrix(c(1, 1, 2, 2), ncol=2) mat_1 + 2 #&gt; [,1] [,2] #&gt; [1,] 3 4 #&gt; [2,] 3 4 # Das geht auch mit zwei Matrizen mat_2 &lt;- matrix(c(4, 4, 4, 4), ncol=2) mat_1 + mat_2 #&gt; [,1] [,2] #&gt; [1,] 5 6 #&gt; [2,] 5 6 Matrizen können auch kombiniert werden. Wir haben ja bereits beim Erstellen von Matrizen aus bereits existierenden Vektoren oder Matrizen die Funktionen rbind() und cbind() verwendet: # Matrizen zeilenweise kombinieren mat_3 &lt;- rbind(mat_1, mat_2) mat_3 #&gt; [,1] [,2] #&gt; [1,] 1 2 #&gt; [2,] 1 2 #&gt; [3,] 4 4 #&gt; [4,] 4 4 # Matrizen spaltenweise kombinieren mat_4 &lt;- cbind(mat_1, mat_2) mat_4 #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 2 4 4 #&gt; [2,] 1 2 4 4 Matrizen können aber nicht immer kombiniert werden. Eine Voraussetzung dafür, dass Matrizen kombiniert werden können, ist, dass sie dieselbe Anzahl von Zeilen und Spalten (also dieselbe Dimension) haben. Die beiden Matrizen mat_3 und mat_4 haben beispielsweise umgekehrte Dimensionen: mat_3 ist eine 4x2-Matrix, und mat_4 ist eine 2x4-Matrix. Wenn die beiden Matrizen kombiniert werden sollen, müssen sie erst in dieselbe Form gebracht werden. Das geht ganz einfach mithilfe der Funktion t(). Das t steht dabei für “Transponieren”. # Matrix mat_3 transponieren mat_3t &lt;- t(mat_3) # Matrix mat_4 und transponierte Matrix kombinieren: cbind(mat_3t, mat_4) #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #&gt; [1,] 1 1 4 4 1 2 4 4 #&gt; [2,] 2 2 4 4 1 2 4 4 Verständnisfragen: Welche Dimension hat die Matrix fruechte_einkauf? Welchen Datentyp haben die Elemente der Matrix fruechte_einkauf? Wie kann man eine Matrix mit fünf Spalten erstellen? 2.6 Arrays Ein Array ermöglicht, einfach gesagt, mehrere Matrizen von gleicher Größe in einer einzigen Datenstruktur zu “stapeln”, wobei jede Matrix eine eigene “Schicht” oder “Ebene” im Array bildet. Auch Arrays haben eine Dimension, allerdings ist damit in Bezug auf Arrays etwas anderes gemeint als in Bezug auf Matrizen. Während die Dimension einer Matrix die Anzahl ihrer Zeilen und Spalten beschreibt, hat der Dimensionsbegriff bei Arrays eine erweiterte Bedeutung. Bei einem Array bezieht sich die Dimension auf die Anzahl der “Richtungen” oder “Achsen”, in denen die Daten organisiert sind. Dies kann die Anzahl der Zeilen, Spalten, “Schichten” und weiterer Organisationsweisen in höherdimensionalen Arrays umfassen. Jede dieser “Richtungen” hat eine bestimmte Größe, das heißt eine festgelegte Anzahl von Elementen. Arrays werden mithilfe der Funktion array() erstellt: # Daten für das Array fruechte_daten &lt;- c( &quot;Apfel&quot;, &quot;Orange&quot;, &quot;Birne&quot;, &quot;Erbeere&quot;, &quot;Melone&quot;, &quot;Kiwi&quot;, &quot;Banane&quot;, &quot;Traube&quot;, &quot;Apfel&quot;, &quot;Papaya&quot;, &quot;Quitte&quot;, &quot;Mango&quot; ) # Erstellen eines 3D-Arrays mit 2 Zeilen, 3 Spalten und 2 &quot;Ebenen&quot; (jede Ebene ist eine separate Matrix) fruechte_array &lt;- array(fruechte_daten, dim = c(2, 3, 2)) # Ausgabe des Arrays print(fruechte_array) #&gt; , , 1 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] &quot;Apfel&quot; &quot;Birne&quot; &quot;Melone&quot; #&gt; [2,] &quot;Orange&quot; &quot;Erbeere&quot; &quot;Kiwi&quot; #&gt; #&gt; , , 2 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] &quot;Banane&quot; &quot;Apfel&quot; &quot;Quitte&quot; #&gt; [2,] &quot;Traube&quot; &quot;Papaya&quot; &quot;Mango&quot; Die Dimension des Arrays fruechte_array lässt sich an der Länge des Vektors dim=c(2, 3, 2) ablesen: Da der Vektor drei Elemente hat, handelt es sich um ein dreidimensionales Array. Das erste Element des Vektors dim legt fest, dass jede Matrix zwei Zeilen hat, das zweite Element legt fest, dass jede Matrix drei Spalten hat, und das dritte Element legt fest, dass es zwei Matrizen gibt. 2.6.1 Operationen auf Arrays Zugriff auf eine Matrix: # Zugriff auf die erste Matrix fruechte_array[,, 1] #&gt; [,1] [,2] [,3] #&gt; [1,] &quot;Apfel&quot; &quot;Birne&quot; &quot;Melone&quot; #&gt; [2,] &quot;Orange&quot; &quot;Erbeere&quot; &quot;Kiwi&quot; Zugriff auf eine Spalte einer Matrix: # Zugriff auf die zweite Spalte der ersten Matrix fruechte_array[, 2, 1] #&gt; [1] &quot;Birne&quot; &quot;Erbeere&quot; Zugriff auf ein Element: # Zugriff auf das Element in der ersten Zeile und zweiten Spalte der ersten Matrix fruechte_array[1, 2, 1] #&gt; [1] &quot;Birne&quot; Dimensionen benennen: dimnames(fruechte_array) &lt;- list( Vorratsstatus = c(&quot;vorraetig&quot;, &quot;nicht_vorraetig&quot;), Vorratsort = c(&quot;kuehlschrank&quot;, &quot;vorratskammer&quot;, &quot;regal&quot;), Haus = c(&quot;Wohnhaus&quot;, &quot;Ferienhaus&quot;) ) fruechte_array #&gt; , , Haus = Wohnhaus #&gt; #&gt; Vorratsort #&gt; Vorratsstatus kuehlschrank vorratskammer regal #&gt; vorraetig &quot;Apfel&quot; &quot;Birne&quot; &quot;Melone&quot; #&gt; nicht_vorraetig &quot;Orange&quot; &quot;Erbeere&quot; &quot;Kiwi&quot; #&gt; #&gt; , , Haus = Ferienhaus #&gt; #&gt; Vorratsort #&gt; Vorratsstatus kuehlschrank vorratskammer regal #&gt; vorraetig &quot;Banane&quot; &quot;Apfel&quot; &quot;Quitte&quot; #&gt; nicht_vorraetig &quot;Traube&quot; &quot;Papaya&quot; &quot;Mango&quot; 2.7 Dataframes Dataframes werden zur Darstellung tabellarischer Daten verwendet. Sie ähneln auf den ersten Blick Matrizen, jedoch können sie Elemente unterschiedlichen Typs beinhalten: Jede Spalte eines Dataframes ist ein Vektor, aber anders als bei Matrizen können die Zeilen nicht als Vektoren aufgefasst werden, da die Elemente in den verschiedenen Spalten unterschiedliche Datentypen haben können. Genauer gesagt ist ein Dataframe also eigentlich eine Art von Liste von Vektoren, bei der jedes Element, also jeder Vektor, dieselbe Länge haben muss: Eine Liste mit fünf Elementen vom Typ numeric könnte bespielsweise genausogut als Dataframe mit einer Zeile und fünf Spalten dargestellt werden. Eine Liste mit vier Elementen, wobei die Elemente Vektoren mit jeweils zwei Elementen sind, könnte als Dataframe mit zwei Zeilen und vier Spalten dargestellt werden. Anders als bei einer Liste hat in einem Dataframe aber nicht nur jede Spalte, sondern auch jede Zeile einen Index. Darauf kommen wir im Abschnitt “Operationen auf Dataframes” zurück. 2.7.1 Dataframes erstellen Weil die Spalten eines Dataframes Vektoren sind, kann man Dataframes “spaltenweise” aus Vektoren erstellen. Dazu erstellt man zunächst entweder einen Vektor für jede Spalte und kombiniert diese dann mithilfe der Funktion data.frame() in ein Dataframe-Objekt: # Dataframe aus Vektoren erstellen: Variante 1 fruechte &lt;- c(&quot;Apfel&quot;, &quot;Erdbeere&quot;, &quot;Banane&quot;) anzahl &lt;- c(20, 32, 0) vorraetig &lt;- c(TRUE, TRUE, FALSE) df &lt;- data.frame(fruechte, anzahl, vorraetig) print(df) #&gt; fruechte anzahl vorraetig #&gt; 1 Apfel 20 TRUE #&gt; 2 Erdbeere 32 TRUE #&gt; 3 Banane 0 FALSE # Dataframe aus Vektoren erstellen: Variante 2 fruechte_df &lt;- data.frame(frucht = c(&quot;Apfel&quot;, &quot;Erdbeere&quot;, &quot;Banane&quot;), anzahl = c(20, 32, 0), vorraetig = c(TRUE, TRUE, FALSE) ) print(fruechte_df) #&gt; frucht anzahl vorraetig #&gt; 1 Apfel 20 TRUE #&gt; 2 Erdbeere 32 TRUE #&gt; 3 Banane 0 FALSE Dataframes können aber auch aus Listen erstellt werden. Dabei wird zuerst eine Liste erstellt, bei der jedes Element ein Vektor ist und stellt die Liste anschließend mit der Funktion as.data.frame() als Dataframe dar: # Dataframe aus einer Liste erstellen liste_von_vektoren &lt;- list(frucht = c(&quot;Apfel&quot;, &quot;Erdbeere&quot;, &quot;Banane&quot;), anzahl = c(20, 32, 0), vorraetig = c(TRUE, TRUE, FALSE) ) fruechte_df &lt;- as.data.frame(liste_von_vektoren) print(fruechte_df) #&gt; frucht anzahl vorraetig #&gt; 1 Apfel 20 TRUE #&gt; 2 Erdbeere 32 TRUE #&gt; 3 Banane 0 FALSE Dataframes können auch aus Matrizen erstellt werden, zum Beispiel aus unserer Matrix fruechte_einkauf: # Dataframe aus Matrix erstellen fruechte_einkauf &lt;- matrix(c(&quot;Birne&quot;, &quot;Orange&quot;, &quot;Banane&quot;, &quot;Kiwi&quot;, &quot;Apfel&quot;, &quot;Erdbeere&quot;), ncol = 2, dimnames = list(NULL, c(&quot;nicht_vorraetig&quot;, &quot;vorraetig&quot;))) fruechte_df &lt;- as.data.frame(fruechte_einkauf) fruechte_df #&gt; nicht_vorraetig vorraetig #&gt; 1 Birne Kiwi #&gt; 2 Orange Apfel #&gt; 3 Banane Erdbeere Allerdings sind in diesem Fall noch einige Operationen notwendig, um zusätzliche Informationen hinzuzufügen und den Dataframe in die gewünschte Form zu bringen. In unserem Beispiel wäre es sinnvoll, die Früchte in einer Spalte aufzulisten und für den Vorratsstatus wie in den Beispielen zuvor eine eigene Spalte anzulegen: # Dataframe mithilfe der Funktion stack() umformen fruechte_df &lt;- stack(fruechte_df) fruechte_df #&gt; values ind #&gt; 1 Birne nicht_vorraetig #&gt; 2 Orange nicht_vorraetig #&gt; 3 Banane nicht_vorraetig #&gt; 4 Kiwi vorraetig #&gt; 5 Apfel vorraetig #&gt; 6 Erdbeere vorraetig # Elemente in Spalte ind in Booleans umwandeln fruechte_df$ind &lt;- fruechte_df$ind == &quot;vorraetig&quot; # Auf dieselbe Weise kann auch eine neue Spalte hinzugefügt werden # fruechte_df$vorraetig &lt;- fruechte_df$ind == &quot;vorraetig&quot; # Alternativ mit ifelse-Anweisung (--&gt; nächste Woche!) # fruechte_df$ind &lt;- ifelse(fruechte_df$ind == &quot;vorraetig&quot;, TRUE, FALSE) fruechte_df #&gt; values ind #&gt; 1 Birne FALSE #&gt; 2 Orange FALSE #&gt; 3 Banane FALSE #&gt; 4 Kiwi TRUE #&gt; 5 Apfel TRUE #&gt; 6 Erdbeere TRUE Der Dataframe ist immer noch nicht ideal. Zum Beispiel sind die Spaltennamen nicht besonders intuitiv und sollten lieber umbenannt werden, und es fehlt noch die Spalte anzahl mit der Anzahl der vorrätigen Früchte. Im folgenden Abschnitt werden Operationen zum Zugriff und zur Transformation von Dataframes vorgestellt, mit denen solche Umformungen umgesetzt werden können. 2.7.2 Operationen auf Dataframes Spalten umbenennen: # Option 1 colnames(fruechte_df) &lt;- c(&quot;frucht&quot;, &quot;vorraetig&quot;) # Option 2 fruechte_df$values &lt;- fruechte_df$frucht fruechte_df$ind &lt;- fruechte_df$vorraetig Spalte hinzufügen: fruechte_df$anzahl &lt;- c(0, 0, 0, 5, 20, 32) fruechte_df #&gt; frucht vorraetig anzahl #&gt; 1 Birne FALSE 0 #&gt; 2 Orange FALSE 0 #&gt; 3 Banane FALSE 0 #&gt; 4 Kiwi TRUE 5 #&gt; 5 Apfel TRUE 20 #&gt; 6 Erdbeere TRUE 32 Anordnung der Spalten ändern: fruechte_df &lt;- fruechte_df[c(&quot;frucht&quot;, &quot;anzahl&quot;, &quot;vorraetig&quot;)] fruechte_df #&gt; frucht anzahl vorraetig #&gt; 1 Birne 0 FALSE #&gt; 2 Orange 0 FALSE #&gt; 3 Banane 0 FALSE #&gt; 4 Kiwi 5 TRUE #&gt; 5 Apfel 20 TRUE #&gt; 6 Erdbeere 32 TRUE Zugriff auf eine Spalte über den Namen der Spalte: # Option 1 fruechte_df$frucht #&gt; [1] &quot;Birne&quot; &quot;Orange&quot; &quot;Banane&quot; &quot;Kiwi&quot; &quot;Apfel&quot; &quot;Erdbeere&quot; # Option 2 fruechte_df[[&quot;frucht&quot;]] #&gt; [1] &quot;Birne&quot; &quot;Orange&quot; &quot;Banane&quot; &quot;Kiwi&quot; &quot;Apfel&quot; &quot;Erdbeere&quot; Zugriff auf eine Spalte über den Spaltenindex: fruechte_df[, 1] #&gt; [1] &quot;Birne&quot; &quot;Orange&quot; &quot;Banane&quot; &quot;Kiwi&quot; &quot;Apfel&quot; &quot;Erdbeere&quot; Zugriff auf eine Zeile: fruechte_df[1, ] #&gt; frucht anzahl vorraetig #&gt; 1 Birne 0 FALSE Zugriff auf einzelne Elemente über den Spaltennamen und den Index der Zeile: # Zugriff auf Element in Spalte &quot;frucht&quot; und Zeile 3 fruechte_df$frucht[3] #&gt; [1] &quot;Banane&quot; # Zugriff auf Elemente in Spalte &quot;frucht&quot; und Zeilen 1 und 4 fruechte_df$frucht[c(1, 4)] #&gt; [1] &quot;Birne&quot; &quot;Kiwi&quot; # Zugriff auf Elemente in Spalte &quot;frucht&quot; und Zeilen 1 bis 4 fruechte_df$frucht[c(1:4)] #&gt; [1] &quot;Birne&quot; &quot;Orange&quot; &quot;Banane&quot; &quot;Kiwi&quot; Zugriff auf einzelne Elemente über den Spaltenindex und den Zeilenindex: # Zugriff auf das Element in Zeile 1 und Spalte 2 fruechte_df[1, 2] #&gt; [1] 0 Bedingter Zugriff auf Zeilen oder Elemente, die eine bestimmte Bedingung erfüllen: # Zugriff auf alle Zeilen, in denen in der Spalte anzahl der Wert 20 steht fruechte_df[fruechte_df$anzahl == 20, ] #&gt; frucht anzahl vorraetig #&gt; 5 Apfel 20 TRUE # Zugriff auf alle Elemente in der Spalte frucht, für die in der Spalte anzahl der Wert 20 steht fruechte_df$frucht[fruechte_df$anzahl == 20] #&gt; [1] &quot;Apfel&quot; # Zugriff auf alle Elemente in der Spalte frucht, für die in der Spalte anzahl ein Wert kleiner als 20 steht fruechte_df$frucht[fruechte_df$anzahl &lt; 20] #&gt; [1] &quot;Birne&quot; &quot;Orange&quot; &quot;Banane&quot; &quot;Kiwi&quot; Spalte entfernen: # hier auskommentiert, da wir die Spalte für unser Beispiel behalten wollen # fruechte_df$anzahl &lt;- NULL Zugriffsoperationen der Art fruechte_df$frucht[fruechte_df$anzahl == 20] und fruechte_df$frucht[fruechte_df$anzahl &lt; 20] sehen auf den ersten Blick unübersichtlich aus, aber hier passiert im Grunde genau dasselbe, was wir bereits vom bedingten Zugriff auf Vektoren kennen: Zunächst wird der Ausdruck in den eckigen Klammern ausgewertet. Da jede Spalte in einem Dataframe ein Vektor ist, wird dabei wieder der Mechanismus der Vektorisierung aktiviert und der Ausdruck wird zu einem logischen Vektor aus Wahrheitswerten evaluiert. In diesem Vektor steht TRUE, wenn ein Element in der Spalte fruechte_df$anzahl genau 20 bzw. kleiner als 20 ist, und FALSE sonst. Mit der Zugriffsoperation fruechte_df$frucht[] wird dann auf alle Elemente in der Spalte frucht zugegriffen, für die in der Spalte anzahl in derselben Zeile ein Wert genau 20 bzw. kleiner 20 steht. Da die Spalten eines Dataframes Vektoren sind, können auf die Spalten alle Operationen angewandt werden, die auch auf Vektoren angewandt werden können, zum Beispiel: fruechte_df$anzahl * 3 #&gt; [1] 0 0 0 15 60 96 Dataframes können auch kombiniert werden. Wir haben ja bereits beim Erstellen von Matrizen aus bereits existierenden Vektoren die Funktionen rbind() und cbind() verwendet. neue_fruechte &lt;- data.frame(frucht = c(&quot;Apfel&quot;, &quot;Zitrone&quot;, &quot;Mango&quot;), anzahl = c(20, 15, 0), vorraetig = c(TRUE, TRUE, FALSE) ) # Dataframes zeilenweise kombinieren rbind(fruechte_df, neue_fruechte) #&gt; frucht anzahl vorraetig #&gt; 1 Birne 0 FALSE #&gt; 2 Orange 0 FALSE #&gt; 3 Banane 0 FALSE #&gt; 4 Kiwi 5 TRUE #&gt; 5 Apfel 20 TRUE #&gt; 6 Erdbeere 32 TRUE #&gt; 7 Apfel 20 TRUE #&gt; 8 Zitrone 15 TRUE #&gt; 9 Mango 0 FALSE # Dataframes spaltenweise kombinieren cbind(fruechte_df, neue_fruechte) #&gt; frucht anzahl vorraetig frucht anzahl vorraetig #&gt; 1 Birne 0 FALSE Apfel 20 TRUE #&gt; 2 Orange 0 FALSE Zitrone 15 TRUE #&gt; 3 Banane 0 FALSE Mango 0 FALSE #&gt; 4 Kiwi 5 TRUE Apfel 20 TRUE #&gt; 5 Apfel 20 TRUE Zitrone 15 TRUE #&gt; 6 Erdbeere 32 TRUE Mango 0 FALSE Achtung: Beachtet, dass beim Zusammenfügen der beiden Dataframes Duplikate entstehen: In dem neuen Dataframe, der mit rbind() erstellt wurde, gibt es zweimal “Apfel”, obwohl sich alle Werte in der Zeile wiederholen. In dem neuen Dataframe, der mit cbind() erstellt wurde, wiederholen sich sogar die Spalten und alle Elemente im Dataframe df_2 werden noch einmal dupliziert. Das hat den Grund, dass cbind() nur Dataframes mit derselben Anzahl an Zeilen zusammenfügen kann. Um zwei Dataframes so zusammenzufügen, dass gleiche Zeilen nicht dupliziert werden und nur die neuen Zeilen und Spalten hinzugefügt werden, kann die Funktion merge() verwendet werden. # Dataframes kombinieren und dabei gleiche Spalten zusammenfügen neue_fruechte &lt;- data.frame(frucht = c(&quot;Apfel&quot;, &quot;Zitrone&quot;, &quot;Mango&quot;), anzahl = c(20, 15, 0), vorraetig = c(TRUE, TRUE, FALSE), preis = c(2.49, 1.49, .99) ) merge(fruechte_df, neue_fruechte, by=c(&quot;frucht&quot;,&quot;anzahl&quot;, &quot;vorraetig&quot;), all = TRUE) #&gt; frucht anzahl vorraetig preis #&gt; 1 Apfel 20 TRUE 2.49 #&gt; 2 Banane 0 FALSE NA #&gt; 3 Birne 0 FALSE NA #&gt; 4 Erdbeere 32 TRUE NA #&gt; 5 Kiwi 5 TRUE NA #&gt; 6 Mango 0 FALSE 0.99 #&gt; 7 Orange 0 FALSE NA #&gt; 8 Zitrone 15 TRUE 1.49 Im Laufe des Semesters werden wir einige weitere Möglichkeiten kennenlernen, wie Dataframes transformiert und kombiniert werden können. Verständnisfragen: Was gilt für alle Spalten eines Dataframes? Welchen Datentyp haben die Werte in der neuen Spalte vorraetig? Was passiert, wenn Werte beim Erstellen eines Dataframes fehlen? Löscht einen Wert und probiert es aus. Verwendet die Funktion View() um euch einen der Dataframes genauer anzusehen. Was passiert? 2.8 Auf einen Blick: Matrizen vs Arrays vs Dataframes In diesem Abschnitt werden die Unterschiede zwischen Matrizen, Arrays und Dataframes anhand eines Beispiels illustriert. Das Beispiel illustriert, wie Daten zu Temperaturmessungen in drei verschiedenen Städten an drei Tageszeiten mithilfe der verschiedenen Datenstrukturen organisiert werden können. # Array: Ein dreidimensionales Modell zur Speicherung von Temperaturdaten über eine Woche, gemessen zu verschiedenen Tageszeiten in verschiedenen Städten. # Ein 3x7x3 Array erstellen für 3 Städte, 7 Tage und 3 Tageszeiten temperature_array &lt;- array(sample(10:30, 63, replace = TRUE), dim = c(3, 7, 3)) dimnames(temperature_array) &lt;- list( Stadt = c(&quot;Berlin&quot;, &quot;Hamburg&quot;, &quot;München&quot;), Tag = c(&quot;Mo&quot;, &quot;Di&quot;, &quot;Mi&quot;, &quot;Do&quot;, &quot;Fr&quot;, &quot;Sa&quot;, &quot;So&quot;), Zeit = c(&quot;Morgen&quot;, &quot;Mittag&quot;, &quot;Abend&quot;) ) print(temperature_array[,&quot;Mo&quot;, &quot;Morgen&quot;]) #&gt; Berlin Hamburg München #&gt; 14 18 27 print(temperature_array) #&gt; , , Zeit = Morgen #&gt; #&gt; Tag #&gt; Stadt Mo Di Mi Do Fr Sa So #&gt; Berlin 14 29 30 27 23 24 19 #&gt; Hamburg 18 24 22 20 28 22 16 #&gt; München 27 21 19 17 13 28 24 #&gt; #&gt; , , Zeit = Mittag #&gt; #&gt; Tag #&gt; Stadt Mo Di Mi Do Fr Sa So #&gt; Berlin 11 30 29 30 14 25 23 #&gt; Hamburg 19 12 20 20 18 24 30 #&gt; München 13 19 27 20 12 18 17 #&gt; #&gt; , , Zeit = Abend #&gt; #&gt; Tag #&gt; Stadt Mo Di Mi Do Fr Sa So #&gt; Berlin 30 15 18 21 15 19 24 #&gt; Hamburg 30 18 15 29 18 11 10 #&gt; München 25 10 21 25 11 11 12 # Matrix: Die Temperaturmessungen für alle Städte über eine Woche zu einer bestimmten Tageszeit. morning_temp_matrix &lt;- matrix(temperature_array[ , , &quot;Morgen&quot;], nrow = 7) rownames(morning_temp_matrix) &lt;- c(&quot;Mo&quot;, &quot;Di&quot;, &quot;Mi&quot;, &quot;Do&quot;, &quot;Fr&quot;, &quot;Sa&quot;, &quot;So&quot;) colnames(morning_temp_matrix) &lt;- c(&quot;Berlin&quot;, &quot;Hamburg&quot;, &quot;München&quot;) print(morning_temp_matrix) #&gt; Berlin Hamburg München #&gt; Mo 14 22 13 #&gt; Di 18 19 24 #&gt; Mi 27 27 22 #&gt; Do 29 20 28 #&gt; Fr 24 17 19 #&gt; Sa 21 23 16 #&gt; So 30 28 24 # Dataframe: Die Temperaturmessungen für alle Städte über eine Woche zu einer bestimmten Tageszeit. morning_temp_dataframe &lt;- data.frame( Berlin = temperature_array[&quot;Berlin&quot;, , &quot;Morgen&quot;], Hamburg = temperature_array[&quot;Hamburg&quot;, , &quot;Morgen&quot;], München = temperature_array[&quot;München&quot;, , &quot;Morgen&quot;] ) print(morning_temp_dataframe) #&gt; Berlin Hamburg München #&gt; Mo 14 18 27 #&gt; Di 29 24 21 #&gt; Mi 30 22 19 #&gt; Do 27 20 17 #&gt; Fr 23 28 13 #&gt; Sa 24 22 28 #&gt; So 19 16 24 # Der Dataframe sieht auf den ersten Blick genauso aus wie die Matrix. # Ein Dataframe kann aber zusätzliche Metadaten und Werte eines anderen Datentyps enthalten: morning_temp_dataframe$Zeit &lt;- &quot;Morgen&quot; morning_temp_dataframe$Skala &lt;- &quot;Celsius&quot; print(morning_temp_dataframe) #&gt; Berlin Hamburg München Zeit Skala #&gt; Mo 14 18 27 Morgen Celsius #&gt; Di 29 24 21 Morgen Celsius #&gt; Mi 30 22 19 Morgen Celsius #&gt; Do 27 20 17 Morgen Celsius #&gt; Fr 23 28 13 Morgen Celsius #&gt; Sa 24 22 28 Morgen Celsius #&gt; So 19 16 24 Morgen Celsius # Wenn wir dasselbe mit der Matrix versuchen, bekommen wir dagegen eine Warnmeldung, und einen wenig sinnvollen Output: morning_temp_matrix$Zeit &lt;- &quot;Morgen&quot; #&gt; Warning in morning_temp_matrix$Zeit &lt;- &quot;Morgen&quot;: Coercing LHS to a list # Auf die Werte in einem Dataframe können auch komplexere Operationen angewandt werden, und die Ergebnisse der Opterationen kann direkt im Dataframe gespeichert werden. # Wir können zum Beispiel das Maximum für jeden Tag berechenen und eine neue Spalte &quot;Maximum&quot; für diesen Wert übertragen morning_temp_dataframe$Maximum &lt;- pmax(morning_temp_dataframe$Berlin, morning_temp_dataframe$Hamburg, morning_temp_dataframe$München) morning_temp_dataframe #&gt; Berlin Hamburg München Zeit Skala Maximum #&gt; Mo 14 18 27 Morgen Celsius 27 #&gt; Di 29 24 21 Morgen Celsius 29 #&gt; Mi 30 22 19 Morgen Celsius 30 #&gt; Do 27 20 17 Morgen Celsius 27 #&gt; Fr 23 28 13 Morgen Celsius 28 #&gt; Sa 24 22 28 Morgen Celsius 28 #&gt; So 19 16 24 Morgen Celsius 24 # Wir könnten auch die Werte in Fahrenheit umwandeln morning_temp_dataframe$Maximum &lt;- morning_temp_dataframe$Maximum * 9/5 + 32 morning_temp_dataframe #&gt; Berlin Hamburg München Zeit Skala Maximum #&gt; Mo 14 18 27 Morgen Celsius 80.6 #&gt; Di 29 24 21 Morgen Celsius 84.2 #&gt; Mi 30 22 19 Morgen Celsius 86.0 #&gt; Do 27 20 17 Morgen Celsius 80.6 #&gt; Fr 23 28 13 Morgen Celsius 82.4 #&gt; Sa 24 22 28 Morgen Celsius 82.4 #&gt; So 19 16 24 Morgen Celsius 75.2 #... und anschließend die Spalte umbenennen morning_temp_dataframe$Maximum_Fahrenheit &lt;- morning_temp_dataframe$Maximum morning_temp_dataframe$Maximum &lt;- NULL # entfernt die ursprüngliche &quot;Maximum&quot; Spalte morning_temp_dataframe #&gt; Berlin Hamburg München Zeit Skala Maximum_Fahrenheit #&gt; Mo 14 18 27 Morgen Celsius 80.6 #&gt; Di 29 24 21 Morgen Celsius 84.2 #&gt; Mi 30 22 19 Morgen Celsius 86.0 #&gt; Do 27 20 17 Morgen Celsius 80.6 #&gt; Fr 23 28 13 Morgen Celsius 82.4 #&gt; Sa 24 22 28 Morgen Celsius 82.4 #&gt; So 19 16 24 Morgen Celsius 75.2 # Zur Datenmanipulation werden wir deswegen meist mit Dataframes zu tun haben. 2.9 Datenstrukturen untersuchen Jetzt haben wir schon ganz schön viele verschiedene Datenstrukturen kennengelernt, da kommt man leicht durcheinander. Letzte Woche haben wir bereits die typeof()-Funktion kennengelernt, um den Datentyp eines Werts herauszufinden. Wenn die Funktion typeof() auf Datenstrukturen angewandt wird, gibt die Funktion Auskunft darüber, wie die Datenstruktur im Speicher abgebildet wird. Ein Dataframe wird im Speicher zum Beispiel immer als Liste repräsentiert: typeof(morning_temp_dataframe) #&gt; [1] &quot;list&quot; Aber wir haben bereits gesehen, dass sich ein Dataframe von einer einfachen Liste unterscheidet. Die Spalten in einem Dataframe müssen immer dieselbe Länge haben und auf Dataframes können andere Funktionen angewandt werden als auf Listen. Um Informationen über die Datenstruktur eines Objekts auf höherer Ebene zu erhalten, kann die Funktion class() verwendet werden: class(morning_temp_dataframe) #&gt; [1] &quot;data.frame&quot; Neben typeof() und class() gibt es noch eine dritte Funktion, mit der die Datenstruktur eines Objekts untersucht werden kann. Die Funktion str() gibt Auskunft über die interne Struktur des Objekts: str(morning_temp_dataframe) #&gt; &#39;data.frame&#39;: 7 obs. of 6 variables: #&gt; $ Berlin : int 14 29 30 27 23 24 19 #&gt; $ Hamburg : int 18 24 22 20 28 22 16 #&gt; $ München : int 27 21 19 17 13 28 24 #&gt; $ Zeit : chr &quot;Morgen&quot; &quot;Morgen&quot; &quot;Morgen&quot; &quot;Morgen&quot; ... #&gt; $ Skala : chr &quot;Celsius&quot; &quot;Celsius&quot; &quot;Celsius&quot; &quot;Celsius&quot; ... #&gt; $ Maximum_Fahrenheit: num 80.6 84.2 86 80.6 82.4 82.4 75.2 Die Funktion typeof() kann natürlich auch auf einzelne Elemente in einer Datenstruktur angewandt werden: # Jedes Element hat in einer Matrix hat den Datentyp character typeof(fruechte_einkauf[1, 1]) # character #&gt; [1] &quot;character&quot; # Jede Spalte in einem Dataframe ist ein Vektor typeof(morning_temp_dataframe[3, ]) #&gt; [1] &quot;list&quot; # Jede Zeile in einem Dataframe ist eine Liste typeof(morning_temp_dataframe[, 3]) #&gt; [1] &quot;integer&quot; Zuletzt gibt es eine Reihe hilfreicher Funktionen, mit denen Datenstrukturen auf bestimmte Aspekte hin untersucht werden können. length() liefert die Anzahl der Elemente in einer Datenstruktur; nchar() gibt die Anzahl der Zeichen in einer Zeichenkette aus. ncol() und nrow() geben Auskunft über die Anzahl an Spalten und Zeilen in einer Datenstruktur und die bereits bekannte Funktion dim() liefert die Dimension. Für Datenstrukturen mit numerischen Werten kann zusätzlich auch das Minimum, das Maximum oder statistische Maße wie der Median oder das arithmetische Mittel bestimmt werden, und zwar mit den Funktionen min(), max(), median(), mean(). Verständnisfragen: Untersucht die Datenstrukturen aus diesem Kapitel mithilfe der Funktionen typeof(), class(), length(), nchar(), ncol(), nrow() und dim(). Was für ein Wert wird ausgegeben, wenn length() auf einen Dataframe angewendet wird? Wie hängen ncol(), nrow() und dim() zusammen? Haben Dataframes auch eine Dimension? Ruft mit ?dim die Dokumentation zur Funktion dim() auf und lest es nach. 2.10 Fehlende und ungültige Werte in Datenstrukturen Bei der Arbeit mit Daten in R kommt es immer mal vor, dass Werte fehlen oder ungültig sind. In R gibt es spezielle Objekte, die in diesem Fall eingesetzt werden. Der Wert NULL wird eingesetzt, um die Nicht-Existenz von Daten zu signalisieren. Das haben wir gesehen, als wir mithilfe der Funktion c() einen leeren Vektor erstellt haben. NULL wird außerdem dazu verwendet, um Werte aus Listen oder Dataframes zu entfernen. Wir haben dieses Objekt beispielsweise verwendet, um die Spalte Maximum aus dem Dataframe morning_temp_dataframe zu entfernen. Daneben gibt es NA, was für Not Available oder “nicht verfügbar” steht und verwendet wird, um das Fehlen von erwarteten Werten in Datenstrukturen zu markieren. Dieser Wert kommt typischerweise in Dataframes zur Anwendung, wenn zu einigen Beobachtungen bestimmte Werte fehlen, zum Beispiel das Alter einer Person in einem Dataframe, der Daten zu verschiedenen Personen enthält. Zuletzt gibt es den Wert NaN, welcher für Not a Number oder “keine Zahl” steht und signalisiert, dass das Ergebnis einer Berechnung eine undefinierte Zahl ist oder eine Zahl, die nicht repräsentiert werden kann. Ein Beispiel ist das Ergebnis der Operation 0/0. 2.11 Der Mitgliedschaftsoperator %in% Am Anfang haben wir Datenstrukturen als strukturierte Sammlungen von Werten (oder anderen Objekten) definiert. Um schnell herauszufinden, ob sich ein Wert in einer Datenstruktur befindet, kann ein spezieller Operator verwendet werden: der sogenannte Migliedschaftsoperator %in%. Dieser Operator wird auf Vektoren angewendet: Entweder auf einzelne Vektoren oder auf Vektoren innerhalb einer anderen Datenstruktur, also zum Beispiel auf die Spalten eines Dataframes oder Listenelemente, die Vektoren sind. Ein paar Beispiele: buchstaben &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;f&quot;, &quot;s&quot;, &quot;g&quot;) &quot;a&quot; %in% buchstaben #&gt; [1] TRUE # Es kann auch direkt nach der Mitgliedschaft mehrerer Elemente gefragt werden: c(&quot;a&quot;, &quot;f&quot;, &quot;b&quot;) %in% buchstaben #&gt; [1] TRUE TRUE TRUE # Mitgliedschaftsoperator auf Elemente einer Liste anwenden obstpreise &lt;- list(obst=c(&quot;Apfel&quot;, &quot;Banane&quot;, &quot;Orange&quot;), preise=c(2.45, 2.99, 1.99)) &quot;Orange&quot; %in% obstpreise$obst #&gt; [1] TRUE 2.12 Unveränderbarkeit von Objekten in R Wir haben in der vergangenen Woche besprochen, dass bei der Zuweisung einer Variable ein Wert zugeordnet wird, indem ein Name festgelegt wird, der fortan für diesen Wert und für den Speicherplatz, in dem er gespeichert ist, steht. Der Name ist also sowas wie eine Referenz zu diesem Wert. Aber was passiert eigentlich, wenn der Wert im Programmverlauf verändert wird? Dieser Frage gehen wir an einem Beispiel nach. Wir weisen zunächst einer Variable x einen Vektor c(1, 2, 3) als Wert zu: x &lt;- c(1, 2, 3) Die folgende Grafik aus dem Buch “Advanced R” von Hadley Wickham illustriert, was bei der Zuweisungsoperation passiert: Figure 2.2: Hadley Wickham (2019), https://adv-r.hadley.nz/names-values.html#binding-basics Der Name x referenziert also nach der Zuweisung einen Vektor mit den Elementen 1, 2 und 3. Die graue Zahl 0x74b steht für die Adresse des Speicherplatzes, der im Computer für das Objekt (den Vektor) “reserviert” ist. Wenn die Variable x einer neuen Variable y zugewiesen wird, dann referenziert auch der Name y denselben Wert, es entsteht zunächst also keine Kopie des Werts c(1, 2, 3): y &lt;- x Figure 2.3: Hadley Wickham (2019), https://adv-r.hadley.nz/names-values.html#binding-basics Aber was passiert mit der Variable x, wenn die Variable y verändert wird? Oder, korrekter formuliert: Welchen Wert referenziert x, wenn mithilfe von y auf den der Wert c(1, 2, 3) zugegriffen und ein Element verändert wird? x &lt;- c(1, 2, 3) y &lt;- x y[3] &lt;- 4 x #&gt; [1] 1 2 3 y wird zwar verändert, aber x nicht! Der Wert, der mit y verknüpft ist, wurde verändert, aber das ursprüngliche Objekt nicht. Stattdessen wurde ein neues Objekt erstellt, das eine Kopie des ursprünglichen Objekts mit dem veränderten Wert ist. Figure 2.4: Hadley Wickham (2019), https://adv-r.hadley.nz/names-values.html#binding-basics Dieses Verhalten liegt daran, dass R Objekte unveränderbar, oder auf Englisch immutable sind. Das bedeutet: Wenn wir in R den Wert einer Variable ändern wollen, z.B. x &lt;- x + 1, dann wird tatsächlich ein neues Objekt erstellt und x wird nun auf den neuen Speicherplatz, der den neuen Wert enthält, verwiesen. Der alte Speicherplatz wird freigegeben, wenn keine andere Variable darauf verweist. Bei der Manipulation von Objekten sollte man also dieses Prinzip der Unveränderbarkeit (Immutability) im Hinterkopf behalten, denn hier unterscheidet sich R von anderen Programmiersprachen wie beispielsweise Python. Diese Beispiele und alle Erklärungen auf Englisch könnt ihr auch nochmal im Kapitel “Binding basics” in Wickhams Lehrbuch “Advanced R” nachlesen. An diesem Punkt sollt ihr aber hauptsächlich das Prinzip der Unveränderbarkeit mal gehört haben; es ist nicht schlimm, wenn ihr den Vorgang nicht im Detail versteht. Quellen Venables, W.N. and Smith, D.M. and the R Core Team (2023). An Introduction to R, https://cran.r-project.org/doc/manuals/r-release/R-intro.pdf Wickham, Hadley. The Tidyverse Style Guide, https://style.tidyverse.org/ Wickham, Hadley (2019). Advanced R. Chapter 4: Subsetting, https://adv-r.hadley.nz/subsetting.html Wickham, Hadley (2019). Advanced R. Chapter 2: Names and Values, https://adv-r.hadley.nz/names-values.html Phillips, Nathaniel D. (2018). Matrices and Dataframes, https://bookdown.org/ndphillips/YaRrr/matricesdataframes.html Phillips, Nathaniel D. (2018). Advanced Dataframe Manipulation, https://bookdown.org/ndphillips/YaRrr/advanceddataframe.html "],["r-basics-iii-kontrollstrukturen.html", "3 R Basics III: Kontrollstrukturen 3.1 Grundlegende Begriffe 3.2 Bedingte Anweisungen 3.3 Verzweigungen 3.4 while-Schleifen 3.5 for-Schleifen 3.6 Schleifen abbrechen Quellen", " 3 R Basics III: Kontrollstrukturen Bisher haben wir in unseren Beispielen immer einzelne Anweisungen oder Ausdrücke (-&gt; Grundbegriffe!) betrachtet. Wir haben dabei gelernt, dass der Computer Code ausführen und auswerten kann: Beim Ausführen “macht” er etwas und ändert den Zustand des Speichers, zum Beispiel, wenn eine neue Variable erstellt wird. Beim Auswerten berechnet er etwas und liefert einen Wert, zum Beispiel, wenn eine logische Aussage überprüft wird. Der Computer kann Anweisungen aber auch wiederholen oder Anweisungen nur dann ausführen, wenn eine bestimmte Bedingung erfüllt ist. In R gibt es eine Reihe von Signalwörtern, die dem Computer mitteilen, dass eine bestimmte Abfolge von Anweisungen (=Anweisungsblock) wiederholt werden soll oder nur unter einer bestimmten Bedingung ausgeführt werden soll. 3.1 Grundlegende Begriffe Begriff Englische Entsprechung Definition (im R-Kontext) Anweisungsblock Code block Mehrere aufeinanderfolgende Codezeilen, zum Beispiel im Körper einer Schleife oder einer bedingten Anweisung. Iteration Iteration Im Kontext von Kontrollstrukturen bezeichnet Iteration zwei Dinge: in einem allgemeinen Sinn den Prozess, bei dem Anweisungen wiederholt ausgeführt werden, und zum anderen einen einzigen Schleifendurchlauf, also das einmalige Ausführen der Anweisungen im Schleifenkörper. Wenn der Code einmal ausgeführt wird, sagt man entsprechend ‘eine Iteration’, für das zweimalige Ausführen ‘zwei Iterationen’, usw. Iterieren Iterate Wenn beschrieben werden soll, dass eine for-Schleife ein Objekt durchläuft, wird dazu häufig gesagt, dass die Schleife ‘über das Objekt iteriert’. Terminieren Terminate Wenn eine Schleife terminiert bedeutet das, dass sie die Ausführung beendet; sie kommt zum Ende. Style Tip In Funktionsaufrufen, also z.B. print(), und in Zugriffsoperationen, also z.B. var[], steht bekanntlich kein Leerzeichen vor der Klammer. Bei Kontrollstrukturen ist das anders. Hier empfiehlt Wickham, nach den Signalwörtern if, if else, for und while stets ein Leerzeichen einzufügen, also z.B. if (var == 20). 3.2 Bedingte Anweisungen Bedingte Anweisungen, oder if-Anweisungen, haben die allgemeine Form: if (Bedingung) { Anweisungsblock } if (Bedingung) { Anweisungsblock if (Bedingung) { Anweisungsblock } } Beispiel: # Nachricht wird ausgegeben, wenn der Vektor autos ein Element mit dem Wert &quot;Mercedes&quot; enthält autos &lt;- c(&quot;Mercedes&quot;, &quot;Fiat&quot;, &quot;Volvo&quot;, &quot;BMW&quot;) if (&quot;Mercedes&quot; %in% autos) { print(&quot;Ein Mercedes steht in der Garage!&quot;) } ## [1] &quot;Ein Mercedes steht in der Garage!&quot; # Nachricht wird ausgegeben, wenn der Wert, der dem Schlüssel &quot;Mercedes&quot; im Vektor autos zugeordnet ist, größer als 1 ist autos &lt;- c(Mercedes=2, Fiat=1, Volvo=1, BMW=3) anzahl_mercedes &lt;- autos[&quot;Mercedes&quot;] if (anzahl_mercedes &gt; 1) { print(paste(&quot;Du hast&quot;, anzahl_mercedes, &quot;Mercedes!&quot;)) } ## [1] &quot;Du hast 2 Mercedes!&quot; Mit der Funktion paste() können character verkettet werden. Dabei werden automatisch Leerzeichen zwischen den zu verkettenden charactern eingefügt. Wenn character ohne Leerzeichen verkettet werden sollen, kann stattdessen die Funktion paste0() verwendet werden. # Wenn der Vektor autos einen Schlüssel &quot;Mercedes&quot; enthält, wird überprüft, ob der Wert, der diesem Schlüssel zugeordnet ist, größer als 1 ist. # Falls ja, wird eine Nachricht ausgegeben. autos &lt;- c(Mercedes=2, Fiat=1, Volvo=1, BMW=3) if (&quot;Mercedes&quot; %in% names(autos)) { anzahl_mercedes &lt;- autos[&quot;Mercedes&quot;] if (anzahl_mercedes &gt; 1) { print(paste(&quot;Du hast&quot;, anzahl_mercedes, &quot;Mercedes!&quot;)) } } ## [1] &quot;Du hast 2 Mercedes!&quot; Verständnisfragen: Welche Datenstruktur hat das Objekt autos im zweiten und dritten Beispiel? Wie müsste man den Code im ersten Beispiel ändern, sodass eine Nachricht ausgegeben wird, wenn sowohl ein Mercedes als auch ein Fiat in der Garage stehen? Bedingungen können auch kombiniert werden. Dazu werden einfach zwei logische Ausdrücke mithilfe der logischen Operatoren &amp;&amp; und || verknüpft: # Beide Ausdrücke sind wahr: die Nachricht wird ausgegeben autos &lt;- c(&quot;Mercedes&quot;, &quot;Fiat&quot;, &quot;Volvo&quot;, &quot;BMW&quot;) if (&quot;Mercedes&quot; %in% autos &amp;&amp; &quot;Fiat&quot; %in% autos) { print(&quot;Ein Mercedes und ein Fiat stehen in der Garage!&quot;) } ## [1] &quot;Ein Mercedes und ein Fiat stehen in der Garage!&quot; # Einer der Ausdrücke ist falsch: es passiert nichts autos &lt;- c(&quot;Mercedes&quot;, &quot;Fiat&quot;, &quot;Volvo&quot;, &quot;BMW&quot;) if (&quot;Mercedes&quot; %in% autos &amp;&amp; &quot;Opel&quot; %in% autos) { print(&quot;Ein Mercedes und ein Opel stehen in der Garage!&quot;) } # Einer der Ausdrücke ist falsch: die Nachricht wird ausgegeben autos &lt;- c(&quot;Mercedes&quot;, &quot;Fiat&quot;, &quot;Volvo&quot;, &quot;BMW&quot;) if (&quot;Mercedes&quot; %in% autos || &quot;Opel&quot; %in% autos) { print(&quot;Ein Mercedes oder ein Opel steht in der Garage!&quot;) } ## [1] &quot;Ein Mercedes oder ein Opel steht in der Garage!&quot; 3.3 Verzweigungen Es wird unterschieden zwischen einfachen und mehrfachen Verzweigungen. Einfache Verzweigungen, oder if-else-Anweisungen, haben die allgemeine Form: if (Bedingung) { Anweisungsblock } else { Anweisungsblock } Beispiel: # Wenn der Wert, der dem Schlüssel &quot;Ibuprofen&quot; zugeordnet ist, größer 0 ist, wird eine Nachricht ausgegeben. # Wenn der Wert 0 (oder im theoretischen Fall kleiner 0) ist, wird eine Warnung ausgegeben. medikamente &lt;- c(Ibuprofen=30, Paracetamol=23, Aspirin=28) anzahl_ibus &lt;- medikamente[&quot;Ibuprofen&quot;] if (anzahl_ibus &gt; 0) { print(paste(&quot;Du hast&quot;, anzahl_ibus, &quot;Ibuprofen!&quot;)) } else { print(&quot;Warnung: kein Ibuprofen mehr da!&quot;) } ## [1] &quot;Du hast 30 Ibuprofen!&quot; Wenn mehr als zwei Fälle überprüft werden sollen, kann eine if-else-Anweisung mit beliebig vielen zusätzlichen bedingten Anweisungen kombiniert werden. Mehrfache Verzweigungen haben die allgemeine Form: if (Bedingung) { Anweisungsblock } else if (Bedingung) { Anweisungsblock } else { Anweisungsblock } # Wenn der Wert, der dem Schlüssel &quot;Ibuprofen&quot; zugeordnet ist, größer als 5 ist, wird eine Nachricht mit dem Wert ausgegeben. # Wenn der Wert genau dem Integer 5 entspricht, wird eine Warnung ausgegeben. # In allen anderen Fällen wird die Nachricht &quot;Achtung! Weniger als 5 Ibuprofen da!&quot; ausgegeben. medikamente &lt;- c(Ibuprofen=30, Paracetamol=23, Aspirin=28) anzahl_ibus &lt;- medikamente[&quot;Ibuprofen&quot;] if (anzahl_ibus &gt; 5) { print(paste(&quot;Du hast&quot;, anzahl_ibus, &quot;Ibuprofen!&quot;)) } else if (anzahl_ibus == 5) { print(&quot;Warnung: Nur noch 5 Ibuprofen da!&quot;) } else { print(&quot;Achtung! Weniger als 5 Ibuprofen da!&quot;) } ## [1] &quot;Du hast 30 Ibuprofen!&quot; Verständnisfragen: Wann wird der Anweisungsblock nach else ausgeführt? Welche Bedingung muss erfüllt sein? Achtung: Wenn zwei Bedingungen in einer Verzweigung zugleich erfüllt sind, wird nur die bedingte Anweisung ausgeführt, die zuerst überprüft wurde, die also “weiter oben” im Skript steht. Zur Illustration schauen wir uns nochmal unser Auto-Beispiel an. # Sowohl die if-Bedingung als auch die if else-Bedingung werden zu True evaluiert. # Allerdings wird die if else-Bedingung nie ausgewertet. # Es wird also nur die if-Anweisung ausgeführt. autos &lt;- c(&quot;Mercedes&quot;, &quot;Fiat&quot;, &quot;Volvo&quot;, &quot;BMW&quot;) if (&quot;Mercedes&quot; %in% autos) { print(&quot;Ein Mercedes steht in der Garage!&quot;) } else if (&quot;Fiat&quot; %in% autos) { print(&quot;Ein Fiat steht in der Garage!&quot;) } else { print(&quot;Weder ein Mercedes noch ein Fiat in der Garage.&quot;) } ## [1] &quot;Ein Mercedes steht in der Garage!&quot; Dieses Verhalten gilt allerdings nur für Verzweigungen, nicht jedoch für zwei if-Anweisungen, die aufeinander folgen: # Beide if-Bedingungen werden nacheinander ausgewertet. Im ersten Schleifendurchlauf # werden beide zu True evaluiert und es werden beide Anweisungen ausgeführt. autos &lt;- c(&quot;Mercedes&quot;, &quot;Fiat&quot;, &quot;Volvo&quot;, &quot;BMW&quot;) if (&quot;Mercedes&quot; %in% autos) { print(&quot;Ein Mercedes steht in der Garage!&quot;) } ## [1] &quot;Ein Mercedes steht in der Garage!&quot; if (&quot;Fiat&quot; %in% autos) { print(&quot;Ein Fiat steht in der Garage!&quot;) } ## [1] &quot;Ein Fiat steht in der Garage!&quot; Eine spezielle Form von Verzweigung sind bedingte Ausdrücke. Diese werden verwendet, um einer Variable in Abhängigkeit von einer anderen Variable einen Wert zuzuweisen. Bedingte Ausdrücke stellen eine Kurzschreibweise für die folgende Verzweigung dar: # Kompliziert x &lt;- 2 if (x == 2) { var &lt;- 10 } else { var &lt;- 20 } # Einfach x &lt;- 2 var &lt;- if (x == 2) 10 else 20 # Alternative (macht dasselbe): Die ifelse-Funktion var &lt;- ifelse(x == 2, 10, 20) 3.4 while-Schleifen while-Schleifen werden verwendet, wenn ein Code-Block (=nur ein anderes Wort für Anweisungsblock) so lange ausgeführt werden soll, wie eine bestimmte Bedingung erfüllt ist. Die Bedingung steht im Schleifenkopf und wird überprüft, bevor der Code im Schleifenkörper ausgeführt wird. Wenn die Bedingung nicht (mehr) erfüllt ist, terminiert die Schleife. while-Schleifen haben die allgemeine Form: while (Bedingung) { Anweisungsblock } Beispiel: # In jedem Schleifendurchlauf wird zunächst der Ausdruck anzahl_ibus &gt; 0 ausgewertet. # Wenn der Ausdruck zu True evaluiert wird, wird die Anweisung im Schleifenkörper ausgeführt, d.h. der Wert der Variable anzahl_ibus wird um 1 verringert. # Wenn die Variable anzahl_ibus den Wert 0 annimmt, wird der Ausdruck im Schleifenkopf zu False evaluiert und die Schleife terminiert. # Nach dem Terminieren der Schleife wird eine Warnung ausgegeben. medikamente &lt;- c(Ibuprofen=30, Paracetamol=23, Aspirin=28) anzahl_ibus &lt;- medikamente[&quot;Ibuprofen&quot;] while (anzahl_ibus &gt; 0) { anzahl_ibus &lt;- anzahl_ibus - 1 } print(&quot;Warnung: kein Ibuprofen mehr da!&quot;) ## [1] &quot;Warnung: kein Ibuprofen mehr da!&quot; Verständnisfragen: Nach wie vielen Schleifendurchläufen wird die Meldung “Achtung! Kein Ibuprofen mehr da!” ausgegeben? Nach wie vielen Schleifendurchläufen terminiert die Schleife? Es ist auch möglich, while-Schleifen und bedingte Anweisungen zu kombinieren: # In jedem Schleifendurchlauf wird zunächst der Ausdruck anzahl_ibus &gt; 0 ausgewertet. # Wenn der Ausdruck zu True evaluiert wird, wird überprüft, ob der Wert dem Integer 5 entspricht. # Falls ja, wird eine Warnmeldung ausgegeben. # Danach wird der Wert der Variable anzahl_ibus um 1 verringert. # Wenn die Variable anzahl_ibus den Wert 0 annimmt, wird der Ausdruck im Schleifenkopf zu False evaluiert und die Schleife terminiert. # Nach dem Terminieren der Schleife wird eine weitere Warnung ausgegeben. medikamente &lt;- c(Ibuprofen=30, Paracetamol=23, Aspirin=28) anzahl_ibus &lt;- medikamente[&quot;Ibuprofen&quot;] while (anzahl_ibus &gt; 0) { if (anzahl_ibus == 5) { print(&quot;Warnung: nur noch 5 Ibuprofen da!&quot;) } anzahl_ibus &lt;- anzahl_ibus - 1 } ## [1] &quot;Warnung: nur noch 5 Ibuprofen da!&quot; print(&quot;Achtung! Kein Ibuprofen mehr da!&quot;) ## [1] &quot;Achtung! Kein Ibuprofen mehr da!&quot; Verständnisfrage: Wir wollen sichergehen, dass die Warnung wirklich im 26. Schleifendurchlauf ausgegeben wird. Wie könnten wir den Code ändern, damit in jedem Schleifendurchgang zusätzlich ein Wert ausgegeben wird? Achtung: while-Schleifen laufen unendlich lange, wenn die Abbruchbedingung nie erfüllt ist: # while (TRUE) { # print(&quot;Dies ist eine unendliche Schleife&quot;) #} Falls ihr versehentlich doch mal eine unendliche Schleife im RStudio ausgeführt haben solltet, könnt ihr die Ausführung der Schleife im RStudio abbrechen. Dazu könnt ihr entweder auf das rote Stopp-Zeichen oben rechts im Konsole-Fenster klicken oder ihr gebt dir Tastenkombination CTRL + C (Mac) bzw. Escape (Windows) ein. 3.5 for-Schleifen for-Schleifen werden verwendet, um iterierbare Objekte zu durchlaufen. Listen und Vektoren sind in R iterierbar; und weil Matrizen und Dataframes aus Vektoren bzw. Listen bestehen, sind auch Matrizen und Dataframes iterierbar. Iterieren bedeutet einfach “durchlaufen”. Im Kopf der for-Schleife steht anders als bei der while-Schleife keine Bedingung, sondern es wird eine Variable festgelegt, die als Platzhalter für den Wert der Elemente des Objekts dient. Diese Variable nennt man auch Laufvariable. Die for-Schleife “durchläuft” also im Grunde das Objekt, indem in jedem Schleifendurchlauf die Laufvariable den Wert des aktuellen Elements annimmt – und das so lange, bis es keine weiteren Elemente mehr gibt. Mithilfe des Variablennamens kann im Schleifenkörper auf den Wert des aktuellen Elements zugegriffen werden. Einen Schleifendurchlauf nennt man auch eine Iteration. for-Schleifen haben in R die allgemeine Form: for (Element in Objekt) { Anweisungsblock } Beispiel: # In jedem Schleifendurchlauf nimmt die Laufvariable zahl den Wert eines Elements aus dem # Vektor zahlen an und es wird der aktuelle Wert der Variable zahl, addiert mit 1, ausgegeben. woerter &lt;- c(&quot;Netzwerkdurchsetzungsgesetz&quot;, &quot;Abfallverzeichnisverordnung&quot;, &quot;Haftpflichtversicherung&quot;, &quot;Antivirenprogramm&quot;) for (wort in woerter) { print(paste(wort, nchar(wort))) } ## [1] &quot;Netzwerkdurchsetzungsgesetz 27&quot; ## [1] &quot;Abfallverzeichnisverordnung 27&quot; ## [1] &quot;Haftpflichtversicherung 23&quot; ## [1] &quot;Antivirenprogramm 17&quot; Mithilfe der Funktion nchar() kann die Anzahl der Zeichen in einer Zeichenkette (=character) bestimmt werden. Wie while-Schleifen können auch for-Schleifen mit bedingten Anweisungen kombiniert werden: # In jedem Schleifendurchlauf nimmt die Laufvariable wort den Wert eines Elements aus dem Vektor woerter (s.o.) an. # Zunächst wird die Zeichenanzahl des aktuellen Strings der Variable laenge als Wert zugewiesen. # Dann wird geprüft, ob der Wert der Variable zeichen größer als 20 ist. # Falls ja, wird der Liste lange_woerter ein Element mit dem aktuellen Wert der Variable wort als Schlüssel und der Zeichenanzahl als Wert hinzugefügt. # Wenn der Vektor woerter keine weiteren Elemente mehr enthält, terminiert die Schleife. # Danach wird die Liste lange_woerter ausgegeben. woerter &lt;- c(&quot;Netzwerkdurchsetzungsgesetz&quot;, &quot;Abfallverzeichnisverordnung&quot;, &quot;Haftpflichtversicherung&quot;, &quot;Antivirenprogramm&quot;) lange_woerter &lt;- list() for (wort in woerter) { zeichen &lt;- nchar(wort) if (zeichen &gt; 20) { lange_woerter[[wort]] &lt;- zeichen } } print(lange_woerter) ## $Netzwerkdurchsetzungsgesetz ## [1] 27 ## ## $Abfallverzeichnisverordnung ## [1] 27 ## ## $Haftpflichtversicherung ## [1] 23 Es muss jedoch beachtet werden, dass Elemente eines iterierbaren Objekts im Laufe einer Iteration nicht direkt verändert werden können: tiere &lt;- c(&quot;Hund&quot;, &quot;Elefant&quot;, &quot;Igel&quot;, &quot;Katze&quot;) for (tier in tiere) { tier &lt;- tolower(tier) } # Änderungen wurden nicht übernommen print(tiere) ## [1] &quot;Hund&quot; &quot;Elefant&quot; &quot;Igel&quot; &quot;Katze&quot; Mithilfe der Funktion tolower() können Buchstaben in einer Zeichenkette (=character) automatisch in Kleinbuchstaben umgewandelt werden. Das liegt daran, dass die Laufvariable nur für den Wert des aktuellen Elements steht, nicht für dieses Element selbst. Die Laufvariable haben wir also eigentlich bisher als “Wertvariable” verwendet. Um Elemente im Schleifendurchlauf zu verändern, muss mithilfe der Indexposition direkt auf ein Element aus dem Vektor oder der Liste zugegriffen werden, also genau so, wie wir bisher auch auf Elemente zugegriffen haben. Doch mit jedem Schleifendurchlauf nimmt die Laufvariable ja den Wert eines anderen Elements an; die Indexposition des aktuellen Elements ändert sich also fortlaufend. Um auf Elemente in einem Schleifendurchlauf zuzugreifen, brauchen wir also eine Variable, die nicht den Wert des aktuellen Elements annimmt, sondern dessen Indexposition. for-Schleifen werden deswegen in R meist als sogennante Zählschleife verwendet. Dazu wird die Funktion seq_along() verwendet, die einen Integer-Vektor erstellt, der genau so lang ist, wie das Objekt, das der Funktion übergeben wird. Solche for-Schleifen haben die allgemeine Form: for (i in seq_along(Objekt)) { Anweisungsblock } Das i steht für iterator und dient als Zählvariable: mit jedem Schleifendurchlauf (Iteration) wird i um Eins erhöht; der Zählbeginn ist 1. In jeder Iteration wird auf das Element i des iterierbaren Objekts zugegriffen. Mithilfe des Iterators i kann also in jeder Iteration auf ein Element aus dem Objekt zugegriffen werden. Klingt kompliziert, wird aber am folgenden Beispiel direkt deutlich: tiere &lt;- c(&quot;Hund&quot;, &quot;Elefant&quot;, &quot;Igel&quot;, &quot;Katze&quot;) for (i in seq_along(tiere)) { tiere[i] &lt;- tolower(tiere[i]) } # Änderungen wurden übernommen print(tiere) ## [1] &quot;hund&quot; &quot;elefant&quot; &quot;igel&quot; &quot;katze&quot; Verständnisfragen: Welchen Wert nimmt i im ersten Schleifendurchlauf an? Auf welches Element wird zugegriffen? Welchen Wert nimmt i im dritten Schleifendurchlauf an? Auf welches Element wird zugegriffen? Kann man eine for-Schleife auch dazu verwenden, um über die Spalten einer Matrix / eines Dataframes zu iterieren? Was macht die Funktion seq_along()? Wann empfiehlt es sich, seq_along() in Verbindung mit einer for-Schleife zu verwenden? Auch Zählschleifen können mit bedingten Anweisungen oder Verzweigungen kombiniert werden: tiere &lt;- c(&quot;Hund&quot;, &quot;Elefant&quot;, &quot;Igel&quot;, &quot;Katze&quot;) for (i in seq_along(tiere)) { if (tiere[i] == &quot;Hund&quot;) { tiere[i] &lt;- tolower(tiere[i]) } else { tiere[i] &lt;- toupper(tiere[i]) } } # Änderungen wurden übernommen print(tiere) ## [1] &quot;hund&quot; &quot;ELEFANT&quot; &quot;IGEL&quot; &quot;KATZE&quot; Im Beispiel oben haben wir mehrmals tiere[i] verwendet. Falls wir uns irgendwann später dazu entscheiden sollten, die Variable tiere umzubenennen, müssten wir alle Vorkommnisse von tiere[i] im Schleifenkörper finden und austauschen. So entstehen schnell Fehler. Um das Problem zu umgehen, könnten wir jetzt auf die Idee kommen, eine “temporäre” Variable zu verwenden, der am Anfang jedes Schleifendurchlaufs das aktuelle Element zugewiesen wird: tiere &lt;- c(&quot;Hund&quot;, &quot;Elefant&quot;, &quot;Igel&quot;, &quot;Katze&quot;) for (i in seq_along(tiere)) { tier &lt;- tiere[i] if (tier == &quot;Hund&quot;) { tier &lt;- tolower(tier) } else { tier &lt;- toupper(tier) } } # Änderungen wurden nicht übernommen! print(tiere) ## [1] &quot;Hund&quot; &quot;Elefant&quot; &quot;Igel&quot; &quot;Katze&quot; Aber wenn wir uns am Ende den Vektor tiere ausgeben lassen, sehen wir, dass wir den Vektor gar nicht verändert haben! Woran liegt das? Verständnisfragen: Warum wird der Vektor tiere durch das Einfügen einer temporären Variable nicht mehr verändert? Wie könnten wir den Code im Beispiel umschreiben, um das Problem zu beheben? Der Grund für dieses Verhalten liegt wieder in der Unveränderbarkeit der Objekte in R. Um das Problem zu beheben, gibt es verschiedene Möglichkeiten. Die Änderungen, die am Objekt tier vorgenommen wurden, könnten zum Beispiel am Ende der Schleife wieder dem Objekt tiere[i] zugewiesen werden: tiere &lt;- c(&quot;Hund&quot;, &quot;Elefant&quot;, &quot;Igel&quot;, &quot;Katze&quot;) for (i in seq_along(tiere)) { tier &lt;- tiere[i] if (tier == &quot;Hund&quot;) { tier &lt;- tolower(tier) } else { tier &lt;- toupper(tier) } # Wert der Variable tier wieder dem Element tiere[i] zuweisen tiere[i] &lt;- tier } # Änderungen wurden übernommen! print(tiere) ## [1] &quot;hund&quot; &quot;ELEFANT&quot; &quot;IGEL&quot; &quot;KATZE&quot; Alternativ kann auch der ursprüngliche Vektor beibehalten werden und die Änderungen in jedem Schleifendurchgang einem neuen Vektor tiere_neu() hinzuzufügt werden. Dafür kann in diesem Fall eine einfache for-Schleife verwendet werden: tiere &lt;- c(&quot;Hund&quot;, &quot;Elefant&quot;, &quot;Igel&quot;, &quot;Katze&quot;) tiere_neu &lt;- c() # leeren Vektor erstellen for (tier in tiere) { if (tier == &quot;Hund&quot;) { tier &lt;- tolower(tier) } else { tier &lt;- toupper(tier) } # Wert der Variable tier als neues Element dem Vektor tiere_neu hinzufügen tiere_neu &lt;- c(tiere_neu, tier) } print(tiere_neu) ## [1] &quot;hund&quot; &quot;ELEFANT&quot; &quot;IGEL&quot; &quot;KATZE&quot; print(tiere) # Vektor tiere ist unverändert ## [1] &quot;Hund&quot; &quot;Elefant&quot; &quot;Igel&quot; &quot;Katze&quot; 3.6 Schleifen abbrechen Es ist zudem möglich, einen Schleifendurchlauf (Iteration) oder die gesamte Schleife abhängig von einer Bedingung frühzeitig abzubrechen. Eine next-Anweisung kann verwendet werden, um den aktuellen Schleifendurchlauf abzubrechen und direkt zum Schleifenkopf zu springen (= Iterationsabbruch). Eine break-Anweisung wird verwendet, um die Schleife komplett abzubrechen (= Schleifenabbruch). Das kann nützlich sein, wenn man fehlende Werte in einem Objekt hat und diese überspringen möchte, damit es zu keiner Fehlermeldung kommt. Die Signalworte next und break können sowohl mit while-Schleifen als auch mit for-Schleifen verwendet werden. Hier ein Beispiel mit einer for-Schleife: # next Anweisung # Vektor mit NA-Werten beliebige_woerter &lt;- c(&quot;Baum&quot;, &quot;Wald&quot;, NA, &quot;Meer&quot;, NA, &quot;Sonne&quot;) # Funktion is.na() überprüft, ob der Wert des Elements wort NA ist for (wort in beliebige_woerter) { if (is.na(wort)) { next } else { print(wort) } } ## [1] &quot;Baum&quot; ## [1] &quot;Wald&quot; ## [1] &quot;Meer&quot; ## [1] &quot;Sonne&quot; # break Anweisung # Vektor mit NA-Werten beliebige_woerter &lt;- c(&quot;Baum&quot;, &quot;Wald&quot;, NA, &quot;Meer&quot;, NA, &quot;Sonne&quot;) # Funktion is.na() überprüft, ob der Wert des Elements wort NA ist for (wort in beliebige_woerter) { if (is.na(wort)) { break } else { print(wort) } } ## [1] &quot;Baum&quot; ## [1] &quot;Wald&quot; Schleifen in R Für die meisten Anwendungen verwendet man in R eher for-Schleifen als while-Schleifen. In vielen Fällen sind Schleifen aber sogar überhaupt nicht notwendig. In der nächsten Stunde werden wir sehen, dass Schleifen in vielen Fällen durch bestimmte Funktionen ersetzt werden können. Da R im Kern eine sogenannte “funktionale” Programmiersprache ist, werden Schleifen weniger verwendet als in anderen Programmiersprachen. Quellen Venables, W.N. and Smith, D.M. and the R Core Team. An Introduction to R, https://cran.r-project.org/doc/manuals/r-release/R-intro.pdf Wickham, Hadley. The Tidyverse Style Guide, https://style.tidyverse.org/ Reussner, Ralf H. Mitschnitt zur Vorlesung “Programmieren” im WiSe 2015/2016. 03: Kontrollstrukturen, https://www.youtube.com/watch?v=-ZvrABPvUdA Wickham, Hadley and Grolemund, Garrett. R for Data Science: Iteration, https://r4ds.had.co.nz/iteration.html "],["r-basics-iv-funktionen-und-pakete.html", "4 R Basics IV: Funktionen und Pakete 4.1 Grundlegende Begriffe 4.2 Was sind Funktionen? 4.3 Funktionen definieren 4.4 Funktionen aufrufen 4.5 Funktionen verstehen 4.6 Wozu werden Funktionen verwendet? 4.7 Schleifen ersetzen mithilfe von Funktionen 4.8 Gültigkeit der Funktionsargumente überprüfen 4.9 Funktionsumgebung und Sichtbarkeitsbereich von Variablen 4.10 Was sind Pakete? 4.11 Pakete installieren 4.12 Pakete laden 4.13 Wozu werden Pakete verwendet? 4.14 Welche Pakete gibt es denn alles? Quellen", " 4 R Basics IV: Funktionen und Pakete Wir haben im Laufe der vergangenen Stunden bereits einige Funktionen kennengelernt, zum Beispiel die Ausgabe-Funktion print(), die Funktion c() zum Erstellen von Vektoren oder die Funktion paste() zum Verketten von character-Objekten. 4.1 Grundlegende Begriffe Begriff Englische Entsprechung Definition (im R-Kontext) Aufrufen Call Wenn die Anweisungen, die in einer Funktion definiert sind, ausgeführt werden, sagt man, dass die Funktion aufgerufen wird. Beim Aufruf können der Funktion Argumente übergeben werden, also Werte, die für die Parameter aus der Funktionsdefinition eingesetzt werden. Zurückgeben Return Funktionen haben einen Rückgabewert, das heißt, sie liefern beim Ausführen einen Wert, der das Ergebnis der Funktion darstellt und der weiterverwendet werden kann. Beim Aufruf einiger Funktionen wird nur etwas auf dem Bildschirm ausgegeben. Diese Funktionen haben meist den Rückgabewert NULL. 4.2 Was sind Funktionen? Funktionen sind wiederverwendbare Abfolgen von Anweisungen. Sie sind also Codeabschnitte, die mithilfe eines Namens wiederholt ausgeführt werden können. Das Prinzip ist also ein bisschen ähnlich wie Variablen, mit dem Unterschied, dass man mithilfe von Funktionsnamen auf Anweisungen zugreifen kann, während man mithilfe von Variablennamen auf Objekte zugreifen kann. Im Grunde sind Funktionsnamen aber auch zugleich Variablennamen, weil in R Funktionen auch Objekte sind (-&gt; Grundbegriffe: alles in R ist ein Objekt). Jede Funktion besteht aus vier Komponenten: Name (“name”) Parameter (“formals”: formale Parameter) Körper (“body”) Umgebung (“environemnt”) Funktionen werden aufgerufen. Beim Funktionsaufruf werden ihnen Argumente übergeben. Welche Argumente eine Funktion annehmen kann, wird in der Funktionsdefinition mithilfe von formalen Parametern festgelegt. Für Argumente sagt man deswegen auch manchmal tatsächliche Parameter. Funktionen geben immer einen Wert zurück, der heißt dann Rückgabewert. Der Rückgabewert kann in einer Funktionsdefinition mithilfe des Schlüsselworts return festgelegt werden. 4.3 Funktionen definieren Funktionsdefinitionen haben in R die allgemeine Form: mache_irgendwas &lt;- function(Parameter_1, Parameter_2, ...) { Anweisungsblock return(Rückgabewert) } Achtung: zwischen dem Schlüsselwort function und der runden Klammer steht KEIN Leerzeichen, anders als bei Kontrollstrukturen. mache_irgendwas ist der Funktionsname. Die Funktionsparameter heißen Parameter_1 und Parameter_2. Dabei handelt es sich um Variablennamen, die nur innerhalb der Funktionsdefinition verwendet werden und als Platzhalter für die Argumente dienen, die der Funktion beim Funktionsaufruf übergeben werden. Die formalen Parameter sind also ein bisschen ähnlich wie die Laufvariablen in for-Schleifen, die auch nur Platzhalter für die Elemente aus einem iterierbaren Objekt waren. Genau wie bei Kontrollstrukturen ist auch bei Funktionen der Funktionskörper alles, was zwischen den geschweiften Klammern steht, also ein Anweisungsblock und eine return-Anweisung. Im Anweisungsblock stehen irgendwelche Anweisungen, die irgendetwas mit den Parametern der Funktion machen, also im Grunde Verarbeitungsschritte für die Funktionsparameter. Im Laufe der Verarbeitung wird irgendeine Variable definiert, die das “Endergebnis” der Verarbeitung zwischenspeichert. Diese Variable wird dann mithilfe der return-Anweisung zurückgegeben, wenn die Funktion aufgerufen wird. Die return-Anweisung definiert also, welche Variable die Funktion als Rückgabewert beim Funktionsaufruf zurückgeben soll. Die Funktionsumgebung ist in der Funktionsdefinition nicht direkt sichtbar. Funktionsumgebungen lernen wir erst etwas später kennen und ignorieren sie erst einmal. Style Tip Für Funktionsnamen gelten fast die selben Konventionen wie für Variablennamen: Wickham empfiehlt, Funktionsnamen in Kleinbuchstaben zu schreiben und einen Unterstrich zu verwenden, um mehrere Wörter voneinander abzutrennen. Allerdings sollten Variablennamen immer irgendeine Operation beschreiben, während Variablennamen in der Regel Substantive sind. Dabei kann es sich auch um eine logische Operation handeln: ist_ungerade() wäre zum Beispiel ein passender Funktionsname für eine Funktion, die überprüft, ob ihr Argument eine ungerade Zahl ist. Ein Beispiel: increment_value &lt;- function(x) { x &lt;- x + 1 return(x) } Verständnisfragen: Was macht die Funktion increment_value()? Was ist der Körper der Funktion increment_value()? Was sind die formalen Parameter? Was ist der Rückgabewert? Anders als in anderen Programmiersprachen kann in R bei einer Funktionsdefinition die return()-Anweisung auch weggelassen werden. Dann wird automatisch der Ausdruck als Rückgabewert zurückgegeben, der im Funktionskörper zuletzt evaluiert wurde: # x + 1 wird &quot;implizit&quot; als Rückgabewert zurückgegeben, wenn die return-Anweisung fehlt increment_value &lt;- function(x) { x + 1 } Der Style Guide, nach dem wir uns richten, empfiehlt, return() nur für frühzeitige Rückgaben zu verwenden, also wenn eine Bedingung erfüllt ist und die Funktion an dieser Stelle beendet werden soll. Am Anfang empfiehlt es sich aber trotzdem, den Rückgabewert immer explizit mit return() anzugeben und an dieser Stelle vom Style Guide abzuweichen. Manchmal ist es sinnvoll, bei der Funktionsdefinition einen Default-Wert für einen oder mehrere Parameter anzugeben: # Funktion mit Default-Wert für einen Parameter add_values &lt;- function(x, y=10) { return(x + y) } Dieser Default-Wert wird dann beim Funktionsaufruf eingesetzt, falls kein Wert für den Parameter festgelegt wird. 4.4 Funktionen aufrufen Funktionsaufurfe haben in R die allgemeine Form: mache_irgendwas(Argument_1, Argument_2, ...) Wenn eine Funktion aufgerufen wird, dann werden die formalen Parameter aus der Funktionsdefinition durch die Argumente (also die tatsächlichen Parameter) ersetzt. Die Verarbeitungsschritte, die im Funktionskörper für die formalen Parameter definiert sind, werden dann mit den Argumenten ausgeführt. Bisher haben wir bereits oft Funktionen aufgerufen und ihnen Argumente übergeben. Zum Beispiel: print(&quot;Hallo&quot;) ## [1] &quot;Hallo&quot; tiere &lt;- c(&quot;Hund&quot;, &quot;Katze&quot;) paste0(tiere[1], &quot;e&quot;) ## [1] &quot;Hunde&quot; length(tiere) ## [1] 2 Wenn wir die Funktion increment_value(), die wir vorhin definiert haben, aufrufen wollen, gehen wir genauso vor: increment_value(3) ## [1] 4 Wenn eine Funktion aufgerufen wird, für deren Parameter in der Funktionsdefinition ein Standardwert festgelegt wurde, dann ist die Angabe eines Werts für diesen Parameter beim Funktionsaufruf optional: # addiert 2 mit dem Standardwert 10 add_values(2) ## [1] 12 # addiert 2 mit 5 add_values(2, 5) ## [1] 7 Verständnisfrage: Welche Argumente werden den Funktionen print(), c(), paste0(), length(), increment_value() und add_values jeweils beim Funktionsaufruf übergeben? In R sind Funktionen auch Objekte. Das heißt, dass eine Funtion als Argument einer anderen Funktion übergeben werden kann. 4.5 Funktionen verstehen Alle Funktionen sind in R gut dokumentiert. Wir haben die offizielle Dokumentation zu einzelnen Funktionen bereits mithilfe des ?-Operators aufgerufen. Funktionen sind in der R-Dokumentation immer nach demselben Schema dokumentiert: Description ist eine kurze Beschreibung davon, was die Funktion macht. Unter Usage steht, wir die Funktion aufgerufen werden kann. Arguments erläutert, welche Argumente der Funktion beim Funktionsaufruf übergeben werden können, und Value beschreibt den Rückgabewert, also welchen Datentyp der Wert hat, der von der Funktion nach der Ausführung aller Anweisungen im Funktionskörper zurückgegeben wird. Beispiel: Dokumentationsseite zur Funktion typeof() 4.6 Wozu werden Funktionen verwendet? Allgemein werden Funktionen verwendet… …um bestimmte Verarbeitungsschritte zu wiederholen, ohne Code ständig kopieren zu müssen. …um den Code weniger fehleranfällig zu machen: Wenn man den Code kopiert, kopiert man auch mögliche Fehler …um den Code effizienter zu machen: Wenn Funktionen verwendet werden, um Schleifen zu ersetzen, macht das den Code effizienter, das heißt, der Computer braucht weniger lange, um dieselben Berechnungen auszuführen Beispiel: Wir wollen herausfinden, wie oft jedes Wort in den Songtexten eine:r Künstler:in vorkommt. Dazu haben wir uns die folgende for-Schleife ausgedacht: lyrics &lt;- &quot;My mind won&#39;t let me rest Voice in my head I hear what it said I can&#39;t trust a thing If I picked up and left How fast did you forget? Resting while I&#39;m inside your presence I don&#39;t want to think nothing bad This time I won&#39;t This time I won&#39;t&quot; lyrics_vec &lt;- strsplit(lyrics, &quot; &quot;)[[1]] lyrics_freq &lt;- c() for (word in lyrics_vec) { if (!(word %in% names(lyrics_freq))) { lyrics_freq[word] &lt;- 1 } else { lyrics_freq[word] &lt;- lyrics_freq[word] + 1 } } print(lyrics_freq) ## My mind won&#39;t let me rest Voice in ## 1 1 3 1 1 1 1 1 ## my head I hear what it said can&#39;t ## 1 1 6 1 1 1 1 1 ## trust a thing If picked up and left ## 1 1 1 1 1 1 1 1 ## How fast did you forget? Resting while I&#39;m ## 1 1 1 1 1 1 1 1 ## inside your presence don&#39;t want to think nothing ## 1 1 1 1 1 1 1 1 ## bad This time ## 1 2 2 Verständnisfragen: Was macht die Funktion strsplit()? Welche Datenstruktur gibt die Funktion als Rückgabewert zurück? Gebt ?strsplit ein und schaut nach. Was passiert in jedem Schleifendurchlauf? Der named vector lyrics_vec enthält dasselbe Wort zweimal, wenn es einmal groß- und einmal kleingeschrieben wird, zum Beispiel “My” und “my”. In der letzten Stunde haben wir eine Funktion kennengelernt, die alle Großbuchstaben in einem Wort in Kleinbuchstaben umwandelt. Wie hieß die Funktion? Und wie könnten wir die Funktion verwenden, um unsere for-Schleife zu verbessern? Um die Arbeitsschritte mit mehreren Liedern auszuführen, sähe unser Code so aus: lyrics_gc &lt;- &quot;My mind won&#39;t let me rest Voice in my head I hear what it said I can&#39;t trust a thing If I picked up and left How fast did you forget? Resting while I&#39;m inside your presence I don&#39;t want to think nothing bad This time I won&#39;t This time I won&#39;t&quot; lyrics_gc_vec&lt;- strsplit(lyrics_gc, &quot; &quot;)[[1]] lyrics_gc_freq &lt;- c() for (word in lyrics_gc_vec) { if (!(word %in% names(lyrics_gc_freq))) { lyrics_gc_freq[word] &lt;- 1 } else { lyrics_gc_freq[word] &lt;- lyrics_gc_freq[word] + 1 } } print(lyrics_gc_freq) lyrics_dd &lt;- &quot;I&#39;m dreamin&#39;, ay Truth be told I got the hardest ahead, yeah But I said I never let it get to my head I be in space, in a daze, while you tellin me things I see your face but I never really heard you say it Red light, green light, either I&#39;ma go New place, corner store Ain&#39;t that close anymore Yeah let me get the greens, I&#39;ll be home by four If you wanna pour up, then I need me a four&quot; lyrics_dd_vec &lt;- strsplit(lyrics_dd, &quot; &quot;)[[1]] lyrics_dd_freq &lt;- c() for (word in lyrics_dd_vec) { if (!(word %in% names(lyrics_dd_freq))) { lyrics_dd_freq[word] &lt;- 1 } else { lyrics_dd_freq[word] &lt;- lyrics_dd_freq[word] + 1 } } print(lyrics_dd_freq) In der Lösung oben haben wir die for-Schleife einfach kopiert und manuell die Variable lyrics_gc durch die Variable lyrics_dd ersetzt. Das geht bei zwei verschiedenen Liedtexten zwar noch, aber was, wenn wir drei, fünf oder zehn verschiedene Liedtexte haben? Dann produzieren wir extrem viel unnötigen und unübersichtlichen Code, der vielleicht auch noch drei, fünf oder zehnmal denselben Fehler enthält. Eine bessere Lösung ist deswegen hier die Verwendung einer Funktion: die for-Schleife kann damit für alle Liedtexte, die in R als character repräsentiert werden, verallgemeinert werden: lyrics_to_frequencies &lt;- function(lyrics) { lyrics_vec &lt;- strsplit(lyrics, &quot; &quot;)[[1]] lyrics_freq &lt;- c() for (word in lyrics_vec) { if (!(word %in% names(lyrics_freq))) { lyrics_freq[word] &lt;- 1 } else { lyrics_freq[word] &lt;- lyrics_freq[word] + 1 } } return(lyrics_freq) } Die Funktion kann dann mit wechselndem Input aufgerufen werden: lyrics_gc &lt;- &quot;My mind won&#39;t let me rest Voice in my head I hear what it said I can&#39;t trust a thing If I picked up and left How fast did you forget? Resting while I&#39;m inside your presence I don&#39;t want to think nothing bad This time I won&#39;t This time I won&#39;t&quot; lyrics_dd &lt;- &quot;I&#39;m dreamin&#39;, ay Truth be told I got the hardest ahead, yeah But I said I never let it get to my head I be in space, in a daze, while you tellin me things I see your face but I never really heard you say it Red light, green light, either I&#39;ma go New place, corner store Ain&#39;t that close anymore Yeah let me get the greens, I&#39;ll be home by four If you wanna pour up, then I need me a four&quot; lyrics_gc_freq &lt;- lyrics_to_frequencies(lyrics_gc) lyrics_dd_freq &lt;- lyrics_to_frequencies(lyrics_dd) print(lyrics_gc_freq) ## My mind won&#39;t let me rest Voice in ## 1 1 3 1 1 1 1 1 ## my head I hear what it said can&#39;t ## 1 1 6 1 1 1 1 1 ## trust a thing If picked up and left ## 1 1 1 1 1 1 1 1 ## How fast did you forget? Resting while I&#39;m ## 1 1 1 1 1 1 1 1 ## inside your presence don&#39;t want to think nothing ## 1 1 1 1 1 1 1 1 ## bad This time ## 1 2 2 print(lyrics_dd_freq) ## I&#39;m dreamin&#39;, ay Truth be told I got ## 1 1 1 1 3 1 7 1 ## the hardest ahead, yeah But said never let ## 2 1 1 1 1 1 2 2 ## it get to my head in space, a ## 2 2 1 1 1 2 1 2 ## daze, while you tellin me things see your ## 1 1 3 1 3 1 1 1 ## face but really heard say Red light, green ## 1 1 1 1 1 1 2 1 ## either I&#39;ma go New place, corner store Ain&#39;t ## 1 1 1 1 1 1 1 1 ## that close anymore Yeah greens, I&#39;ll home by ## 1 1 1 1 1 1 1 1 ## four If wanna pour up, then need ## 2 1 1 1 1 1 1 Verständnisfrage: Angenommen, wir wollen die Funktion lyrics_to_frequencies() auf 20 verschiedene Liedtexte anwenden. Dann würden wir den Funktionsaufruf zwanzig Mal kopieren. Dieses Vorgehen ist nicht schön, denn so können sich wieder Fehler einschleichen. Wie könnte man das Problem lösen? Welches Vorgehen wäre eleganter? 4.7 Schleifen ersetzen mithilfe von Funktionen Am Ende der letzten Einheit habe ich bereits darauf hingewiesen, dass Schleifen in R viel weniger verwendet werden als in anderen Programmiersprachen. Das liegt daran, dass Schleifen in R oft durch Funktionen ersetzt werden, die im Allgemeinen effizienter sind als Schleifen. Das Prinzip, das das ermöglicht, haben wir bereits kennengelernt: Es heißt “Vektorisierung” und beschreibt einen Mechanismus, bei dem Operationen direkt auf alle Elemente eines Vektors angewandt weren. Vektorisierte Funktionen Man sagt, dass eine Funktion “vektorisiert” ist, wenn eine Funktion in der Lage ist, direkt einen Vektor oder ein Objekt mit einer anderen Datenstruktur zu bearbeiten. Anders formuliert: Vektorisierte Funktionen können elementweise Operationen auf Vektoren durchführen. Solche Funktionen nehmen einen Vektor oder eben eine andere Datenstruktur als Argumente an und geben als Rückgabewert oft ein Objekt mit derselben Datenstruktur zurück. Tatsächlich haben wir bereits eine Funktion kennengelernt, welche auf Vektorisierung zurückgreift, um genau das zu machen, was wir in unserem Beispiel mit den Liedtexten mühsam mithilfe einer for-Schleife und später mithilfe unserer selbst definierten Funktion lyrics_to_frequencies() erreicht haben: die table()-Funktion. lyrics &lt;- &quot;My mind won&#39;t let me rest Voice in my head I hear what it said I can&#39;t trust a thing If I picked up and left How fast did you forget? Resting while I&#39;m inside your presence I don&#39;t want to think nothing bad This time I won&#39;t This time I won&#39;t&quot; lyrics_vec &lt;- strsplit(lyrics, &quot; &quot;)[[1]] lyrics_freq &lt;- table(lyrics_vec) print(lyrics_freq) ## lyrics_vec ## a and bad can&#39;t did don&#39;t fast forget? ## 1 1 1 1 1 1 1 1 ## head hear How I I&#39;m If in inside ## 1 1 1 6 1 1 1 1 ## it left let me mind my My nothing ## 1 1 1 1 1 1 1 1 ## picked presence rest Resting said thing think This ## 1 1 1 1 1 1 1 2 ## time to trust up Voice want what while ## 2 1 1 1 1 1 1 1 ## won&#39;t you your ## 3 1 1 Zur Erinnerung: Die table()-Funktion wandelt ihr Argument zunächst automatisch in einen Faktor um und erstellt daraus eine Häufigkeitstabelle. Auch andere for-Schleifen aus der letzten Stunde können durch eine Funktion ersetzt werden. Am Ende der letzten Stunde haben wir uns beispielsweise die folgende for-Schleife angesehen, welche eine Änderung an den Elementen eines Vektors tiere vornimmt und die geänderten Werte einem neuen Vektor tiere_neu zuweist: tiere &lt;- c(&quot;Hund&quot;, &quot;Elefant&quot;, &quot;Igel&quot;, &quot;Katze&quot;) tiere_neu &lt;- c() # leeren Vektor erstellen for (i in seq_along(tiere)) { tier &lt;- tiere[i] if (tier == &quot;Hund&quot;) { tier &lt;- tolower(tier) } else { tier &lt;- toupper(tier) } # Wert der Variable tier als neues Element dem Vektor tiere_neu hinzufügen tiere_neu &lt;- c(tiere_neu, tier) } print(tiere_neu) ## [1] &quot;hund&quot; &quot;ELEFANT&quot; &quot;IGEL&quot; &quot;KATZE&quot; Dasselbe kann mithilfe der Funktion ifelse() in einer einzigen Zeile erreicht werden: tiere &lt;- c(&quot;Hund&quot;, &quot;Elefant&quot;, &quot;Igel&quot;, &quot;Katze&quot;) tiere_neu &lt;- ifelse(tiere == &quot;Hund&quot;, tolower(tiere), toupper(tiere)) Die Funktion ifelse() greift genau wie die table()-Funktion unter der Motorhaube auf Vektorisierung zurück: Wenn der Ausdruck tiere == \"Hund\" ausgewertet wird, wird ein Vektor erstellt, dessen Elemente den Wert TRUE für jedes Element im Vektor tiere, das dem Wert \"Hund\" entspricht, hat, und FALSE sonst. Der zweite Parameter der Funktion ifelse, in unserem Fall tolower(tiere), legt fest, was mit den Elementen, für die Vergleichsoperation zu TRUE evaluiert wurde, passieren soll. Der dritte Parameter (toupper(tiere)) legt fest, was mit den Elementen, die zu FALSE ausgewertet wurden, passieren soll. Auch unsere for-Schleife zur Erstellung eines Vektors mit langen Wörtern können wir ersetzen, indem wir die Funktion nchar() vektorisiert wird, also indem ihr ein Vektor als Argument übergeben wird. Anstelle mithilfe einer if-Anweisung zu überprüfen, ob die Zeichenanzahl eines Wortes im Vektor woerter größer als 20 ist, wird die Funktion which() verwendet. Diese Funktion kann ebenfalls vektorisiert werden, also mit einem Vektor als Argument aufgerufen werden. Ihr Rückgabewert ist ein Vektor mit den Indizes der Elemente, für die der Ausdruck wortlaengen &gt; 20 zu TRUE evaluiert wurde. woerter &lt;- c(&quot;Netzwerkdurchsetzungsgesetz&quot;, &quot;Abfallverzeichnisverordnung&quot;, &quot;Haftpflichtversicherung&quot;, &quot;Antivirenprogramm&quot;) wortlaengen &lt;- nchar(woerter) indizes &lt;- which(wortlaengen &gt; 20) lange_woerter &lt;- wortlaengen[indizes] names(lange_woerter) &lt;- woerter[indizes] lange_woerter ## Netzwerkdurchsetzungsgesetz Abfallverzeichnisverordnung ## 27 27 ## Haftpflichtversicherung ## 23 Pro Tipp Viele Funktionen nehmen nicht nur Vektoren als Argumente an, sondern auch Listen oder andere Datenstrukturen. Welchen Datentyp oder welche Datenstruktur ein Objekt haben muss, damit eine Funktion auf das Objekt angewendet werden kann, erfahrt ihr in der Funktionsdokumentation unter “Arguments” in den R Hilfeseiten. Die Möglichkeit, in vielen Fällen for-Schleifen durch Funktionen, die Vektoren oder andere Datenstrukturen als Argumente annehmen, zu ersetzen, macht R Code häufig kürzer und in vielen Fällen auch effizienter als zum Beispiel Python Code. Am Anfang kann dieser Vorteil aber vor allem verwirren. Deswegen ist es besonders am Anfang komplett in Ordnung und sogar empfehlenswert, erst einmal Schleifen zu verwenden, und diese erst später durch eine geeignete Funktion auszutauschen. Durch das Erstellen der Schleife könnt ihr euch besser in die Aufgabe und die notwendigen Verarbeitungsschritte zur Lösung der Aufgabe eindenken. 4.7.1 Die Apply-Funktionen Nicht jede Funktion kann allerdings vektorisiert werden, also nicht jede Funktion nimmt einen Vektor oder eine andere Datenstruktur als Argument an. In diesem Fall können spezielle Funktionen verwendet werden, die eine andere Funktion und einen Vektor oder eine Liste als Argument annehmen und diese Funktion auf jedes Element des Vektors (oder der Liste) anwenden. Diese Funktionen heißen lapply(), sapply(), vapply() und mapply(). Verständnisfrage: Was ist der Unterschied zwischen den verschiedenen Apply-Funktionen? Sucht nach den Funktionen in den R-Hilfeseiten und vergleicht Argumente und Rückgabewerte der Funktionen. Ein Beispiel: Angenommen, wir hätten die folgende (fragwürdige) Funktion definiert, die erkennen soll, ob eine Stadt in Deutschland eine Großstadt ist und eine entsprechende Nachricht zurückgibt. ist_grossstadt &lt;- function(stadt) { grossstaedte &lt;- c(&quot;Berlin&quot;, &quot;Hamburg&quot;, &quot;Frankfurt&quot;, &quot;München&quot;) if (stadt %in% grossstaedte) { return(paste(stadt, &quot;ist eine Großstadt&quot;)) } else { return(paste(stadt, &quot;ist keine Großstadt&quot;)) } } Die Funktion ist etwas gestellt so definiert, dass sie nur auf einzelne Zeichenketten angewandt werden kann, nicht auf character-Vektoren. Beim Versuch, die Funktion mit einem Vektor als Argument auszuführen, wird eine Fehlermeldung ausgegeben. ist_grossstadt(c(&quot;Berlin&quot;, &quot;Bremen&quot;)) # produziert Fehlermeldung ## Error in if (stadt %in% grossstaedte) {: the condition has length &gt; 1 ist_grossstadt(&quot;Berlin&quot;) ## [1] &quot;Berlin ist eine Großstadt&quot; Um die Funktion trotzdem auf einen Vektor anzuwenden, kann die Funktion lapply() eingesetzt werden: lapply(c(&quot;Berlin&quot;, &quot;Bremen&quot;), ist_grossstadt) ## [[1]] ## [1] &quot;Berlin ist eine Großstadt&quot; ## ## [[2]] ## [1] &quot;Bremen ist keine Großstadt&quot; Im Fall unserer Beispielfunktion ist_grosstadt() wäre es natürlich auch möglich (und eleganter), die Funktion direkt so zu definieren, dass sie auch auf Vektoren angewandt werden kann. Dabei wird die Funktion außerdem so umgeschrieben, dass Wahrheitswerte statt Textnachrichten ausgegeben werden. Das hat den zusätzlichen Vorteil, dass das Ergebnis der Überprüfung flexibel weiterverwendet werden kann. ist_grossstadt &lt;- function(stadt) { grossstaedte &lt;- c(&quot;Berlin&quot;, &quot;Hamburg&quot;, &quot;Frankfurt&quot;, &quot;München&quot;) return(stadt %in% grossstaedte) } ist_grossstadt(c(&quot;Berlin&quot;, &quot;Bremen&quot;)) ## [1] TRUE FALSE Verständnisfrage: Warum kann die Funktion ist_grossstadt() auch auf Vektoren angewandt werden, wenn der Ausdruck stadt %in% grossstaedte außerhalb einer if-Anweisung evaluiert wird? Was ist anders, wenn der Ausdruck Teil einer if-Anweisung ist? 4.8 Gültigkeit der Funktionsargumente überprüfen In den Beispielfunktionen, die wir uns bisher angesehen haben, haben wir immer angenommen, dass ein gültiger Wert als Argument übergeben wird. Beim Versuch, die ist_grossstadt()-Funktion auf einen Vektor anzuwenden haben wir aber gesehen, dass beim Ausführen einer Funktion mit ungültigen Argumenten Fehler entstehen können. Deswegen ist es oft sinnvoll, im Funktionskörper zu überprüfen, ob die gewählten Argumente gültig sind. Wenn dies nicht der Fall ist, kann eine spezielle Funktion mit dem Namen stop() verwendet werden, um die Ausführung der Funktion abzubrechen und eine Fehlermeldung auszugeben: ist_grossstadt &lt;- function(stadt) { if (!is.character(stadt)) { stop(&quot;Das Argument &#39;stadt&#39; muss ein Charaktervektor sein.&quot;) } grossstaedte &lt;- c(&quot;Berlin&quot;, &quot;Hamburg&quot;, &quot;Frankfurt&quot;, &quot;München&quot;) return(stadt %in% grossstaedte) } ist_grossstadt(c(1, 2)) ## Error in ist_grossstadt(c(1, 2)): Das Argument &#39;stadt&#39; muss ein Charaktervektor sein. 4.9 Funktionsumgebung und Sichtbarkeitsbereich von Variablen Wenn wir Variablen erstellt haben, sind wir immer davon ausgegangen, dass diese im gesammten Programm mithilfe des Namens abrufbar sind. Wenn wir selbst eine Funktion definieren, und dabei eine Variable erstellen, dann ist die Variable im restlichen Programm jedoch im Normalfall nicht abrufbar, sie “existiert” sozusagen nur in der Funktion und ist im restlichen Programm nicht sichtbar. Ein Beispiel: x &lt;- 1 y &lt;- 2 beispiel &lt;- function() { x &lt;- 4 y &lt;- 5 return(c(x, y)) } Beim Funktionsaufruf werden die Variablen x und y aus dem Funktionskörper zurückgegeben: beispiel() ## [1] 4 5 Aber die Variablen x und y aus dem Funktionskörper können nicht unabhängig von der Funktion abgerufen werden. Sie existieren nur in der Funktion selbst: print(c(x, y)) ## [1] 1 2 Für Variablen, die innerhalb einer Funktion definiert sind, sagt man deswegen auch “lokale Variablen” und für Variablen, die außerhalb von Funktionen definiert sind, “globale Variablen”. Aber Achtung: Wenn im Funktionskörper eine Variable verwendet wird, für die im Funktionskörper oder beim Funktionsaufruf kein Wert festgelegt wird, dann wird beim Funktionsaufruf außerhalb der Funktion nach dieser Variable gesucht: x &lt;- 2 beispiel &lt;- function() { y &lt;- 1 return(c(x, y)) } beispiel() ## [1] 2 1 Der Bereich “außerhalb der Funktion” ist im Grunde genau das, was wir eingangs “Funktionsumgebung” genannt haben. In diesem Beispiel wird in der Funktionsdefinition nur eine lokale Variable y definiert. Wenn die Funktion beispiel() später aufgerufen wird, sucht R nach einer Definition für x. Da in der Funktion keine lokale Variable x definiert wurde, sucht R in der Funktionsumgebung (die in diesem Fall die globale Umgebung ist, wo die Funktion definiert wurde) und findet die globale Variable x. Wenn der Wert der Variable x sich im Programmverlauf ändert, dann wird beim Funktionsaufruf der Wert eingesetzt, den die Variable zum Zeitpunkt des Funktionsaufrufs angenommen hat: x &lt;- 4 beispiel() ## [1] 4 1 x &lt;- 6 beispiel() ## [1] 6 1 4.10 Was sind Pakete? “An R package is a collection of functions, data, and documentation that extends the capabilities of base R.” (Wickham 2017) Mit “base R” sind alle in R vordefinierten Funktionen, Datentypen und -strukturen, Operatoren, etc. gemeint. Pakete (engl. Packages) werden also verwendet, um auf bestimmte Funktionalitäten zuzugreifen, die in R nicht vordefiniert sind und die andere R-Nutzer:innen definiert und veröffentlicht haben. Um darauf zuzugreifen, müssen R Pakete zuerst installiert und danach geladen werden. Die Funktionen, die wir bisher kennengelernt haben, waren alle in R vordefiniert. Wir mussten deswegen kein Paket installieren und laden, um sie zu nutzen. In den R Dokumentationsseiten kann man in R vordefinierte Funktionen daran erkennen, dass neben dem Funktionsnamen in der linken oberen Ecke der Dokumentationsseite das Wort “base” steht. Das steht für “base R”, es handelt sich also um eine R-Basisfunktion. Bei Funktionen aus Paketen steht dort entsprechend der Paketname. Paketname auf einer R Dokumentationsseite: “base” steht für alle in R vordefinierten Funktionen 4.11 Pakete installieren R Pakete können mithilfe der Funktion install.packages() installiert werden. Die Funktion nimmt entweder einen einzelnen Paketnamen als Argument oder einen character-Vektor, der mehrere Paketnamen enthält. # Paket installieren install.packages(&quot;quanteda&quot;) # mehrere Pakete gleichzeitig installieren install.packages(c(&quot;quanteda&quot;, &quot;readtext&quot;)) Achtung: Manchmal wird auf der Konsole (RStudio Fenster R Console) bei der Installation von Paketen eine Meldung der Art “Do you want to install from sources the package which needs compilation? (Yes/no/cancel)” ausgegeben. In diesem Fall müsst ihr einfach no eingeben und auf Enter drücken. 4.12 Pakete laden Installierte Pakete müssen immer am Anfang eines R Skripts geladen werden, bevor sie verwendet werden können: library(quanteda) library(readtext) Wenn nur eine einzige oder einige wenige Funktionen aus einem Paket benötigt werden, können diese auch augerufen werden, ohne dass direkt das gesamte Paket geladen wird: quanteda::tokens(&quot;Guten Morgen&quot;) ## Tokens consisting of 1 document. ## text1 : ## [1] &quot;Guten&quot; &quot;Morgen&quot; Die Angabe des Namens des Pakets beim Aufruf von Funktionen aus Paketen erleichtert dabei außerdem, zwischen R base-Funktionen und Funktionen aus Paketen zu unterscheiden und stellt sicher, dass bei mehreren geladenen Paketen nicht versehentlich eine gleichnamige Funktion aus einem anderen Paket aufgerufen wird. 4.13 Wozu werden Pakete verwendet? R Pakete werden wir im Rahmen dieses Seminars vor allem dazu verwenden, um auf zusätzliche Funktionen zuzugreifen, die in R nicht vordefiniert sind, die also nicht zu den R-Basisfunktionen gehören. Das Paket quanteda, das wir vorhin installiert haben, bietet zum Beispiel eine Funktion, die character, die aus mehreren Wörtern bestehen, automatisch in sogenannte Tokens umwandelt (was das ist, lernen wir in der Sitzung zur Textanalyse): lyrics &lt;- &quot;My mind won&#39;t let me rest Voice in my head I hear what it said I can&#39;t trust a thing If I picked up and left How fast did you forget? Resting while I&#39;m inside your presence I don&#39;t want to think nothing bad This time I won&#39;t This time I won&#39;t&quot; # Aufruf der Funktion tokens() aus dem Paket quanteda lyrics_toks &lt;- quanteda::tokens(lyrics) print(lyrics_toks) ## Tokens consisting of 1 document. ## text1 : ## [1] &quot;My&quot; &quot;mind&quot; &quot;won&#39;t&quot; &quot;let&quot; &quot;me&quot; &quot;rest&quot; ## [7] &quot;Voice&quot; &quot;in&quot; &quot;my&quot; &quot;head&quot; &quot;I&quot; &quot;hear&quot; ## [13] &quot;what&quot; &quot;it&quot; &quot;said&quot; &quot;I&quot; &quot;can&#39;t&quot; &quot;trust&quot; ## [19] &quot;a&quot; &quot;thing&quot; &quot;If&quot; &quot;I&quot; &quot;picked&quot; &quot;up&quot; ## [25] &quot;and&quot; &quot;left&quot; &quot;How&quot; &quot;fast&quot; &quot;did&quot; &quot;you&quot; ## [31] &quot;forget&quot; &quot;?&quot; &quot;Resting&quot; &quot;while&quot; &quot;I&#39;m&quot; &quot;inside&quot; ## [37] &quot;your&quot; &quot;presence&quot; &quot;I&quot; &quot;don&#39;t&quot; &quot;want&quot; &quot;to&quot; ## [43] &quot;think&quot; &quot;nothing&quot; &quot;bad&quot; &quot;This&quot; &quot;time&quot; &quot;I&quot; ## [49] &quot;won&#39;t&quot; &quot;This&quot; &quot;time&quot; &quot;I&quot; &quot;won&#39;t&quot; Verständnisfrage: Im Kapitel 4.5 haben wir die Funktion strsplit() verwendet, um den Songtext lyrics in seine Bestandteile aufzuteilen. Dabei haben wir das Leerzeichen als Trennzeichen zwischen den Wörtern festgelegt. Dadurch wurden Satzzeichen allerdings nicht als einzelne Zeichen erkannt, zum Beispiel bei “forget?”. Wie teilt die Funktion tokens() den Songtext auf? Welche Bestandteile werden dabei erkannt? Pakete können aber zum Beispiel auch zusätzliche Datenstrukturen enthalten. Die quanteda-tokens()-Funktion, die wir gerade ausgetestet haben, erstellt beispielsweise ein sogenanntes “tokens”-Objekt (schauen wir uns noch an): typeof(lyrics_toks) ## [1] &quot;list&quot; class(lyrics_toks) ## [1] &quot;tokens&quot; Ein Paket, das keine zusätzliche Datenstruktur, sondern einen zusätzlichen Operator zur Verfügung stellt, ist daneben das Paket magrittr. Dieses Paket ermöglicht es, den sogenannten Pipe-Operator zu verwenden. Der Pipe-Operator kann verwendet werden, um mehrere Funktionsaufrufe miteinander zu verketten. Wenn dasselbe Objekt nacheinander durch verschiedene Funktionen bearbeitet wird, wäre ohne den Pipe-Operator entweder eine Folge von Anweisungen der folgenden Art notwendig: greeting &lt;- &quot;Guten Tag&quot; greeting &lt;- paste0(greeting, &quot;!&quot;) greeting_toks &lt;- strsplit(greeting, &quot; &quot;) Oder verschachtelte Funktionsaufrufe der Art: greeting &lt;- &quot;Guten Tag&quot; greeting_toks &lt;- strsplit(paste0(greeting, &quot;!&quot;), &quot; &quot;) Mit dem Pipe-Operator können solche aufeinanderfolgenden oder verschachtelten Funktionsaufrufe vereinfacht werden. Um den Operator zu verwenden, muss zunächst das Paket magrittr installiert und geladen werden: install.packages(&quot;magrittr&quot;) library(magrittr) Jetzt kann der Pipe-Operator verwendet werden: greeting &lt;- &quot;Guten Tag&quot; greeting_toks &lt;- greeting %&gt;% paste0(&quot;!&quot;) %&gt;% strsplit(&quot; &quot;) Der Ausdruck x %&gt;% f ist also äquivalent zu f(x). Der Pipe-Operator ist in R sehr weit verbreitet und wir werden immer wieder darauf zurückgreifen. Ihr solltet euch erst einmal nur merken, dass der Pipe-Operator ein zusätzlicher Operator ist, der ermöglicht, Funktionsaufrufe zu verketten. Das Tidyverse Verschiedene R Pakete folgen verschiedenen Philosophien oder Designprinzipien, wie guter Code aussehen sollte, und welche Datenstrukturen für welche Aufgaben verwendet werden sollten. Deswegen sind Pakete, die denselben Prinzipien folgen und dieselben Datenstrukturen verwenden untereinander kompatibler und Code, der mithilfe von Funktionen aus verschiedenen Paketen geschrieben ist, unterscheidet sich mitunter stark von Code, der nur R-Basisfunktionen nutzt. Das sogenannte Tidyverse ist eine Sammlung von R Paketen, die alle denselben Designprinzipien folgen und dieselben Datenstrukturen verwenden. Auch das Paket magrittr ist Teil des Tidyverse. Innerhalb des Tidyverse wird stets der Pipe-Operator verwendet, um Funktionsaufrufe zu verketten, und es gibt für viele R Base Funktionen eigene Tidyverse-Funktionen, die dasselbe machen, aber auf eine Weise, die mit den Prinzipien des Tidyverse übereinstimmt. Beispielsweise gibt es im Tidyverse anstelle der apply-Funktionen eine Reihe von Tidyverse-Funktionen, die genau wie die apply-Funktionen nicht vektorisierte Funktionen vektorisieren (die map-Funktionen). Wir werden in diesem Seminar nicht das gesamte Tidyverse behandeln, aber später werden wir die beiden Tidyverse-Pakete ggplot2 und stringr kennenlernen. Zuletzt solltet ihr wissen, dass manche Pakete sogar komplette Datensätze oder Korpora (lernen wir noch) enthalten, die zusammen mit dem Rest des Pakets heruntergeladen werden. Quanteda stellt beispielsweise zu Testzwecken ein komplettes Korpus aus Reden von US-Präsidenten zur Verfügung: # Einen Datensatz kann man laden, indem man einfach den Namen des Datensatzes eingibt. Die Funktion head() gibt die ersten fünf Zeilen eines Dataframes aus. Die Funktion summary() gibt einen Dataframe mit Metadaten zu einem bestimmten Objekt zurück. Wenn Funktionsaufrufe verschachtelt werden, wird immer zuerst die innere Funktion ausgeführt, und dann die äußere. head(summary(quanteda::data_corpus_inaugural)) ## Text Types Tokens Sentences Year President FirstName ## 1 1789-Washington 625 1537 23 1789 Washington George ## 2 1793-Washington 96 147 4 1793 Washington George ## 3 1797-Adams 826 2577 37 1797 Adams John ## 4 1801-Jefferson 717 1923 41 1801 Jefferson Thomas ## 5 1805-Jefferson 804 2380 45 1805 Jefferson Thomas ## 6 1809-Madison 535 1261 21 1809 Madison James ## Party ## 1 none ## 2 none ## 3 Federalist ## 4 Democratic-Republican ## 5 Democratic-Republican ## 6 Democratic-Republican 4.14 Welche Pakete gibt es denn alles? Wenn ihr nach einer bestimmten Funktionalität sucht, dann empfiehlt es sich, zunächst auf der Seite https://rdrr.io/ nach einem Stichwort zu suchen. Diese Seite durchsucht verschiedene Online-Plattformen, auf denen R Nutzer:innen ihre Pakete veröffentlicht haben. Die offizielle Veröffentlichungsplattform für R Pakete heißt CRAN. Die Funktion install.packages() installiert deswegen per Default nur Pakete, die über CRAN veröffentlicht wurden. Wir haben ja vorhin eine Funktion increment_value() definiert, die zu einer beliebigen Zahl 1 addiert. Diese Operation nennt man auch “Inkrementieren”. Das Inkrementieren ist eine Operation, die sehr viele Menschen sehr oft verwenden. Wir können uns deswegen sicher sein, dass schon ein:e ander:e R Nutzer:in diese Funktion definiert hat und im Rahmen von einem R Paket veröffentlicht hat. Und tatsächlich: Wenn wir auf https://rdrr.io/ nach “increment” suchen, werden direkt mehrere Pakete vorgeschlagen, die eine “increment”-Funktion enthalten. Es haben also schon einige R Nutzer:innen Inkrementierungsfunktionen definiert und im Rahmen von Paketen anderen Nutzer:innen bereitgestellt. Die increment_value()-Funktion von vorhin würden wir also in der Praxis eigentlich nicht selbst defnieren, sondern stattdessen aus einem Paket installieren. Zu den meisten Paketen gibt es eigene Dokumentationsseiten, die von den R Nutzer:innen gepflegt werden, die die Pakete entwickelt haben. Um zu verstehen, welche Funktionalitäten ein bestimmtes Paket zur Verfügung stellt, solltet ihr euch die Dokumentationsseiten zu dem Paket durchlesen. Dokumentationsseiten zum Paket quanteda: https://quanteda.io/ Dokumentationsseiten zum Paket magrittr: https://magrittr.tidyverse.org/ Unter dem Menüpunkt “Reference” auf den quanteda-Seiten findet ihr zum Beispiel eine Liste aller Datensätze und Funktionen, welche das Paket zur Verfügung stellt. Dependencies Fast alle R Pakete nutzen selbst Funktionen aus anderen Paketen. Zum Beispiel gibt es auch außerhalb des Tidyverse Pakete, welche in ihren Funktionsdefinitionen den Pipe-Operator verwenden und dazu auf das magrittr-Paket zurückgreifen. Wenn ein Paket A auf Funktionalitäten aus einem anderen Paket B zurückgreift, dann nennt man das Paket B eine “Dependency” von Paket A. Wenn ihr ein Paket installiert, wird deswegen oft automatisch eine Reihe weiterer Pakete installiert. Das sind die Dependencies des Pakets, das ihr installieren wollt. Quellen Venables, W.N. and Smith, D.M. and the R Core Team. An Introduction to R, https://cran.r-project.org/doc/manuals/r-release/R-intro.pdf Wickham, Hadley. The Tidyverse Style Guide, https://style.tidyverse.org/ Riepl, Wolf. R-Code beschleunigen: Schleifen vs. Vektorisierung vs. Lookup-Tables, https://statistik-dresden.de/archives/15332 Wickham, Hadley and Grolemund, Garrett (2017). R for Data Science: Functions, https://r4ds.had.co.nz/functions.html Wickham, Hadley. Advanced R. Chapter 6: Functions. Function Components, https://adv-r.hadley.nz/functions.html#fun-components Wickham, Hadley. Advanced R. Chapter 6: Functions. Lexical Scoping, https://adv-r.hadley.nz/functions.html#lexical-scoping Wickham, Hadley and Grolemund, Garrett (2017). R for Data Science: Iteration. The Map Functions, https://r4ds.had.co.nz/iteration.html#the-map-functions Wickham, Hadley (2019). Advanced R. Ch. 7.4.2: The Function Environment, https://adv-r.hadley.nz/environments.html#function-environments Benoit, Kenneth and Watanabe, Kohei. Quanteda 4.0.0: Reference, https://quanteda.io/reference/index.html Benoit, Kenneth and Watanabe, Kohei. Quanteda: Quantitative Analysis of Textual Data, https://quanteda.io Wickham, Hadley and Grolemund, Garrett (2017). R for Data Science: Pipes, https://r4ds.had.co.nz/pipes.html Bache, Stefan Milton and Wickham, Hadley. Magrittr 2.0.3 Dokumentation, https://magrittr.tidyverse.org/ "],["textanalyse-i-korpus-tokens-daten-und-dateien.html", "5 Textanalyse I: Korpus, Tokens, Daten und Dateien 5.1 Was sind eigentlich Daten? 5.2 Korpus, Tokens und Types 5.3 Vom Korpus zur Analyse 5.4 Überblick: Textanalyse mit Quanteda 5.5 Textdateien einlesen 5.6 Character Encodings 5.7 Quanteda corpus-Objekte 5.8 Quanteda tokens-Objekte 5.9 Quanteda DFM-Objekte 5.10 Daten schreiben Quellen", " 5 Textanalyse I: Korpus, Tokens, Daten und Dateien 5.1 Was sind eigentlich Daten? Most of my colleagues in literary and cultural studies would not necessarily speak of their objects of study as “data.” If you ask them what it is they are studying, they would rather speak of books, paintings and movies; of drama and crime fiction, of still lives and action painting; of German expressionist movies and romantic comedy. […] However, in the humanities just as in other areas of research, we are increasingly dealing with “data.” Quelle: Christoph Schöch (2013). Clean? Smart? Messy? Data in the Humanities, in: Journal of Digital Humanities 2, no. 3 In den Geisteswissenschaften wird der Begriff “Daten” kaum verwendet, aber in den Digital Humanities allgemein und besonders in der Textanalyse sind “Daten” allgegenwärtig. Auch in diesem Seminar haben wir bereits “Datentypen” und “Datenstrukturen” kennengelernt. Aber was sind denn eigentlich geisteswissenschaftliche Daten? Und was sind Textdaten, oder anders formuliert: Wie wird eine Textdatei zu Daten, die in R repräsentiert, bearbeitet und ausgewertet werden können? Um uns dem Begriff anzunähern, betrachten wir zwei Passagen aus Christoph Schöchs Aufsatz “Big? Smart? Clean? Messy? Data in the Humanities” (2013). Schöch fasst zunächst Diskussionen zur Begriffsbestimmung in den Digital Humanities zusammen: Some practitioners of digital humanities, notably Joanna Drucker, have argued that the term “data” is actually inadequate. And indeed, the term’s etymology seems problematic in the context of the humanities: it comes from the Latin datum, which means “that which is given.” This means it carries with it the meaning of an observer-independent fact which cannot be challenged in itself. Johanna Drucker prefers to speak of “capta” instead of data, literally “that which has been captured or gathered”, underlining the idea that even the very act of capturing data in the first place is oriented by certain goals, done with specific instruments, and driven by a specific attention to a small part of what could have been captured given different goals and instruments. In other words, capturing data is not passively accepting what is given, but actively constructing what one is interested in. (Schöch 2013) Und schlägt dann eine eigene Definition für den Begriff “Daten” vor: Data in the humanities could be considered a digital, selectively constructed, machine-actionable abstraction representing some aspects of a given object of humanistic inquiry. (Schöch 2013) Geisteswissenschaftliche Daten sind also erst einmal ganz allgemein “digitale Abstraktionen”, die Aspekte eines (Forschungs-)Objekts repräsentieren. Sie sind dabei nicht einfach “gegeben”, sondern sie werden aktiv von Forscher:innen im Hinblick auf eine bestimmte Fragestellung konstruiert und mithilfe von ganz konkreten Methoden nach bestimmten Regeln gesammelt. Vielleicht erinnert euch das aus die Lektüre aus der ersten Woche: Eine ganz ähnliche Idee haben auch die Autor:innen von “Mapping Texts” mit ihrem Gegenbegriff “Mapping” zum gängigen “Mining” formuliert (Stolz/Taylor 2024). Je nachdem, wie die so gesammelten Daten organisiert sind, kann zwischen strukturierten und unstrukturierten Daten unterschieden werden: Structured data is typically held in a database in which all key/value pairs have identifiers and clear relations and which follow an explicit data model. Plain text is a typical example of unstructured data, in which the boundaries of individual items, the relations between items, and the meaning of items, are mostly implicit. Data held in XML files is an example of semi-structured data, which can be more or less strictly constrained by the absence or presence of a more or less precise schema. (Schöch 2013) Zusätzlich kann zwischen Daten und Metadaten unterschieden werden: […] “data” refers to the part of a file or dataset which contains the actual representation of an object of inquiry, while the term “metadata” refers to data about that data: metadata explicitly describes selected aspects of a dataset, such as the time of its creation, or the way it was collected, or what entity external to the dataset it is supposed to represent. (Schöch 2013) Aber was sind denn ganz konkret die Daten, mit denen wir bei der Textanalyse zu tun haben? Sind diese Daten strukturiert, unstrukturiert oder semi-strukturiert? Und was sind “Metadaten” von Textdaten? 5.2 Korpus, Tokens und Types In der computergestützten bzw. algorithmischen Textanalyse gibt es eine Reihe von Begriffen, um zwischen verschiedenen Organisationsebenen von Textdaten zu unterscheiden. In den folgenden Sitzungen zur Textanalyse werden die folgenden Begriffe immer wieder vorkommen: Korpus: Texte oder andere Objekte, die auf eine bestimmte Weise mit einem Forschungsziel oder im Hinblick auf einen bestimmten Aspekt gesammelt wurden. Bei Textkorpora kann das beispielsweise die Textsorte, Epoche oder Autor:in sein (s. forText). “Eine nach bestimmten Regeln geordnete und nach Auswahlkriterien zusammengestellte Sammlung von Texten” (Riebling 2019, S. 152). Dabei ist wichtig zu beachten, dass es von der Forschungsfrage, die auf der Grundlage eines Korpus beantwortet werden soll, abhängt, ob die Zusammenstellung des Korpus sinnvoll ist oder nicht. Jedes Korpus hat blinde Flecken und Auslassungen und spiegelt immer eine bestimmte Perspektive wieder. Ein “neutrales” Korpus gibt es in diesem Sinne nicht (Grimmer et al. 2022, S. 35-37). Tokens: Vorkomnisse von Wörtern oder Äußerungen in Texten (s. forText) Types: Typen von Wörtern oder Äußerungen in Texten (s. forText) Document-Term-Matrix (kurz DTM, oder Document-Feature-Matrix, DFM): Eine numerische Repräsentation eines Textkorpus als Matrix, bei der jede Zeile einem Satz, Text oder einer anderen Analyseeinheit (“document”) entspricht, und jede Spalte einem Token oder Type (“term” bzw. “feature”). In den Zellen wird angezeigt, ob bzw. wie häufig jedes Token oder Type in einem Dokument vorkommt (s. Jünger/Gärtner 2023; Van Atteveldt 2022). Achtung Es heißt “das Korpus” und nicht “der Korpus”. Wie verhalten sich also die Begriffe “Korpus”, “Tokens” und “Types” zum Begriff der Daten? Textkorpora liegen zunächst als Dateien vor, z.B. als PDF-Dateien, XML-Dateien oder Plaintext-Dateien. Diese Dateien selbst sind (nach unserer Definition) noch keine Daten. Damit der Text in R analysiert werden kann, muss der Computer den Text aus den Dateien einlesen können, und das geht nur, wenn der Text in maschinenlesbarer Form vorliegt. Plaintext-Dateien (also Dateien mit der Dateiendung .txt) und XML-Dateien (lernen wir noch) sind zum Beispiel immer maschinenlesbar, während ein Foto eines Textes oder ein Text, der eingescant und als PDF-Datei gespeichert wurde, nicht maschinenlesbar sind. Um solche Texte maschinenlesbar zu machen, müssen komplexe Verfahren der optischen Zeichenerkennung (OCR) angewandt werden. In diesem Seminar werden wir ausschließlich mit bereits maschinenlesbaren Texten arbeiten, und zwar mit Plaintext- und XML-Dateien. Ein Korpus kann direkt aus Plaintext- oder XML-Dateien in R eingelesen werden. Beim Einlesen von Plaintext-Dateien können Metadaten zu jedem Text aus dem Dateinamen extrahiert werden, zum Beispiel der Name der Autor:in, das Publikationsjahr und der Titel eines Textes. Der Text selbst repräsentiert die eigentlichen Daten, die noch unstrukturiert vorliegen: In einem Korpus von Texten verschiedener Autor:innen können wir zum Beispiel davon ausgehen, dass sich das verwendete Vokabular unterscheidet oder dass vielleicht ein:e Autor:in im Schnitt kürzere Sätze schreibt als ein:e andere:r, aber diese Merkmale sind implizit und liegen nicht in strukturierter Form vor. Welche Merkmale oder Aspekte uns interessieren, hängt wiederum von der Auswahl der Texte und unserer Forschungsfrage ab; wir finden also diese Merkmale nicht einfach als “Daten” vor. Wenn Texte dagegen aus XML-Dateien eingelesen werden, ist der Text bereits vor dem Einlesen teilweise strukturiert (oder “semi-strukturiert”) und mit Metainformationen versehen. Darauf kommen wir in der Sitzung zu XML-TEI noch einmal zurück. Text wird im Computer als Abfolge von Zeichen abgebildet. In R ist eine Abfolge von Zeichen ein Objekt vom Typ character. Wie wir bereits gesehen haben, kann aber auf Zeichen in R nicht einzeln zugegriffen werden. Verschiedene Wörter bilden dieselbe Zeichenkette und können nicht unterschieden werden. Deswegen wird Text tokenisiert: Das Tokenisieren, also das Zerlegen des Textes in sinnvolle Einheiten (Tokens), ermöglicht zum einen den Zugriff auf einzelne Wörter oder Äußerungen im Text, und zum anderen deren quantitative Auswertung. Was genau eine Einheit (also ein Wort oder eine Äußerung) in einem Text bildet, ist jedoch kontextabhängig: In einem Korpus von Social Media Posts zum Beispiel hat das Rautezeichen eine besondere Bedeutung und Raute-Wortkombinationen wie #digitalhumanities bilden ein Token. Aber das Rautezeichen kann in einem anderen Kontext etwas ganz anderes bedeuten; zum Beispiel kommt es auch in URLs vor, um Ankerelemente zu kennzeichnen. Ein Punkt kann das Ende eines Satzes kennzeichnen, oder er ist Teil eines Titels wie Prof. oder Mr. Nach welchen Regeln ein Text tokenisiert werden soll und was dabei als Token gezählt wird, hängt nicht zuletzt auch von der Forschungsfrage ab. In seinem Werk “Enumerations: Data and Literary Study” hat Andrew Piper beispielsweise ein ganzes Kapitel einer quantitativen Analyse der Bedeutung von Satzzeichen in der Lyrik gewidment: Ein Satzzeichen ist für eine solche Analyse offensichtlich ein sehr wichtiges Token. In anderen Analysen spielen Satzzeichen dagegen gar keine Rolle. Schon beim Tokenisieren treffen Forscher:innen also aktive Entscheidungen, wie Textdaten strukturiert und repräsentiert werden: sie konstruieren die Daten und finden sie nicht einfach vor. In R kann ein tokenisierter Text als spezieller Vektor dargestellt werden, bei dem jedes Token ein Element bildet. Im quanteda-Kontext wird dazu ein tokens-Objekt verwendet: Ein tokens-Objekt bildet ein tokenisiertes Korpus im Grunde als eine Liste von Vektoren ab, wobei jedes Element der Liste einem Dokument aus dem Korpus entspricht. Die Reihenfolge der Tokens ist für alle Texte in einem tokens-Objekt beibehalten. Es handelt sich dabei lediglich um eine Repräsentation von Texten als Abfolge von Tokens (also als “string of words”). Ein weiterer Abstraktionsschritt ist die numerische Repräsentation von Texten als Ansammlung von Tokens ohne festgelegte Reihenfolge (also als “bag of words”). Wie wir bereits gesehen haben, kann eine Document-Term-Matrix bzw. eine Document-Feature-Matrix (DFM) verwendet werden, um ein Korpus auf diese Weise darzustellen. Die Textdaten liegen als DFM strukturiert vor: Die Beziehung zwischen Dokumenten und Tokens (oder Types) ist durch die Spalten und Zeilen klar definiert und wird durch die Angabe, ob bzw. wie oft jedes Token vorkommt, zusätzlich quantifiziert. Bildlich kann man sich den Zusammenhang zwischen Korpus, Tokens und DFM so vorstellen: Dabei muss jedoch beachtet werden, dass die Zeilen in einer DFM wie eingangs erwähnt nicht unbedingt die tatsächlichen Dokumente aus dem Korpus repräsentieren müssen. Manchmal werden auch kleinere Einheiten für die Analyse verwendet, zum Beispiel Sätze oder andere Segmente. Verständnisfragen: Welche Zeichen bilden jeweils inhaltlich zusammenhängende Einheiten in diesen beiden Tweets von Greta Thunberg (der viertmeistgelikte Tweet aller Zeiten laut Wikipedia) und Andrew Tate? Angenommen, die beiden Tweets werden so tokenisiert, dass die in der vorigen Frage identifizierten Einheiten Tokens bilden. Wie viele Tokens hat der Tweet von Greta Thunberg? Wie viele Types? Wie würde eine Document-Feature-Matrix für die beiden Tweets aussehen, wenn die Zeilen jeweils den ersten Satz aus den beiden Tweets repräsentieren? 5.3 Vom Korpus zur Analyse Wir haben bereits gesehen, dass sowohl die Auswahl und Zusammenstellung des Korpus als auch die Wahl eines Verfahrens zum Tokenisieren der Texte Entscheidungen voraussetzen, bevor wir überhaupt mit der eigentlichen Analyse begonnen haben. Also wo beginnt man bei einem Textanalyseprojekt? Wie trifft man diese Entscheidungen? Es gibt verschiedene Zugänge, die bereits in den Lektüren zur ersten Sitzung angedeutet wurden. Zur Erinnerung: Evelyn Gius und Janina Jacke haben zwischen “explorativen” und “konfirmatorischen” Methoden unterschieden (Gius/Jacke, S. 10f.). Beim explorativen Zugriff wird ein Korpus demnach mit programmatischen Methoden untersucht, um über die geänderte oder auch entfremdete Perspektive eine Fragestellung zu entwickeln, der im Anschluss mithilfe quantitativer oder aber auch “klassischer” qualitativer Analysemethoden nachgegangen werden kann. Beim konfirmatorischen Zugriff steht dagegen die Fragestellung vorab fest und es werden ganz gezielt Methoden der quantitativen Textanalyse angewandt, um eine Hypothese zu testen. Bei diesem Zugriff ist eine vorsichtige und kritische Operationalisierung der Fragestellung notwendig. Dem Begriff Operationalisierung seid ihr im Text von Axel Pichler und Nils Reiter begegnet: Operationalisierung ist der “Arbeitsprozess, einem theoretischen Begriff messbare Textoberflächenphänomene zuzuordnen” (Pichler/Reiter 2021, S. 12), also das Werkzeug, mit dem Fragestellungen von den “klassischen” in die digitalen Geisteswissenschaften überführt werden können. Der Operationalisierungsprozess ist oft das schwierigste an der gesamten Textanalyse, denn dabei müssen laut Pichler und Reiter sowohl die “mitbestimmenden literaturtheoretischen Hintergrundannahmen” (oder andere fachspezifische theoretische Hintergründe) als auch die “Hintergrundannahmen der algorithmischen Textanalyse” verstanden und berücksichtigt werden (S. 24). Was bedeutet das? Die Betrachtung von Kookkurrenzen, also von Wörtern, die mit bestimmten Begriffen in einem bestimmten Kontext gemeinsam vorkommen, ist eine gängige Operationalisierung für Fragestellungen, bei denen es um kontextuelle Bedeutungen von Begriffen oder auch den Bedeutungswandel über die Zeit geht. Diese Art der Operationalisierung wurde auch in dem Text von Sayan Bhattacharyya aus der ersten Woche diskutiert (Bhattacharyya 2021, S. 81). Bhattacharyya kritisiert Textanalysemethoden, welche die Häufigkeit einzelner Wörter in einem Korpus über die Zeit hinweg vergleichen, um daran einen Bedeutungswandel festzumachen. Diesem Vorgehen liege ein Verständnis von Wörtern als “neutrale, unproblematische Objekte” zugrunde, die als “Stellvertreter für Konzepte innerhalb einer stabilen Architektur von Konzepten fungieren” (S. 81). Diese theoretische Annahme sei aber für das Verständnis der “polysemischen und mehrsprachigen Textwelt” des Black Atlantic gänzlich ungeeignet, da sich die Bedeutungen europäischer Wörter darin fortlaufend verändern und oft zusätzliche Bedeutungsebenen annähmen (S.82). Bhattacharyya hebt dagegen Analysemethoden, die Kookkurrenzen und Word Embeddings betrachten, positiv hervor: By taking the relationships between words (expressed as cooccurrences of words), rather than the words themselves, as the basic unit of representation, this way of computationally representing text ends up treating the meaning of words as following from the relationships and dependencies between words or sets of words, rather than as properties of the individual words. (S. 81) Bhattacharyyas Artikel ist ein gutes Beispiel dafür, wie kritisch bewertet werden kann, ob die epistemologischen und theoretischen Grundannahmen verschiedener Operationalisierungen einer Fragestellung mit den eigenen Grundannahmen und mit dem spezifischen Korpus, das untersucht werden soll, vereinbar sind. Kookkurrenzen und Word Embeddings werden wir erst in den nächsten Wochen kennenlernen, aber wir können bereits an dieser Stelle einen weiteren, grundlegenden Aspekt hervorheben: Genauso wie geisteswissenschaftliche Fragestellungen unterschiedliche theoretische Hintergründe haben, haben auch verschiedene Analysemethoden selbst verschiedene theoretische (und das bedeutet hier meist mathematische) Hintergründe. Das gemeinsame Vorkommen von zwei Wörtern in einem Text kann nämlich sehr verschieden bestimmt und bewertet werden, je nachdem, welche Grundannahmen vorausgesetzt werden. Zum Beispiel können zwei aufeinanderfolgende Wörter wahrscheinlichkeitstheoretisch betrachtet werden: es wird ein Wort ausgewählt und die bedingte Wahrscheinlichkeit bestimmt, dass darauf ein bestimmtes anderes Wort folgt (siehe dazu z.B. Jurafsky/Martin, N-Gram Language Models, S. 31-37). Dieser Vorgang kann für alle Wörter in einem Korpus wiederholt werden, bis das Wort gefunden wurde, das mit der größten Wahrscheinlichkeit auf das ausgewählte Wort folgt. Alternativ können auch alle Paare von aufeinanderfolgenden Wörtern in einem Korpus gezählt werden und die Wortkombinationen, die im Verhältnis zu anderen besonders häufig vorkommen, werden ausgewählt (siehe dazu den Abschnitt “Kollokationen” in der übernächsten Woche, hier stark vereinfacht). Zwei Wörter können aber auch nach ganz anderen Kriterien ausgewählt werden: zum Beispiel kann die “Nähe” von zwei Wörtern zueinander nicht nur daran bemessen werden, wie wahrscheinlich es ist, dass sie direkt aufeinanderfolgen. Eine andere Möglichkeit, das Verhältnis von zwei Wörtern zueinander zu beschreiben, ist, den Kontext zu vergleichen, in dem sie vorkommen. Dieser Kontext besteht aus allen Wörtern, die mit einem bestimmten Wort gemeinsam vorkommen. Für all diese Wörter wird gezählt, wie oft sie mit dem Wort vorkommen, und die so berechneten Werte können als Vektor im Sinne der linearen Algebra aufgefasst werden (siehe dazu z.B. Jurafsky/Martin, Vector Semantics and Embeddings, S. 31-37, wiederum hier sehr vereinfacht). Die Ähnlichkeit zweier Wort-Vektoren zueinander kann dann als Abstand zweier Vektoren voneinander mit Methoden der linearen Algebra bestimmt werden. Auch die Document-Feature-Matrix selbst kann auf unterschiedliche Weisen interpretiert werden: Justin Grimmer, Margarete Roberts und Brandon Stewart unterscheiden in “Text as Data” zwischen zwei grundlegenden “Hintergrundannahmen der algorithmischen Textanalyse” (wie es Pichler und Reiter ausdrücken): Sie unterscheiden zwischen probabilistischen Ansätzen, denen wahrscheinlichkeitstheoretische Annahmen zugrunde liegen, und algorithmischen Ansätzen, denen Konzepte aus der linearen Algebra zugrunde liegen (Grimmer et al. 2022, S. 60-77). Nach dem wahrscheinlichkeitstheoretischen Modell wird jede Zeile in einer Document Feature Matrix aufgefasst als “random draw from a multinomial distribution”, während das Vektorraummodell jede Zeile interpertiert als “vector in a high-dimensional space” (S. 70). Ihr seht: Der theoretische Hintergrund der Textanalyse mit R ist durchaus komplex und um wirklich tief einzusteigen, kommt man irgendwann nicht mehr darum herum, sich mit den mathematischen Grundlagen der verschiedenen Textanalysemethoden zu beschäftigen. Für dieses Seminar sind keine mathematischen Vorkenntnisse vorausgesetzt, deswegen werde ich zu den Textanalysemethoden immer optionale Kapitel über die mathematischen Hintergründe zur Verfügung stellen, die ihr in solchen ausklappbaren Abschnitten findet: Hier verbirgt sich ein optionaler Abschnitt Das Verhältnis zwischen “wie interessant ist die Analyse” und “verstehe ich überhaupt was hier passiert” lässt sich anfangs vielleicht ungefähr so darstellen: 5.4 Überblick: Textanalyse mit Quanteda Zum Einstieg in die Textanalyse werden wir uns nächste Woche mit ganz einfachen Worthäufigkeiten beschäftigen. Im Kapitel IV: Funktionen und Pakete haben wir bereits das Paket quanteda kennengelernt. Das Paket quanteda bietet eine Vielzahl Funktionen zur quantitativen Analyse von Text sowie spezialisierte Datenstrukturen und sogar Datensätze. Zur Analyse von Worthäufigkeiten werden wir vor allem mit quanteda arbeiten. Bevor wir ganz praktisch in die Textanalyse mit quanteda einsteigen, verschaffen wir uns einen theoretischen Überblick über das Vorgehen: Zur Textanalyse mit quanteda wird gewöhnlich zunächst ein Korpus aus Plaintext-Dateien im RStudio eingelesen. Die Texte werden dann mithilfe verschiedener Funktionen in quanteda-Datenobjekte umgewandelt: In ein quanteda corpus-Objekt, tokens-Objekt und/oder in eine Document Feature Matrix (DFM). Für verschiedene Arten von Analysen verwendet man verschiedene Arten von Objekten. Grundsätzlich wird dabei in Quanteda zwischen Bag-of-Words und String-of-Words Methoden unterschieden, also zwischen Methoden, bei denen die Reihenfolge der Tokens beibehalten wird (String-of-Words) und jenen, bei denen die Reihenfolge keine Rolle spielt (Bag-of-Words). Bei String-of-Words Methoden werden Texte also als Abfolge von Wörtern behandelt, und bei Bag-of-Words-Methoden als Ansammlung von Wörtern. Da ein tokens-Objekt in quanteda Texte als Abfolge von Wörtern repräsentiert, werden für Analysen, bei denen die Reihenfolge der Tokens eine Rolle spielt, quanteda tokens-Objekte verwendet. Wenn die Reihenfolge keine Rolle spielt, wird eine DFM verwendet, da eine DFM Texte als Ansammlung von Wörtern repräsentiert. Die folgende Überblicksdarstellung illustriert, welche quanteda-Objekte für welche Analysemethoden verwendet werden können: Quelle: https://tutorials.quanteda.io/basic-operations/workflow/ Um auf die quanteda-Funktionen zugreifen zu können, müssen neben dem Paket quanteda weitere Pakete installiert werden. Weil die Pakete alle zusammengehören, werden diese “Unterpakete” auch Module genannt: quanteda: contains all of the core natural language processing and textual data management functions quanteda.textmodels: contains all of the text models and supporting functions, namely the textmodel_*() functions quanteda.textstats: statistics for textual data, namely the textstat_*() functions quanteda.textplots: plots for textual data, namely the textplot_*() functions In der heutigen Stunde werden wir die grundlegenden quanteda-Funktionen und quanteda-Datenstrukturen kennenlernen. Als Beispiel dient uns ein Korpus deutschsprachiger belletristischer Texte aus dem späten 19. und frühen 20. Jahrhundert. Zunächst werden wir das Korpus einlesen, danach werden wir quanteda corpus- und tokens-Objekte und zuletzt eine DFM erstellen. 5.5 Textdateien einlesen Um Dateien in R einzulesen, muss zuerst das Arbeitsverzeichnis gesetzt werden. Das heißt, dass wir dem Computer mitteilen müssen, in welchem Ordner auf unserem Computer sich die Dateien befinden, die wir einlesen wollen. Um das Arbeitsverzeichnis zu setzen, gibt es mehrere Möglichkeiten: # Arbeitsverzeichnis setzen setwd(&quot;/Users/gast/R-Seminar&quot;) # Setzt hier euren eigenen Pfad ein # Backslashes für Windows: # setwd(&quot;C:\\Users\\gast\\R-Seminar&quot;) Alternativ kann das Arbeitsverzeichnis auch über den Tab “Files” im Fenster unten rechts gesetzt werden. Navigiert euch dazu erst in den gewünschten Ordner, klickt dann auf “More” und “Set As Working Directory”. Wenn wir das Arbeitsverzeichnis gesetzt haben, können wir die Dateien einlesen. Auch hier gibt es mehrere Möglichkeiten: Zum Einlesen von Dateien können entweder R-Basisfunktionen verwendet werden oder Funktionen aus einem R Paket. Die Entwickler:innen von quanteda empfehlen, zum Einlesen eines Textkorpus die Funktion readtext() aus dem Paket readtext zu verwenden. Beim Einlesen der Texte mithilfe der readtext()-Funktion können direkt Metadaten aus den Dateinamen extrahiert werden, im Beispiel unten Autor:innennamen, Titel und Publikationsjahre der Texte. Diese Metadaten auf Dokumentenebene heißen im readtext- und quanteda-Kontext dann “docvars”. Wir vergleichen im Folgenden die verschiedenen Einlesefunktionen: # 1. R base Funktionen - Beispiele # multi-purpose Funktion &quot;scan&quot; kafka_1 &lt;- scan(&quot;kafka_verwandlung_1915.txt&quot;, what=&quot;character&quot;, encoding = &quot;UTF-8&quot;, sep=&quot;\\n&quot;) # Alternative nur für Textdateien: readLines kafka_2 &lt;- readLines(&quot;kafka_verwandlung_1915.txt&quot;) # 2. Paket readtext install.packages(&quot;readtext&quot;) library(readtext) # einen Text einlesen und einer Variable zuweisen kafka_3 &lt;- readtext(&quot;kafka_verwandlung_1915.txt&quot;, encoding = &quot;UTF-8&quot;) # zwei Texte einlesen kafka_3 &lt;- readtext(c(&quot;kafka_verwandlung_1915.txt&quot;, &quot;kafka_prozess_1925.txt&quot;), encoding = &quot;UTF-8&quot;) kafka_3 # alle Texte in einem Ordner einlesen ein_korpus &lt;- readtext(&quot;korpus/*.txt&quot;, encoding = &quot;UTF-8&quot;) ein_korpus # Texte in einem Unterordner einlesen noch_ein_korpus &lt;- readtext(&quot;Unterordner/*.txt&quot;, encoding = &quot;UTF-8&quot;) # oder /Unterordner/*.txt noch_ein_korpus # Texte in einem Ordner einlesen und Metadaten aus den Dateinamen extrahieren ger_texte &lt;- readtext(&quot;korpus/*.txt&quot;, docvarsfrom = &quot;filenames&quot;, dvsep = &quot;_&quot;, docvarnames = c(&quot;Autor_in&quot;, &quot;Titel&quot;, &quot;Jahr&quot;), encoding = &quot;UTF-8&quot;) ger_texte # Vergleich typeof(kafka_1) #scan typeof(kafka_2) #readLines typeof(kafka_3) #readtext class(kafka_3) Beachtet, dass die Funktion typeof() angibt, wie ein Objekt intern in R gespeichert ist. Das muss immer eine der grundlegenden R Datenstrukturen sein, die wir in Kapitel II kennengelernt haben. Die Funktion class() dagegen gibt an, wie ein Objekt in R behandelt wird: Das heißt, auch wenn manche Pakete ihre eigenen Datenstrukturen definieren und festlegen, welche Eigenschaften diese haben und Funktionen darauf angewendet werden können, müssen diese Datenstrukturen irgendwie wieder als R Datenstrukturen interpretiert werden, damit sie gespeichert werden können. Während das Objekt kafka_3 also intern als Liste gespeichert ist, handelt es sich dabei eigentlich um einen Dataframe, und ganz genau gesagt um ein readtext-Objekt. Das Objekt teilt also Eigenschaften mit R Dataframes, aber es hat auch weitere spezielle Eigenschaften von readtext-Objekten, und es gibt Funktionen, die nur auf genau diese Art von Objekt angewendet werden können. Verständnisfragen: Was ist der Unterschied zwischen den Objekten, die wir mit readLines(), scan() und readtext() erstellt haben? Welche anderen Unterschiede könnt ihr den R-Dokumentationsseiten zu den Funktionen entnehmen? Bereits nach dem Einlesen können wir uns einen Überblick über das Korpus verschaffen. Dabei können auch die beim Einlesen aus den Dateinamen extrahierten Metadaten zu den einzelnen Texten abgefragt werden. # Alle Texte mit Publikationsjahr 1912 auswählen ger_texte$doc_id[ger_texte$Jahr == 1912] ## character(0) # Wie viele Texte gibt es aus dem Jahr 1912? length(ger_texte$doc_id[ger_texte$Jahr == 1912]) ## [1] 0 # Häufigkeitstabelle der Publikationsjahre table(ger_texte$Jahr) ## ## 1883 1888 1894 1896 1899 1901 1903 1905 1913 1915 1918 1919 1920 1924 1925 1926 ## 1 1 1 1 1 1 2 1 2 1 1 1 1 2 2 1 5.6 Character Encodings Text wird im Computer eigentlich als Abfolge von Zeichen abgebildet, und jedes Zeichen wird im Computer durch eine Zahlenfolge repräsentiert. Wie genau diese Folge aussieht, hängt davon ab, welche Kodierung (Encoding) dazu verwendet wird. Das folgende Beispiel aus Kevin Usheys Beitrag “String Encoding and R” illustriert diesen Umstand: utf8 &lt;- &quot;\\u00fb&quot; # &#39;û&#39; latin1 &lt;- iconv(utf8, to = &quot;latin1&quot;) paste(latin1, &quot;(latin1):&quot;, pryr::bits(latin1)) ## [1] &quot;û (latin1): 11111011&quot; paste(utf8, &quot;(UTF-8) :&quot;, pryr::bits(utf8)) ## [1] &quot;û (UTF-8) : 11000011 10111011&quot; Eine der ersten Kodierungen war ASCII, mit der allerdings nur Zeichen aus dem lateinischen Alphabet, Zahlen und einige Sonderzeichen repräsentiert werden können. Heutzutage gibt es mit Unicode einen international anerkannten Standard-Zeichensatz. Dieser Zeichensatz ordnet nicht nur allen Zeichen im lateinischen Alphabet, sondern allen Zeichen in allen Schriftsprachen und sogar Symbolen wie Emojis einen einzigartigen Zahlenwert zu. Solche Unicode-Zahlenwerte heißen “Codepunkte”. Zeichenketten, die als Unicode-Codepunkte repräsentiert werden, können mithilfe von Kodierungen wie UTF-8 in Zahlenfolgen, die nur aus Nullen und Einsen bestehen (Bytes) umgewandelt werden. R unterstützt mehrere Kodierungen, aber es empfiehlts sich, beim Einlesen und Schreiben von Textdateien die Kodierung UTF-8 zu verwenden. Beim Einlesen der Textdateien in den Beispielen oben haben wir deswegen die readtext-Funktion mit dem zusätzlichen Argument encoding = \"UTF-8\" aufgerufen. Mit der Funktion Encoding() kann nach dem Einlesen überprüft werden, ob das Encoding korrekt erkannt wird: Encoding(ger_texte[1, 2]) ## [1] &quot;UTF-8&quot; Beim Einlesen und Speichern von Dateien muss in R auf die Wahl des richtigen Encodings geachtet werden, insbesondere beim Umgang mit nicht-lateinischen Schriften. Das werden wir später in der Praxis genauer betrachten. 5.7 Quanteda corpus-Objekte Ein Quanteda corpus-Objekt enthält die eingelesenen Texte selbst, sowie Metadaten auf Dokument- und Korpusebene. install.packages(&quot;quanteda&quot;) library(quanteda) # quanteda-Korpusobkjekt erstellen ger_korpus &lt;- corpus(ger_texte) ger_korpus ## Corpus consisting of 20 documents and 3 docvars. ## fontane_briest_1896.txt : ## &quot;In Front des schon seit Kurfürst Georg Wilhelm von der Famil...&quot; ## ## fontane_irrungen_1888.txt : ## &quot;An dem Schnittpunkte von Kurfürstendamm und Kurfürstenstraße...&quot; ## ## fontane_reise_1894.txt : ## &quot;Zu den Eigentümlichkeiten unserer Zeit gehört das Massenreis...&quot; ## ## fontane_stechlin_1899.txt : ## &quot;Im Norden der Grafschaft Ruppin, hart an der mecklenburgisch...&quot; ## ## fontane_wuthenow_1883.txt : ## &quot;In dem Salon der in der Behrenstraße wohnenden Frau v. Caray...&quot; ## ## kafka_amerika_1925.txt : ## &quot;Als der sechzehnjährige Karl Roßmann, der von seinen armen E...&quot; ## ## [ reached max_ndoc ... 14 more documents ] Die Funktion str() kann verwendet werden, um einen Überblick über die Struktur des Objekts zu erhalten. Da ein Quanteda corpus-Objekt neben den Texten selbst auch Metadaten enthält, gibt die str()-Funktion einen Überblick über alle Metadaten. Die Metadaten der einzelnen Dokumente (z.B. Dateinamen, ggf. mithilfe der readtext-Funktion extrahierte docvars) können unter attr(*, \"docvars\") eingesehen werden. attr(*, \"meta\") beschreibt dagegen alle Metadaten auf Korpusebene (z.B. Informationen zu Ort und Zeit der Erstellung des corpus-Objekts). str(ger_korpus) ## &#39;corpus&#39; Named chr [1:20] &quot;In Front des schon seit Kurfürst Georg Wilhelm von der Familie von Briest bewohnten Herrenhauses zu Hohen-Cremm&quot;| __truncated__ ... ## - attr(*, &quot;names&quot;)= chr [1:20] &quot;fontane_briest_1896.txt&quot; &quot;fontane_irrungen_1888.txt&quot; &quot;fontane_reise_1894.txt&quot; &quot;fontane_stechlin_1899.txt&quot; ... ## - attr(*, &quot;docvars&quot;)=&#39;data.frame&#39;: 20 obs. of 6 variables: ## ..$ docname_: chr [1:20] &quot;fontane_briest_1896.txt&quot; &quot;fontane_irrungen_1888.txt&quot; &quot;fontane_reise_1894.txt&quot; &quot;fontane_stechlin_1899.txt&quot; ... ## ..$ docid_ : Factor w/ 20 levels &quot;fontane_briest_1896.txt&quot;,..: 1 2 3 4 5 6 7 8 9 10 ... ## ..$ segid_ : int [1:20] 1 1 1 1 1 1 1 1 1 1 ... ## ..$ Autor_in: chr [1:20] &quot;fontane&quot; &quot;fontane&quot; &quot;fontane&quot; &quot;fontane&quot; ... ## ..$ Titel : chr [1:20] &quot;briest&quot; &quot;irrungen&quot; &quot;reise&quot; &quot;stechlin&quot; ... ## ..$ Jahr : int [1:20] 1896 1888 1894 1899 1883 1925 1920 1925 1919 1913 ... ## - attr(*, &quot;meta&quot;)=List of 3 ## ..$ system:List of 6 ## .. ..$ package-version:Classes &#39;package_version&#39;, &#39;numeric_version&#39; hidden list of 1 ## .. .. ..$ : int [1:3] 4 2 0 ## .. ..$ r-version :Classes &#39;R_system_version&#39;, &#39;package_version&#39;, &#39;numeric_version&#39; hidden list of 1 ## .. .. ..$ : int [1:3] 4 3 3 ## .. ..$ system : Named chr [1:3] &quot;Darwin&quot; &quot;arm64&quot; &quot;lipogg&quot; ## .. .. ..- attr(*, &quot;names&quot;)= chr [1:3] &quot;sysname&quot; &quot;machine&quot; &quot;user&quot; ## .. ..$ directory : chr &quot;/Users/lipogg/Desktop/LV_Textanalyse/textanalyse-mit-r&quot; ## .. ..$ created : Date[1:1], format: &quot;2025-05-20&quot; ## .. ..$ source : chr &quot;data.frame&quot; ## ..$ object:List of 2 ## .. ..$ unit : chr &quot;documents&quot; ## .. ..$ summary:List of 2 ## .. .. ..$ hash: chr(0) ## .. .. ..$ data: NULL ## ..$ user : list() Mit der Funktion summary() können Informationen zu den Texten selbst abgerufen werden. Die Funktion berechnet für jeden Text in einem Korpus die Anzahl der Tokens, der Types und der Sätze und bietet so einen ersten Überblick über das Korpus. # Weitere Informationen abrufen mit der summary()-Funktion ger_info &lt;- summary(ger_korpus) ger_info ## Corpus consisting of 20 documents, showing 20 documents: ## ## Text Types Tokens Sentences Autor_in ## fontane_briest_1896.txt 11846 118213 5875 fontane ## fontane_irrungen_1888.txt 8823 63642 3546 fontane ## fontane_reise_1894.txt 8086 43945 2167 fontane ## fontane_stechlin_1899.txt 16162 156206 8998 fontane ## fontane_wuthenow_1883.txt 8700 50846 2671 fontane ## kafka_amerika_1925.txt 10407 100252 4023 kafka ## kafka_landarzt_1920.txt 3813 15675 663 kafka ## kafka_schloss_1925.txt 11392 133468 4631 kafka ## kafka_strafkolonie_1919.txt 2505 12252 522 kafka ## kafka_urteil_1913.txt 1345 4793 237 kafka ## kafka_verwandlung_1915.txt 3968 22294 720 kafka ## mann_budden_1901.txt 26631 285968 12806 mann ## mann_tonio_1903.txt 5435 26161 1151 mann ## mann_tristan_1903.txt 4085 17475 852 mann ## mann_venedig_1913.txt 7588 29609 1011 mann ## mann_zauberberg_1924.txt 36068 321896 12198 mann ## schnitzler_casanova_1918.txt 7077 43424 1381 schnitzler ## schnitzler_else_1924.txt 2827 19276 1803 schnitzler ## schnitzler_tanzerin_1905.txt 5740 41441 2240 schnitzler ## schnitzler_traumnovelle_1926.txt 5092 27465 1414 schnitzler ## Titel Jahr ## briest 1896 ## irrungen 1888 ## reise 1894 ## stechlin 1899 ## wuthenow 1883 ## amerika 1925 ## landarzt 1920 ## schloss 1925 ## strafkolonie 1919 ## urteil 1913 ## verwandlung 1915 ## budden 1901 ## tonio 1903 ## tristan 1903 ## venedig 1913 ## zauberberg 1924 ## casanova 1918 ## else 1924 ## tanzerin 1905 ## traumnovelle 1926 Die summary()-Funktion gibt einen Dataframe zurück. Es können deswegen alle Zugriffsoperationen und Funktionen auf das Objekt ger_info angewendet werden, die auf Dataframes angewendet werden können: # Minimum und Maximum der Spalten Jahr und Tokens range(ger_info$Jahr) ## [1] 1883 1926 range(ger_info$Tokens) ## [1] 4793 321896 # Anzahl der verschiedenen Autor:innen length(unique(ger_info$Autor_in)) ## [1] 4 # Gesamtzahl der Tokens im ger_korpus Korpus sum(ger_info$Tokens) ## [1] 1534301 # Titel des Textes mit den meisten Tokens ger_info$Titel[ger_info$Tokens == max(ger_info$Tokens)] ## [1] &quot;zauberberg&quot; # Autor:in des Textes mit den meisten Tokens ger_info$Autor_in[ger_info$Tokens == max(ger_info$Tokens)] ## [1] &quot;mann&quot; # Titel des Textes mit einer Tokenanzahl zwischen 250000 und 300000 ger_info$Titel[ger_info$Tokens &gt;= 250000 &amp; ger_info$Tokens &lt;= 300000] ## [1] &quot;budden&quot; Oft ist bei der Textanalyse der Vergleich zwischen verschiedenen Teilkorpora oder Unterkorpora von Interesse, beispielsweise, wenn die Texte verschiedener Autor:innen verglichen werden sollen. Ein Teilkorpus kann unkompliziert nach dem Einlesen der Texte erstellt werden: # Teilkorpus aus Kafka-Texten erstellen mit R Base-Funktionen length(which(ger_korpus$Autor_in == &quot;kafka&quot;)) ## [1] 6 which(ger_korpus$Autor_in == &quot;kafka&quot;) # gibt aus 6 7 8 9 10 11 ## [1] 6 7 8 9 10 11 ger_korpus[6:11] ## Corpus consisting of 6 documents and 3 docvars. ## kafka_amerika_1925.txt : ## &quot;Als der sechzehnjährige Karl Roßmann, der von seinen armen E...&quot; ## ## kafka_landarzt_1920.txt : ## &quot;Der neue Advokat. Wir haben einen neuen Advokaten, den Dr. B...&quot; ## ## kafka_schloss_1925.txt : ## &quot;Es war spätabends, als K. ankam. Das Dorf lag in tiefem Schn...&quot; ## ## kafka_strafkolonie_1919.txt : ## &quot;»Es ist ein eigentümlicher Apparat«, sagte der Offizier zu d...&quot; ## ## kafka_urteil_1913.txt : ## &quot;Es war an einem Sonntagvormittag im schönsten Frühjahr. Geor...&quot; ## ## kafka_verwandlung_1915.txt : ## &quot;Als Gregor Samsa eines Morgens aus unruhigen Träumen erwacht...&quot; # Teilkorpus aus Kafka-Texten erstellen: the quanteda way kafka_korpus &lt;- corpus_subset(ger_korpus, Autor_in == &quot;kafka&quot;) kafka_korpus ## Corpus consisting of 6 documents and 3 docvars. ## kafka_amerika_1925.txt : ## &quot;Als der sechzehnjährige Karl Roßmann, der von seinen armen E...&quot; ## ## kafka_landarzt_1920.txt : ## &quot;Der neue Advokat. Wir haben einen neuen Advokaten, den Dr. B...&quot; ## ## kafka_schloss_1925.txt : ## &quot;Es war spätabends, als K. ankam. Das Dorf lag in tiefem Schn...&quot; ## ## kafka_strafkolonie_1919.txt : ## &quot;»Es ist ein eigentümlicher Apparat«, sagte der Offizier zu d...&quot; ## ## kafka_urteil_1913.txt : ## &quot;Es war an einem Sonntagvormittag im schönsten Frühjahr. Geor...&quot; ## ## kafka_verwandlung_1915.txt : ## &quot;Als Gregor Samsa eines Morgens aus unruhigen Träumen erwacht...&quot; # Teilkorpus erstellen und Korpusinformationen zusammenfassen in einer Zeile kafka_summary &lt;- summary(corpus_subset(ger_korpus, Autor_in == &quot;kafka&quot;)) # Wir können auch stattdessen den Dataframe ger_info nach Kafka-Texten filtern: kafka_summary &lt;- ger_info[ger_info$Autor_in == &quot;kafka&quot;,] # Wie viele Texte umfasst das Kafka-Korpus? View() öffnet im RStudio ein neues Fenster View(kafka_summary) 5.8 Quanteda tokens-Objekte Ein Quanteda tokens-Objekt bildet ein tokenisiertes Korpus als eine Liste von Vektoren ab, wobei jedes Element der Liste einem Dokument aus dem Korpus entspricht. Die Reihenfolge der Tokens ist für alle Texte in einem tokens-Objekt beibehalten. library(quanteda) # quanteda-Tokensobjekt erstellen kafka_toks &lt;- tokens(kafka_korpus) # Print-Funktion muss für quanteda-Objekte angepasst werden: http://quanteda.io/reference/print-quanteda.html print(kafka_toks[1]) # wird nicht komplett angezeigt ## Tokens consisting of 1 document and 3 docvars. ## kafka_amerika_1925.txt : ## [1] &quot;Als&quot; &quot;der&quot; &quot;sechzehnjährige&quot; &quot;Karl&quot; ## [5] &quot;Roßmann&quot; &quot;,&quot; &quot;der&quot; &quot;von&quot; ## [9] &quot;seinen&quot; &quot;armen&quot; &quot;Eltern&quot; &quot;nach&quot; ## [ ... and 100,240 more ] print(kafka_toks[1], max_ntoken = 200) # 200 Tokens anzeigen ## Tokens consisting of 1 document and 3 docvars. ## kafka_amerika_1925.txt : ## [1] &quot;Als&quot; &quot;der&quot; &quot;sechzehnjährige&quot; &quot;Karl&quot; ## [5] &quot;Roßmann&quot; &quot;,&quot; &quot;der&quot; &quot;von&quot; ## [9] &quot;seinen&quot; &quot;armen&quot; &quot;Eltern&quot; &quot;nach&quot; ## [13] &quot;Amerika&quot; &quot;geschickt&quot; &quot;worden&quot; &quot;war&quot; ## [17] &quot;,&quot; &quot;weil&quot; &quot;ihn&quot; &quot;ein&quot; ## [21] &quot;Dienstmädchen&quot; &quot;verführt&quot; &quot;und&quot; &quot;ein&quot; ## [25] &quot;Kind&quot; &quot;von&quot; &quot;ihm&quot; &quot;bekommen&quot; ## [29] &quot;hatte&quot; &quot;,&quot; &quot;in&quot; &quot;dem&quot; ## [33] &quot;schon&quot; &quot;langsam&quot; &quot;gewordenen&quot; &quot;Schiff&quot; ## [37] &quot;in&quot; &quot;den&quot; &quot;Hafen&quot; &quot;von&quot; ## [41] &quot;New&quot; &quot;York&quot; &quot;einfuhr&quot; &quot;,&quot; ## [45] &quot;erblickte&quot; &quot;er&quot; &quot;die&quot; &quot;schon&quot; ## [49] &quot;längst&quot; &quot;beobachtete&quot; &quot;Statue&quot; &quot;der&quot; ## [53] &quot;Freiheitsgöttin&quot; &quot;wie&quot; &quot;in&quot; &quot;einem&quot; ## [57] &quot;plötzlich&quot; &quot;stärker&quot; &quot;gewordenen&quot; &quot;Sonnenlicht&quot; ## [61] &quot;.&quot; &quot;Ihr&quot; &quot;Arm&quot; &quot;mit&quot; ## [65] &quot;dem&quot; &quot;Schwert&quot; &quot;ragte&quot; &quot;wie&quot; ## [69] &quot;neuerdings&quot; &quot;empor&quot; &quot;,&quot; &quot;und&quot; ## [73] &quot;um&quot; &quot;ihre&quot; &quot;Gestalt&quot; &quot;wehten&quot; ## [77] &quot;die&quot; &quot;freien&quot; &quot;Lüfte&quot; &quot;.&quot; ## [81] &quot;›&quot; &quot;So&quot; &quot;hoch&quot; &quot;!&quot; ## [85] &quot;‹&quot; &quot;sagte&quot; &quot;er&quot; &quot;sich&quot; ## [89] &quot;und&quot; &quot;wurde&quot; &quot;,&quot; &quot;wie&quot; ## [93] &quot;er&quot; &quot;so&quot; &quot;gar&quot; &quot;nicht&quot; ## [97] &quot;an&quot; &quot;das&quot; &quot;Weggehen&quot; &quot;dachte&quot; ## [101] &quot;,&quot; &quot;von&quot; &quot;der&quot; &quot;immer&quot; ## [105] &quot;mehr&quot; &quot;anschwellenden&quot; &quot;Menge&quot; &quot;der&quot; ## [109] &quot;Gepäckträger&quot; &quot;,&quot; &quot;die&quot; &quot;an&quot; ## [113] &quot;ihm&quot; &quot;vorüberzogen&quot; &quot;,&quot; &quot;allmählich&quot; ## [117] &quot;bis&quot; &quot;an&quot; &quot;das&quot; &quot;Bordgeländer&quot; ## [121] &quot;geschoben&quot; &quot;.&quot; &quot;Ein&quot; &quot;junger&quot; ## [125] &quot;Mann&quot; &quot;,&quot; &quot;mit&quot; &quot;dem&quot; ## [129] &quot;er&quot; &quot;während&quot; &quot;der&quot; &quot;Fahrt&quot; ## [133] &quot;flüchtig&quot; &quot;bekannt&quot; &quot;geworden&quot; &quot;war&quot; ## [137] &quot;,&quot; &quot;sagte&quot; &quot;im&quot; &quot;Vorübergehen&quot; ## [141] &quot;:&quot; &quot;»&quot; &quot;Ja&quot; &quot;,&quot; ## [145] &quot;haben&quot; &quot;Sie&quot; &quot;denn&quot; &quot;noch&quot; ## [149] &quot;keine&quot; &quot;Lust&quot; &quot;auszusteigen&quot; &quot;?&quot; ## [153] &quot;«&quot; &quot;»&quot; &quot;Ich&quot; &quot;bin&quot; ## [157] &quot;doch&quot; &quot;fertig&quot; &quot;«&quot; &quot;,&quot; ## [161] &quot;sagte&quot; &quot;Karl&quot; &quot;,&quot; &quot;ihn&quot; ## [165] &quot;anlachend&quot; &quot;,&quot; &quot;und&quot; &quot;hob&quot; ## [169] &quot;aus&quot; &quot;Übermut&quot; &quot;,&quot; &quot;und&quot; ## [173] &quot;weil&quot; &quot;er&quot; &quot;ein&quot; &quot;starker&quot; ## [177] &quot;Junge&quot; &quot;war&quot; &quot;,&quot; &quot;seinen&quot; ## [181] &quot;Koffer&quot; &quot;auf&quot; &quot;die&quot; &quot;Achsel&quot; ## [185] &quot;.&quot; &quot;Aber&quot; &quot;wie&quot; &quot;er&quot; ## [189] &quot;über&quot; &quot;seinen&quot; &quot;Bekannten&quot; &quot;hinsah&quot; ## [193] &quot;,&quot; &quot;der&quot; &quot;ein&quot; &quot;wenig&quot; ## [197] &quot;seinen&quot; &quot;Stock&quot; &quot;schwenkend&quot; &quot;sich&quot; ## [ ... and 100,052 more ] Auch ein tokens-Objekt kann mithilfe der Funktion str() untersucht werden. Quanteda tokens-Objekte enthalten neben den Tokens selbst dieselben Metadaten wie quanteda corpus-Objekte. str(kafka_toks) ## List of 6 ## $ kafka_amerika_1925.txt : chr [1:100252] &quot;Als&quot; &quot;der&quot; &quot;sechzehnjährige&quot; &quot;Karl&quot; ... ## $ kafka_landarzt_1920.txt : chr [1:15675] &quot;Der&quot; &quot;neue&quot; &quot;Advokat&quot; &quot;.&quot; ... ## $ kafka_schloss_1925.txt : chr [1:133468] &quot;Es&quot; &quot;war&quot; &quot;spätabends&quot; &quot;,&quot; ... ## $ kafka_strafkolonie_1919.txt: chr [1:12252] &quot;»&quot; &quot;Es&quot; &quot;ist&quot; &quot;ein&quot; ... ## $ kafka_urteil_1913.txt : chr [1:4793] &quot;Es&quot; &quot;war&quot; &quot;an&quot; &quot;einem&quot; ... ## $ kafka_verwandlung_1915.txt : chr [1:22294] &quot;Als&quot; &quot;Gregor&quot; &quot;Samsa&quot; &quot;eines&quot; ... ## - attr(*, &quot;class&quot;)= chr &quot;tokens&quot; ## - attr(*, &quot;types&quot;)= chr [1:19780] &quot;Als&quot; &quot;der&quot; &quot;sechzehnjährige&quot; &quot;Karl&quot; ... ## - attr(*, &quot;padding&quot;)= logi TRUE ## - attr(*, &quot;docvars&quot;)=&#39;data.frame&#39;: 6 obs. of 6 variables: ## ..$ docname_: chr [1:6] &quot;kafka_amerika_1925.txt&quot; &quot;kafka_landarzt_1920.txt&quot; &quot;kafka_schloss_1925.txt&quot; &quot;kafka_strafkolonie_1919.txt&quot; ... ## ..$ docid_ : Factor w/ 6 levels &quot;kafka_amerika_1925.txt&quot;,..: 1 2 3 4 5 6 ## ..$ segid_ : int [1:6] 1 1 1 1 1 1 ## ..$ Autor_in: chr [1:6] &quot;kafka&quot; &quot;kafka&quot; &quot;kafka&quot; &quot;kafka&quot; ... ## ..$ Titel : chr [1:6] &quot;amerika&quot; &quot;landarzt&quot; &quot;schloss&quot; &quot;strafkolonie&quot; ... ## ..$ Jahr : int [1:6] 1925 1920 1925 1919 1913 1915 ## - attr(*, &quot;meta&quot;)=List of 3 ## ..$ system:List of 5 ## .. ..$ package-version:Classes &#39;package_version&#39;, &#39;numeric_version&#39; hidden list of 1 ## .. .. ..$ : int [1:3] 4 2 0 ## .. ..$ r-version :Classes &#39;R_system_version&#39;, &#39;package_version&#39;, &#39;numeric_version&#39; hidden list of 1 ## .. .. ..$ : int [1:3] 4 3 3 ## .. ..$ system : Named chr [1:3] &quot;Darwin&quot; &quot;arm64&quot; &quot;lipogg&quot; ## .. .. ..- attr(*, &quot;names&quot;)= chr [1:3] &quot;sysname&quot; &quot;machine&quot; &quot;user&quot; ## .. ..$ directory : chr &quot;/Users/lipogg/Desktop/LV_Textanalyse/textanalyse-mit-r&quot; ## .. ..$ created : Date[1:1], format: &quot;2025-05-20&quot; ## ..$ object:List of 7 ## .. ..$ unit : chr &quot;documents&quot; ## .. ..$ what : chr &quot;word&quot; ## .. ..$ tokenizer : chr &quot;tokenize_word4&quot; ## .. ..$ ngram : int 1 ## .. ..$ skip : int 0 ## .. ..$ concatenator: chr &quot;_&quot; ## .. ..$ summary :List of 2 ## .. .. ..$ hash: chr(0) ## .. .. ..$ data: NULL ## ..$ user : list() Auch aus Quanteda tokens-Objekten kann ein Teilkorpus gebildet werden: # Tokens-Objekt nach Kafka-Texten filtern kafka_tokens &lt;- tokens_subset(ger_toks, Autor_in == &quot;kafka&quot;) 5.9 Quanteda DFM-Objekte Für die meisten Analysemethoden wird eine sogenannte Document-Feature-Matrix (DFM) verwendet. Wie wir bereits gesehen haben, ist eine DFM eine Matrix, deren Spalten “Features” und deren Zeilen Dokumente repräsentieren. In unserem Fall sind die Features Tokens und die Dokumente sind die Texte des Korpus. library(quanteda) # DFM erstellen kafka_dfm &lt;- dfm(kafka_toks) kafka_dfm ## Document-feature matrix of: 6 documents, 18,490 features (71.75% sparse) and 3 docvars. ## features ## docs als der sechzehnjährige karl roßmann , von ## kafka_amerika_1925.txt 444 1965 1 1107 54 8844 482 ## kafka_landarzt_1920.txt 65 311 0 0 0 1241 64 ## kafka_schloss_1925.txt 629 1964 0 0 0 13256 672 ## kafka_strafkolonie_1919.txt 54 447 0 0 0 966 46 ## kafka_urteil_1913.txt 15 90 0 0 0 391 22 ## kafka_verwandlung_1915.txt 133 426 1 0 0 1862 93 ## features ## docs seinen armen eltern ## kafka_amerika_1925.txt 146 11 22 ## kafka_landarzt_1920.txt 5 4 2 ## kafka_schloss_1925.txt 79 17 15 ## kafka_strafkolonie_1919.txt 16 2 0 ## kafka_urteil_1913.txt 12 1 2 ## kafka_verwandlung_1915.txt 27 3 27 ## [ reached max_nfeat ... 18,480 more features ] 5.10 Daten schreiben Alle Objekte, die wir bisher erstellt haben, existieren nur in unserer RStudio Umgebung. Es gibt verschiedene Möglichkeiten, diese Objekte zu speichern. Wenn Objekte in einem eigenen Ordner (=“Verzeichnis”) gespeichert werden sollen, kann dieser direkt aus R heraus erstellt werden: # Neuen Ordner erstellen: falls bereits ein Ordner &quot;output&quot; existiert, wird dieser gelöscht unlink(&quot;output&quot;, recursive = TRUE) dir.create(&quot;output&quot;) setwd(paste0(getwd(), &quot;/output&quot;)) getwd() Tabellarische Daten (Dataframes) können zum Beispiel in csv-Dateien gespeichert werden: # Dataframe in csv-Datei schreiben write.csv2(ger_info, &quot;ger_info.csv&quot;, fileEncoding=&quot;UTF-8&quot;) # Können wir verhindern, dass die Zeilenindizes als eigene Spalte gespeichert werden? ?write.csv2 # Ja, mit dem Parameter row.names: write.csv2(ger_info, &quot;ger_info.csv&quot;, row.names=FALSE, fileEncoding=&quot;UTF-8&quot;) Objekte, die für die Weiterverarbeitung in R gedacht sind, wie zum Beispiel quanteda tokens-Objekte oder auch der ger_info Dataframe, können außerdem in R-internen Datenformaten gespeichert werden: # R-interne Datenformate: R Objekte speichern und laden # rds: Ein Objekt in einer Datei speichern saveRDS(ger_info, file=&quot;ger_info.rds&quot;) saveRDS(kafka_toks, file=&quot;kafka_toks.rds&quot;) # RData und rda : Mehrere Objekte in einer Datei speichern save(kafka_1, kafka_2, kafka_3, file=&quot;uebung.rda&quot;) save(kafka_1, kafka_2, kafka_3, file=&quot;uebung.RData&quot;) RDS-, RDA- und RData-Dateien können später eingelesen werden mit: ger_info &lt;- readRDS(file=&quot;ger_info.rds&quot;) kafka_toks &lt;- readRDS(file=&quot;kafka_toks.rds&quot;) load(file=&quot;uebung.rda&quot;) load(file=&quot;uebung.RData&quot;) Und csv-Dateien könne eingelesen werden mit: ger_info &lt;- read.csv2(file=&quot;ger_info.csv&quot;, fileEncoding=&quot;UTF-8&quot;) Um Änderungen zu speichern, die wir ggf. an den eingelesenen Texten vorgenommen haben, können wir diese einfach in eine neue Textdatei schreiben: # Textdateien Zeile für Zeile schreiben: writeLines(kafka_1, &quot;kafka_bearbeitet.txt&quot;) # Alternativ mit write.table: Funktioniert auch für Textdateien! write.table(kafka_1, file = &quot;kafka_bearbeitet.txt&quot;, quote=FALSE, col.names=FALSE, row.names=FALSE, fileEncoding=&quot;UTF-8&quot;) Quellen Schöch, Christoph (2013). Clean? Smart? Messy? Data in the Humanities, in: Journal of Digital Humanities 2, no. 3, http://journalofdigitalhumanities.org/2-3/big-smart-clean-messy-data-in-the-humanities/. ForText (2016), Glossar: Type/Token, https://fortext.net/ueber-fortext/glossar/type-token. ForText (2016), Glossar: Korpus, https://fortext.net/ueber-fortext/glossar/korpus. Jünger, J. and Gärtner, C. (2023). Computational Methods für die Sozial- und Geisteswissenschaften. Kapitel 9: Textanalyse, S. 356-359, https://doi.org/10.1007/978-3-658-37747-2_9. Riebling, Jan Rasmus (2019). Methode und Methodologie quantitativer Textanalyse. Kapitel 5: Text und Token, S. 125-160, https://d-nb.info/1188242121/34. Stoltz, Dustin S. und Taylor, Marshall A. (2024). Mapping Texts. Computational Text Analysis for the Social Sciences. Introduction, https://global.oup.com/academic/product/mapping-texts-9780197756881 Lukes, David (2016). How Computers Handle Text: A Gentle but Thorough Introduction to Unicode, https://dlukes.github.io/unicode.html. Van Atteveldt, Wouter, Trilling, Damian und Arcila Calderón, Carlos (2022). Computational Analysis of Communication. Chapter 9: Processing Text, https://cssbook.net/content/chapter09.html. Van Atteveldt, Wouter, Trilling, Damian und Arcila Calderón, Carlos (2022). Computational Analysis of Communication. Chapter 5.2.2: Encodings and Dialects, https://cssbook.net/content/chapter05.html#sec-encodings. Gius, Evelyn und Jacke, Janina (2022). Are Computational Literary Studies Structuralist?, in: Journal of Cultural Analytics 7, no. 4, https://doi.org/10.22148/001c.46662. Pichler, Axel und Reiter, Nils (2021), Zur Operationalisierung literaturwissenschaftlicher Begriffe in der algorithmischen Textanalyse, in: Journal of Literary Theory 15, no. 1-2, https://doi.org/10.1515/jlt-2021-2008. Bhattacharyya, Sayan (2021). Text Analysis for Thought in the Black Atlantic, in: Kelly Baker Josephs und Roopika Risam, The Digital Black Atlantic, pp. 77-83, https://muse.jhu.edu/book/84470. Grimmer, Justin, Roberts, Margaret und Stewart, Brandon (2022), Text as Data. A New Framework for Machine Learning and the Social Sciences, https://fu-berlin.primo.exlibrisgroup.com/permalink/49KOBV_FUB/1v1tp5h/alma9960725495502883. Jurafsky, Daniel und Martin, James H. (2023). Speech and Language Processing, Ch. 3 und 6, https://web.stanford.edu/~jurafsky/slp3/. Quanteda-Website: https://quanteda.io/ Quanteda Tutorials: https://tutorials.quanteda.io/ Quanteda Quick Start Guide: https://quanteda.io/articles/quickstart.html Sanchez, Gaston (2014), Handling and Processing Strings in R, https://gotellilab.github.io/Bio381/Scripts/Feb07/HandlingAndProcessingStringsInR.pdf Ushey, Kevin (2018), String Encoding and R, https://kevinushey.github.io/blog/2018/02/21/string-encoding-and-r/ "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
